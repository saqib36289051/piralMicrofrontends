"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonInjector = exports.StoreInjector = exports.HarInjector = exports.ProxyInjector = exports.ScriptInjector = exports.withInjectors = void 0;
const form_data_1 = __importDefault(require("form-data"));
const fs_1 = require("fs");
const path_1 = require("path");
const url_1 = require("url");
const helpers_1 = require("../helpers");
const info_1 = require("../info");
const har_injector_1 = __importDefault(require("./har-injector"));
exports.HarInjector = har_injector_1.default;
const json_injector_1 = __importDefault(require("./json-injector"));
exports.JsonInjector = json_injector_1.default;
const proxy_injector_1 = __importDefault(require("./proxy-injector"));
exports.ProxyInjector = proxy_injector_1.default;
const script_injector_1 = __importDefault(require("./script-injector"));
exports.ScriptInjector = script_injector_1.default;
const store_injector_1 = __importDefault(require("./store-injector"));
exports.StoreInjector = store_injector_1.default;
const specialHeaders = ['origin', 'content-type'];
const coreInjectors = {
    har: har_injector_1.default,
    json: json_injector_1.default,
    proxy: proxy_injector_1.default,
    script: script_injector_1.default,
    store: store_injector_1.default,
};
function sendResponse(req, ans, res) {
    if (!ans.redirectUrl) {
        const origin = req.headers.origin;
        const type = (0, helpers_1.getLast)(ans.headers['content-type']);
        for (const headerName of Object.keys(ans.headers)) {
            if (specialHeaders.indexOf(headerName) === -1) {
                res.setHeader(headerName, ans.headers[headerName]);
            }
        }
        if (origin) {
            res.setHeader('Access-Control-Allow-Origin', origin);
        }
        res.setHeader('Access-Control-Allow-Credentials', 'true');
        res.status(ans.status.code);
        res.type(type);
        res.end(ans.content);
    }
    else {
        const target = (0, url_1.parse)(ans.redirectUrl);
        res.redirect(ans.status.code, target.path);
    }
}
function normalizeTarget(head) {
    return head.endsWith('/') ? head.substring(0, head.length - 1) : head;
}
function getTarget(targets, url) {
    for (const target of targets) {
        if (url.startsWith(target)) {
            const c = url[target.length];
            if (c === undefined || c === '?' || c === '/') {
                return target;
            }
        }
    }
    return undefined;
}
function normalizeRequest(targets, req) {
    const target = getTarget(targets, req.originalUrl) || '';
    const url = req.originalUrl.substring(target.length);
    const headers = (0, helpers_1.deepMerge)(Object.assign({}, req.headers), req.addedHeaders);
    const query = (0, helpers_1.deepMerge)(Object.assign({}, req.query), req.addedQuery);
    const method = typeof req.method === 'string' ? req.method : 'GET';
    let content;
    if (req.headers['content-type'] && req.headers['content-type'].search('multipart/form-data') !== -1) {
        const formData = new form_data_1.default();
        typeof req.body === 'object' &&
            Object.keys(req.body).map((field) => {
                return formData.append(field, req.body[field]);
            });
        req.files &&
            req.files.length &&
            Array.prototype.map.call(req.files, (file) => {
                return formData.append(file.fieldname, file.buffer, {
                    filename: file.originalname,
                });
            });
        headers['content-type'] = formData.getHeaders()['content-type'];
        content = formData;
    }
    else {
        content = typeof req.body === 'string' ? req.body : '';
    }
    for (const name of req.removedHeaders) {
        delete headers[name];
    }
    for (const name of req.removedQuery) {
        delete query[name];
    }
    return {
        url,
        encrypted: (0, helpers_1.isEncrypted)(req),
        port: (0, helpers_1.getPort)(req),
        remoteAddress: req.connection.remoteAddress || req.socket.remoteAddress,
        target,
        query,
        method,
        headers,
        content,
    };
}
function tryInjectors(injectors, req) {
    return __awaiter(this, void 0, void 0, function* () {
        if (injectors.length > 0) {
            const injector = injectors.shift();
            const { ignore, handle } = injector.config || { ignore: undefined, handle: undefined };
            const ignored = ignore && ignore.some((t) => normalizeTarget(t) === req.target);
            const handled = !handle || handle.some((t) => normalizeTarget(t) === req.target);
            const response = !ignored && handled && (yield injector.handle(req));
            return response || tryInjectors(injectors, req);
        }
        return undefined;
    });
}
function handleRequest(server, req, res) {
    const injectors = server.injectors.filter((injector) => injector.active);
    server.emit('request', req);
    tryInjectors(injectors, req).then((ans) => __awaiter(this, void 0, void 0, function* () {
        res.prepared = ans;
        if (!ans) {
            server.emit('missing', req);
            ans = (0, helpers_1.fromMissing)(req.url);
        }
        else {
            server.emit('response', ans);
        }
        for (const middleware of res.middlewares) {
            yield middleware();
        }
        sendResponse(req, ans, res);
    }));
}
function findInjector(modulePath) {
    try {
        const { default: Injector } = require(modulePath);
        return Injector;
    }
    catch (e) {
        return undefined;
    }
}
function findInjectorIn(injectorDir, name) {
    const paths = Array.isArray(injectorDir) ? injectorDir : typeof injectorDir === 'string' ? [injectorDir] : [];
    for (const path of paths) {
        const target = (0, path_1.resolve)(path, name);
        const Injector = findInjector(target);
        if (Injector) {
            return Injector;
        }
    }
    return undefined;
}
function addInjectorInstance(Injector, options, config, server) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Injector) {
            const instance = new Injector(options, config, server);
            if (typeof instance.setup === 'function') {
                yield instance.setup();
            }
            if (typeof instance.handle === 'function') {
                server.injectors.push(instance);
            }
        }
    });
}
function withInjectors(server, config) {
    return __awaiter(this, void 0, void 0, function* () {
        const names = Object.keys(config.injectors);
        const heads = Object.keys(config.map)
            .map((head) => normalizeTarget(head))
            .sort((a, b) => b.length - a.length);
        const ignored = Object.keys(config.map)
            .filter((head) => config.map[head] === false)
            .map((head) => normalizeTarget(head));
        const always = heads.length === 0;
        if (info_1.injectorDebug) {
            const Injector = findInjector(info_1.injectorMain);
            yield addInjectorInstance(Injector, info_1.injectorConfig, config, server);
        }
        for (const name of names) {
            const isPath = (0, path_1.basename)(name) !== name && (0, fs_1.existsSync)(name);
            const options = config.injectors[name];
            const Injector = coreInjectors[name] ||
                (isPath && findInjector(name)) ||
                findInjectorIn(config.injectorDirs, `${name}-injector`) ||
                findInjectorIn(options.baseDir, `${name}-injector`) ||
                findInjector(`kras-${name}-injector`) ||
                findInjector(`${name}-kras-injector`) ||
                findInjector(`${name}-injector`);
            yield addInjectorInstance(Injector, options, config, server);
        }
        server.add({
            rate: (req) => {
                if (!always) {
                    const target = getTarget(heads, req.url);
                    const hasTarget = target !== undefined;
                    return hasTarget && !ignored.includes(target) ? 1 : 0;
                }
                return 1;
            },
            handle: (req, res) => {
                const entry = normalizeRequest(heads, req);
                return handleRequest(server, entry, res);
            },
        });
    });
}
exports.withInjectors = withInjectors;
