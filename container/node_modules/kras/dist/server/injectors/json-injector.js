"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const faker = __importStar(require("faker"));
const cookie = __importStar(require("cookie"));
const parser = __importStar(require("accept-language-parser"));
const faker_locale_1 = __importDefault(require("../helpers/faker-locale"));
const generate_from_template_1 = require("../helpers/generate-from-template");
const helpers_1 = require("../helpers");
function find(response, randomize) {
    if (Array.isArray(response)) {
        const index = randomize ? Math.floor(Math.random() * response.length) : 0;
        return response[index];
    }
    return response;
}
class JsonInjector {
    constructor(options, config) {
        this.files = [];
        const directory = options.directory || config.sources || config.directory;
        this.config = options;
        this.watcher = (0, helpers_1.watch)(directory, '**/*.json', (ev, fileName, position) => {
            switch (ev) {
                case 'create':
                case 'update':
                    return this.load(fileName, position);
                case 'delete':
                    return this.unload(fileName);
            }
        });
    }
    getOptions() {
        return {
            randomize: {
                description: `If active randomizes the selected response. Only applicable in case where multiple responses are found for a given request.`,
                title: `Randomize Response`,
                type: 'checkbox',
                value: this.config.randomize || false,
            },
            directories: (0, helpers_1.editDirectoryOption)(this.watcher.directories),
            files: (0, helpers_1.editEntryOption)(this.files, ({ request }) => `${request.method} ${request.url}`),
        };
    }
    setOptions(options) {
        this.config.randomize = options.randomize;
        for (const { name, entries } of options.files) {
            const files = this.files.find((m) => m[0].file === name);
            if (entries) {
                for (let i = 0; i < entries.length; i++) {
                    const entry = entries[i];
                    const file = files[i];
                    if (file && typeof entry.active === 'boolean') {
                        file.active = entry.active;
                    }
                }
            }
        }
        this.watcher.directories = options.directories;
    }
    get name() {
        return 'json-injector';
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    unload(fileName) {
        const index = this.files.findIndex((m) => m[0].file === fileName);
        if (index !== -1) {
            this.files.splice(index, 1);
        }
    }
    load(fileName, position) {
        const content = (0, helpers_1.asJson)(fileName, []);
        const items = Array.isArray(content) ? content : [content];
        for (const item of items) {
            item.file = fileName;
            item.active = true;
            if (typeof item.request !== 'object') {
                item.request = {};
            }
            if (typeof item.response !== 'object') {
                item.response = {};
            }
        }
        this.unload(fileName);
        if (items.length > 0) {
            this.files.splice(position, 0, items);
        }
    }
    dispose() {
        this.watcher.close();
    }
    contentProcess(req, content) {
        if (this.config.generator) {
            const localeName = this.config.generatorLocaleName || 'language';
            const cookies = cookie.parse(req.headers.cookie || '');
            const acceptLanguage = parser.parse(req.headers['accept-language']);
            let locale = 'en';
            if (req.query[localeName]) {
                locale = (0, helpers_1.getFirst)(req.query[localeName]);
            }
            else if (cookies[localeName]) {
                locale = cookies[localeName];
            }
            else if (acceptLanguage.length && acceptLanguage[0].code) {
                locale = acceptLanguage[0].code;
            }
            // Convert like: en, en-US to en_US
            faker.setLocale((0, faker_locale_1.default)(locale) || locale);
            // Ignore Buffer content
            if (Buffer.isBuffer(content)) {
                return content;
            }
            if (typeof content === 'string') {
                content = JSON.parse(content);
            }
            const templateJson = (0, generate_from_template_1.generateFromTemplate)(content);
            return JSON.stringify(templateJson);
        }
        return content;
    }
    handle(req) {
        let i = 0;
        for (const files of this.files) {
            for (const { file, active, request, response } of files) {
                if (active) {
                    if ((0, helpers_1.compareRequests)(request, req)) {
                        const rand = this.config.randomize;
                        const res = find(response, rand);
                        const name = this.name;
                        const content = this.contentProcess(req, res.content);
                        return (0, helpers_1.fromJson)(request.url, res.status.code, res.status.text, res.headers, content, {
                            name,
                            file: {
                                name: file,
                                entry: i,
                            },
                        });
                    }
                }
                i++;
            }
        }
    }
}
exports.default = JsonInjector;
