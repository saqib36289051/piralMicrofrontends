var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// ../../../node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../../node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs2) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs2);
      }
      if (!fs2.lutimes) {
        patchLutimes(fs2);
      }
      fs2.chown = chownFix(fs2.chown);
      fs2.fchown = chownFix(fs2.fchown);
      fs2.lchown = chownFix(fs2.lchown);
      fs2.chmod = chmodFix(fs2.chmod);
      fs2.fchmod = chmodFix(fs2.fchmod);
      fs2.lchmod = chmodFix(fs2.lchmod);
      fs2.chownSync = chownFixSync(fs2.chownSync);
      fs2.fchownSync = chownFixSync(fs2.fchownSync);
      fs2.lchownSync = chownFixSync(fs2.lchownSync);
      fs2.chmodSync = chmodFixSync(fs2.chmodSync);
      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
      fs2.stat = statFix(fs2.stat);
      fs2.fstat = statFix(fs2.fstat);
      fs2.lstat = statFix(fs2.lstat);
      fs2.statSync = statFixSync(fs2.statSync);
      fs2.fstatSync = statFixSync(fs2.fstatSync);
      fs2.lstatSync = statFixSync(fs2.lstatSync);
      if (fs2.chmod && !fs2.lchmod) {
        fs2.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchmodSync = function() {
        };
      }
      if (fs2.chown && !fs2.lchown) {
        fs2.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs2.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs2.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs2.rename);
      }
      fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs2.read);
      fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs2, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs2.readSync);
      function patchLchmod(fs3) {
        fs3.lchmod = function(path, mode, callback) {
          fs3.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs3.fchmod(fd, mode, function(err2) {
              fs3.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs3.lchmodSync = function(path, mode) {
          var fd = fs3.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs3.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs3.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs3.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs3) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs3.futimes) {
          fs3.lutimes = function(path, at, mt, cb) {
            fs3.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs3.futimes(fd, at, mt, function(er2) {
                fs3.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs3.lutimesSync = function(path, at, mt) {
            var fd = fs3.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs3.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs3.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs3.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs3.futimes) {
          fs3.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs3.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs2, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs2, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs2, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs2, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../../node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../../node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs2) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs2.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs2.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../../node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../../node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../../node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../../node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs2 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs2[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs2, queue);
      fs2.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs2, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs2.close);
      fs2.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs2, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs2.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs2[gracefulQueue]);
          require("assert").equal(fs2[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs2[gracefulQueue]);
    }
    module2.exports = patch(clone(fs2));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
      module2.exports = patch(fs2);
      fs2.__patched = true;
    }
    function patch(fs3) {
      polyfills(fs3);
      fs3.gracefulify = patch;
      fs3.createReadStream = createReadStream;
      fs3.createWriteStream = createWriteStream;
      var fs$readFile = fs3.readFile;
      fs3.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs3.writeFile;
      fs3.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs3.appendFile;
      if (fs$appendFile)
        fs3.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs3.copyFile;
      if (fs$copyFile)
        fs3.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs3.readdir;
      fs3.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs3);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs3.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs3.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs3, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs3, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs3, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs3, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs3.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs3.WriteStream(path, options);
      }
      var fs$open = fs3.open;
      fs3.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs3;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs2[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
        if (fs2[gracefulQueue][i].length > 2) {
          fs2[gracefulQueue][i][3] = now;
          fs2[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs2[gracefulQueue].length === 0)
        return;
      var elem = fs2[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs2[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../../node_modules/enhanced-resolve/lib/CachedInputFileSystem.js
var require_CachedInputFileSystem = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/CachedInputFileSystem.js"(exports, module2) {
    "use strict";
    var nextTick = require("process").nextTick;
    var dirname2 = (path) => {
      let idx = path.length - 1;
      while (idx >= 0) {
        const c = path.charCodeAt(idx);
        if (c === 47 || c === 92)
          break;
        idx--;
      }
      if (idx < 0)
        return "";
      return path.slice(0, idx);
    };
    var runCallbacks = (callbacks, err, result) => {
      if (callbacks.length === 1) {
        callbacks[0](err, result);
        callbacks.length = 0;
        return;
      }
      let error;
      for (const callback of callbacks) {
        try {
          callback(err, result);
        } catch (e) {
          if (!error)
            error = e;
        }
      }
      callbacks.length = 0;
      if (error)
        throw error;
    };
    var OperationMergerBackend = class {
      constructor(provider, syncProvider, providerContext) {
        this._provider = provider;
        this._syncProvider = syncProvider;
        this._providerContext = providerContext;
        this._activeAsyncOperations = new Map();
        this.provide = this._provider ? (path, options, callback) => {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
          if (options) {
            return this._provider.call(this._providerContext, path, options, callback);
          }
          if (typeof path !== "string") {
            callback(new TypeError("path must be a string"));
            return;
          }
          let callbacks = this._activeAsyncOperations.get(path);
          if (callbacks) {
            callbacks.push(callback);
            return;
          }
          this._activeAsyncOperations.set(path, callbacks = [callback]);
          provider(path, (err, result) => {
            this._activeAsyncOperations.delete(path);
            runCallbacks(callbacks, err, result);
          });
        } : null;
        this.provideSync = this._syncProvider ? (path, options) => {
          return this._syncProvider.call(this._providerContext, path, options);
        } : null;
      }
      purge() {
      }
      purgeParent() {
      }
    };
    var STORAGE_MODE_IDLE = 0;
    var STORAGE_MODE_SYNC = 1;
    var STORAGE_MODE_ASYNC = 2;
    var CacheBackend = class {
      constructor(duration, provider, syncProvider, providerContext) {
        this._duration = duration;
        this._provider = provider;
        this._syncProvider = syncProvider;
        this._providerContext = providerContext;
        this._activeAsyncOperations = new Map();
        this._data = new Map();
        this._levels = [];
        for (let i = 0; i < 10; i++)
          this._levels.push(new Set());
        for (let i = 5e3; i < duration; i += 500)
          this._levels.push(new Set());
        this._currentLevel = 0;
        this._tickInterval = Math.floor(duration / this._levels.length);
        this._mode = STORAGE_MODE_IDLE;
        this._timeout = void 0;
        this._nextDecay = void 0;
        this.provide = provider ? this.provide.bind(this) : null;
        this.provideSync = syncProvider ? this.provideSync.bind(this) : null;
      }
      provide(path, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof path !== "string") {
          callback(new TypeError("path must be a string"));
          return;
        }
        if (options) {
          return this._provider.call(this._providerContext, path, options, callback);
        }
        if (this._mode === STORAGE_MODE_SYNC) {
          this._enterAsyncMode();
        }
        let cacheEntry = this._data.get(path);
        if (cacheEntry !== void 0) {
          if (cacheEntry.err)
            return nextTick(callback, cacheEntry.err);
          return nextTick(callback, null, cacheEntry.result);
        }
        let callbacks = this._activeAsyncOperations.get(path);
        if (callbacks !== void 0) {
          callbacks.push(callback);
          return;
        }
        this._activeAsyncOperations.set(path, callbacks = [callback]);
        this._provider.call(this._providerContext, path, (err, result) => {
          this._activeAsyncOperations.delete(path);
          this._storeResult(path, err, result);
          this._enterAsyncMode();
          runCallbacks(callbacks, err, result);
        });
      }
      provideSync(path, options) {
        if (typeof path !== "string") {
          throw new TypeError("path must be a string");
        }
        if (options) {
          return this._syncProvider.call(this._providerContext, path, options);
        }
        if (this._mode === STORAGE_MODE_SYNC) {
          this._runDecays();
        }
        let cacheEntry = this._data.get(path);
        if (cacheEntry !== void 0) {
          if (cacheEntry.err)
            throw cacheEntry.err;
          return cacheEntry.result;
        }
        const callbacks = this._activeAsyncOperations.get(path);
        this._activeAsyncOperations.delete(path);
        let result;
        try {
          result = this._syncProvider.call(this._providerContext, path);
        } catch (err) {
          this._storeResult(path, err, void 0);
          this._enterSyncModeWhenIdle();
          if (callbacks) {
            runCallbacks(callbacks, err, void 0);
          }
          throw err;
        }
        this._storeResult(path, void 0, result);
        this._enterSyncModeWhenIdle();
        if (callbacks) {
          runCallbacks(callbacks, void 0, result);
        }
        return result;
      }
      purge(what) {
        if (!what) {
          if (this._mode !== STORAGE_MODE_IDLE) {
            this._data.clear();
            for (const level of this._levels) {
              level.clear();
            }
            this._enterIdleMode();
          }
        } else if (typeof what === "string") {
          for (let [key, data] of this._data) {
            if (key.startsWith(what)) {
              this._data.delete(key);
              data.level.delete(key);
            }
          }
          if (this._data.size === 0) {
            this._enterIdleMode();
          }
        } else {
          for (let [key, data] of this._data) {
            for (const item of what) {
              if (key.startsWith(item)) {
                this._data.delete(key);
                data.level.delete(key);
                break;
              }
            }
          }
          if (this._data.size === 0) {
            this._enterIdleMode();
          }
        }
      }
      purgeParent(what) {
        if (!what) {
          this.purge();
        } else if (typeof what === "string") {
          this.purge(dirname2(what));
        } else {
          const set = new Set();
          for (const item of what) {
            set.add(dirname2(item));
          }
          this.purge(set);
        }
      }
      _storeResult(path, err, result) {
        if (this._data.has(path))
          return;
        const level = this._levels[this._currentLevel];
        this._data.set(path, { err, result, level });
        level.add(path);
      }
      _decayLevel() {
        const nextLevel = (this._currentLevel + 1) % this._levels.length;
        const decay = this._levels[nextLevel];
        this._currentLevel = nextLevel;
        for (let item of decay) {
          this._data.delete(item);
        }
        decay.clear();
        if (this._data.size === 0) {
          this._enterIdleMode();
        } else {
          this._nextDecay += this._tickInterval;
        }
      }
      _runDecays() {
        while (this._nextDecay <= Date.now() && this._mode !== STORAGE_MODE_IDLE) {
          this._decayLevel();
        }
      }
      _enterAsyncMode() {
        let timeout = 0;
        switch (this._mode) {
          case STORAGE_MODE_ASYNC:
            return;
          case STORAGE_MODE_IDLE:
            this._nextDecay = Date.now() + this._tickInterval;
            timeout = this._tickInterval;
            break;
          case STORAGE_MODE_SYNC:
            this._runDecays();
            if (this._mode === STORAGE_MODE_IDLE)
              return;
            timeout = Math.max(0, this._nextDecay - Date.now());
            break;
        }
        this._mode = STORAGE_MODE_ASYNC;
        const ref = setTimeout(() => {
          this._mode = STORAGE_MODE_SYNC;
          this._runDecays();
        }, timeout);
        if (ref.unref)
          ref.unref();
        this._timeout = ref;
      }
      _enterSyncModeWhenIdle() {
        if (this._mode === STORAGE_MODE_IDLE) {
          this._mode = STORAGE_MODE_SYNC;
          this._nextDecay = Date.now() + this._tickInterval;
        }
      }
      _enterIdleMode() {
        this._mode = STORAGE_MODE_IDLE;
        this._nextDecay = void 0;
        if (this._timeout)
          clearTimeout(this._timeout);
      }
    };
    var createBackend = (duration, provider, syncProvider, providerContext) => {
      if (duration > 0) {
        return new CacheBackend(duration, provider, syncProvider, providerContext);
      }
      return new OperationMergerBackend(provider, syncProvider, providerContext);
    };
    module2.exports = class CachedInputFileSystem {
      constructor(fileSystem, duration) {
        this.fileSystem = fileSystem;
        this._lstatBackend = createBackend(duration, this.fileSystem.lstat, this.fileSystem.lstatSync, this.fileSystem);
        const lstat = this._lstatBackend.provide;
        this.lstat = lstat;
        const lstatSync = this._lstatBackend.provideSync;
        this.lstatSync = lstatSync;
        this._statBackend = createBackend(duration, this.fileSystem.stat, this.fileSystem.statSync, this.fileSystem);
        const stat = this._statBackend.provide;
        this.stat = stat;
        const statSync = this._statBackend.provideSync;
        this.statSync = statSync;
        this._readdirBackend = createBackend(duration, this.fileSystem.readdir, this.fileSystem.readdirSync, this.fileSystem);
        const readdir = this._readdirBackend.provide;
        this.readdir = readdir;
        const readdirSync = this._readdirBackend.provideSync;
        this.readdirSync = readdirSync;
        this._readFileBackend = createBackend(duration, this.fileSystem.readFile, this.fileSystem.readFileSync, this.fileSystem);
        const readFile = this._readFileBackend.provide;
        this.readFile = readFile;
        const readFileSync2 = this._readFileBackend.provideSync;
        this.readFileSync = readFileSync2;
        this._readJsonBackend = createBackend(duration, this.fileSystem.readJson || this.readFile && ((path, callback) => {
          this.readFile(path, (err, buffer) => {
            if (err)
              return callback(err);
            if (!buffer || buffer.length === 0)
              return callback(new Error("No file content"));
            let data;
            try {
              data = JSON.parse(buffer.toString("utf-8"));
            } catch (e) {
              return callback(e);
            }
            callback(null, data);
          });
        }), this.fileSystem.readJsonSync || this.readFileSync && ((path) => {
          const buffer = this.readFileSync(path);
          const data = JSON.parse(buffer.toString("utf-8"));
          return data;
        }), this.fileSystem);
        const readJson = this._readJsonBackend.provide;
        this.readJson = readJson;
        const readJsonSync = this._readJsonBackend.provideSync;
        this.readJsonSync = readJsonSync;
        this._readlinkBackend = createBackend(duration, this.fileSystem.readlink, this.fileSystem.readlinkSync, this.fileSystem);
        const readlink = this._readlinkBackend.provide;
        this.readlink = readlink;
        const readlinkSync = this._readlinkBackend.provideSync;
        this.readlinkSync = readlinkSync;
      }
      purge(what) {
        this._statBackend.purge(what);
        this._lstatBackend.purge(what);
        this._readdirBackend.purgeParent(what);
        this._readFileBackend.purge(what);
        this._readlinkBackend.purge(what);
        this._readJsonBackend.purge(what);
      }
    };
  }
});

// ../../../node_modules/tapable/lib/Hook.js
var require_Hook = __commonJS({
  "../../../node_modules/tapable/lib/Hook.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var deprecateContext = util.deprecate(() => {
    }, "Hook.context is deprecated and will be removed");
    var CALL_DELEGATE = function(...args) {
      this.call = this._createCall("sync");
      return this.call(...args);
    };
    var CALL_ASYNC_DELEGATE = function(...args) {
      this.callAsync = this._createCall("async");
      return this.callAsync(...args);
    };
    var PROMISE_DELEGATE = function(...args) {
      this.promise = this._createCall("promise");
      return this.promise(...args);
    };
    var Hook = class {
      constructor(args = [], name = void 0) {
        this._args = args;
        this.name = name;
        this.taps = [];
        this.interceptors = [];
        this._call = CALL_DELEGATE;
        this.call = CALL_DELEGATE;
        this._callAsync = CALL_ASYNC_DELEGATE;
        this.callAsync = CALL_ASYNC_DELEGATE;
        this._promise = PROMISE_DELEGATE;
        this.promise = PROMISE_DELEGATE;
        this._x = void 0;
        this.compile = this.compile;
        this.tap = this.tap;
        this.tapAsync = this.tapAsync;
        this.tapPromise = this.tapPromise;
      }
      compile(options) {
        throw new Error("Abstract: should be overridden");
      }
      _createCall(type) {
        return this.compile({
          taps: this.taps,
          interceptors: this.interceptors,
          args: this._args,
          type
        });
      }
      _tap(type, options, fn) {
        if (typeof options === "string") {
          options = {
            name: options.trim()
          };
        } else if (typeof options !== "object" || options === null) {
          throw new Error("Invalid tap options");
        }
        if (typeof options.name !== "string" || options.name === "") {
          throw new Error("Missing name for tap");
        }
        if (typeof options.context !== "undefined") {
          deprecateContext();
        }
        options = Object.assign({ type, fn }, options);
        options = this._runRegisterInterceptors(options);
        this._insert(options);
      }
      tap(options, fn) {
        this._tap("sync", options, fn);
      }
      tapAsync(options, fn) {
        this._tap("async", options, fn);
      }
      tapPromise(options, fn) {
        this._tap("promise", options, fn);
      }
      _runRegisterInterceptors(options) {
        for (const interceptor of this.interceptors) {
          if (interceptor.register) {
            const newOptions = interceptor.register(options);
            if (newOptions !== void 0) {
              options = newOptions;
            }
          }
        }
        return options;
      }
      withOptions(options) {
        const mergeOptions = (opt) => Object.assign({}, options, typeof opt === "string" ? { name: opt } : opt);
        return {
          name: this.name,
          tap: (opt, fn) => this.tap(mergeOptions(opt), fn),
          tapAsync: (opt, fn) => this.tapAsync(mergeOptions(opt), fn),
          tapPromise: (opt, fn) => this.tapPromise(mergeOptions(opt), fn),
          intercept: (interceptor) => this.intercept(interceptor),
          isUsed: () => this.isUsed(),
          withOptions: (opt) => this.withOptions(mergeOptions(opt))
        };
      }
      isUsed() {
        return this.taps.length > 0 || this.interceptors.length > 0;
      }
      intercept(interceptor) {
        this._resetCompilation();
        this.interceptors.push(Object.assign({}, interceptor));
        if (interceptor.register) {
          for (let i = 0; i < this.taps.length; i++) {
            this.taps[i] = interceptor.register(this.taps[i]);
          }
        }
      }
      _resetCompilation() {
        this.call = this._call;
        this.callAsync = this._callAsync;
        this.promise = this._promise;
      }
      _insert(item) {
        this._resetCompilation();
        let before;
        if (typeof item.before === "string") {
          before = new Set([item.before]);
        } else if (Array.isArray(item.before)) {
          before = new Set(item.before);
        }
        let stage = 0;
        if (typeof item.stage === "number") {
          stage = item.stage;
        }
        let i = this.taps.length;
        while (i > 0) {
          i--;
          const x = this.taps[i];
          this.taps[i + 1] = x;
          const xStage = x.stage || 0;
          if (before) {
            if (before.has(x.name)) {
              before.delete(x.name);
              continue;
            }
            if (before.size > 0) {
              continue;
            }
          }
          if (xStage > stage) {
            continue;
          }
          i++;
          break;
        }
        this.taps[i] = item;
      }
    };
    Object.setPrototypeOf(Hook.prototype, null);
    module2.exports = Hook;
  }
});

// ../../../node_modules/tapable/lib/HookCodeFactory.js
var require_HookCodeFactory = __commonJS({
  "../../../node_modules/tapable/lib/HookCodeFactory.js"(exports, module2) {
    "use strict";
    var HookCodeFactory = class {
      constructor(config) {
        this.config = config;
        this.options = void 0;
        this._args = void 0;
      }
      create(options) {
        this.init(options);
        let fn;
        switch (this.options.type) {
          case "sync":
            fn = new Function(this.args(), '"use strict";\n' + this.header() + this.contentWithInterceptors({
              onError: (err) => `throw ${err};
`,
              onResult: (result) => `return ${result};
`,
              resultReturns: true,
              onDone: () => "",
              rethrowIfPossible: true
            }));
            break;
          case "async":
            fn = new Function(this.args({
              after: "_callback"
            }), '"use strict";\n' + this.header() + this.contentWithInterceptors({
              onError: (err) => `_callback(${err});
`,
              onResult: (result) => `_callback(null, ${result});
`,
              onDone: () => "_callback();\n"
            }));
            break;
          case "promise":
            let errorHelperUsed = false;
            const content = this.contentWithInterceptors({
              onError: (err) => {
                errorHelperUsed = true;
                return `_error(${err});
`;
              },
              onResult: (result) => `_resolve(${result});
`,
              onDone: () => "_resolve();\n"
            });
            let code = "";
            code += '"use strict";\n';
            code += this.header();
            code += "return new Promise((function(_resolve, _reject) {\n";
            if (errorHelperUsed) {
              code += "var _sync = true;\n";
              code += "function _error(_err) {\n";
              code += "if(_sync)\n";
              code += "_resolve(Promise.resolve().then((function() { throw _err; })));\n";
              code += "else\n";
              code += "_reject(_err);\n";
              code += "};\n";
            }
            code += content;
            if (errorHelperUsed) {
              code += "_sync = false;\n";
            }
            code += "}));\n";
            fn = new Function(this.args(), code);
            break;
        }
        this.deinit();
        return fn;
      }
      setup(instance, options) {
        instance._x = options.taps.map((t) => t.fn);
      }
      init(options) {
        this.options = options;
        this._args = options.args.slice();
      }
      deinit() {
        this.options = void 0;
        this._args = void 0;
      }
      contentWithInterceptors(options) {
        if (this.options.interceptors.length > 0) {
          const onError = options.onError;
          const onResult = options.onResult;
          const onDone = options.onDone;
          let code = "";
          for (let i = 0; i < this.options.interceptors.length; i++) {
            const interceptor = this.options.interceptors[i];
            if (interceptor.call) {
              code += `${this.getInterceptor(i)}.call(${this.args({
                before: interceptor.context ? "_context" : void 0
              })});
`;
            }
          }
          code += this.content(Object.assign(options, {
            onError: onError && ((err) => {
              let code2 = "";
              for (let i = 0; i < this.options.interceptors.length; i++) {
                const interceptor = this.options.interceptors[i];
                if (interceptor.error) {
                  code2 += `${this.getInterceptor(i)}.error(${err});
`;
                }
              }
              code2 += onError(err);
              return code2;
            }),
            onResult: onResult && ((result) => {
              let code2 = "";
              for (let i = 0; i < this.options.interceptors.length; i++) {
                const interceptor = this.options.interceptors[i];
                if (interceptor.result) {
                  code2 += `${this.getInterceptor(i)}.result(${result});
`;
                }
              }
              code2 += onResult(result);
              return code2;
            }),
            onDone: onDone && (() => {
              let code2 = "";
              for (let i = 0; i < this.options.interceptors.length; i++) {
                const interceptor = this.options.interceptors[i];
                if (interceptor.done) {
                  code2 += `${this.getInterceptor(i)}.done();
`;
                }
              }
              code2 += onDone();
              return code2;
            })
          }));
          return code;
        } else {
          return this.content(options);
        }
      }
      header() {
        let code = "";
        if (this.needContext()) {
          code += "var _context = {};\n";
        } else {
          code += "var _context;\n";
        }
        code += "var _x = this._x;\n";
        if (this.options.interceptors.length > 0) {
          code += "var _taps = this.taps;\n";
          code += "var _interceptors = this.interceptors;\n";
        }
        return code;
      }
      needContext() {
        for (const tap of this.options.taps)
          if (tap.context)
            return true;
        return false;
      }
      callTap(tapIndex, { onError, onResult, onDone, rethrowIfPossible }) {
        let code = "";
        let hasTapCached = false;
        for (let i = 0; i < this.options.interceptors.length; i++) {
          const interceptor = this.options.interceptors[i];
          if (interceptor.tap) {
            if (!hasTapCached) {
              code += `var _tap${tapIndex} = ${this.getTap(tapIndex)};
`;
              hasTapCached = true;
            }
            code += `${this.getInterceptor(i)}.tap(${interceptor.context ? "_context, " : ""}_tap${tapIndex});
`;
          }
        }
        code += `var _fn${tapIndex} = ${this.getTapFn(tapIndex)};
`;
        const tap = this.options.taps[tapIndex];
        switch (tap.type) {
          case "sync":
            if (!rethrowIfPossible) {
              code += `var _hasError${tapIndex} = false;
`;
              code += "try {\n";
            }
            if (onResult) {
              code += `var _result${tapIndex} = _fn${tapIndex}(${this.args({
                before: tap.context ? "_context" : void 0
              })});
`;
            } else {
              code += `_fn${tapIndex}(${this.args({
                before: tap.context ? "_context" : void 0
              })});
`;
            }
            if (!rethrowIfPossible) {
              code += "} catch(_err) {\n";
              code += `_hasError${tapIndex} = true;
`;
              code += onError("_err");
              code += "}\n";
              code += `if(!_hasError${tapIndex}) {
`;
            }
            if (onResult) {
              code += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              code += onDone();
            }
            if (!rethrowIfPossible) {
              code += "}\n";
            }
            break;
          case "async":
            let cbCode = "";
            if (onResult)
              cbCode += `(function(_err${tapIndex}, _result${tapIndex}) {
`;
            else
              cbCode += `(function(_err${tapIndex}) {
`;
            cbCode += `if(_err${tapIndex}) {
`;
            cbCode += onError(`_err${tapIndex}`);
            cbCode += "} else {\n";
            if (onResult) {
              cbCode += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              cbCode += onDone();
            }
            cbCode += "}\n";
            cbCode += "})";
            code += `_fn${tapIndex}(${this.args({
              before: tap.context ? "_context" : void 0,
              after: cbCode
            })});
`;
            break;
          case "promise":
            code += `var _hasResult${tapIndex} = false;
`;
            code += `var _promise${tapIndex} = _fn${tapIndex}(${this.args({
              before: tap.context ? "_context" : void 0
            })});
`;
            code += `if (!_promise${tapIndex} || !_promise${tapIndex}.then)
`;
            code += `  throw new Error('Tap function (tapPromise) did not return promise (returned ' + _promise${tapIndex} + ')');
`;
            code += `_promise${tapIndex}.then((function(_result${tapIndex}) {
`;
            code += `_hasResult${tapIndex} = true;
`;
            if (onResult) {
              code += onResult(`_result${tapIndex}`);
            }
            if (onDone) {
              code += onDone();
            }
            code += `}), function(_err${tapIndex}) {
`;
            code += `if(_hasResult${tapIndex}) throw _err${tapIndex};
`;
            code += onError(`_err${tapIndex}`);
            code += "});\n";
            break;
        }
        return code;
      }
      callTapsSeries({
        onError,
        onResult,
        resultReturns,
        onDone,
        doneReturns,
        rethrowIfPossible
      }) {
        if (this.options.taps.length === 0)
          return onDone();
        const firstAsync = this.options.taps.findIndex((t) => t.type !== "sync");
        const somethingReturns = resultReturns || doneReturns;
        let code = "";
        let current = onDone;
        let unrollCounter = 0;
        for (let j = this.options.taps.length - 1; j >= 0; j--) {
          const i = j;
          const unroll = current !== onDone && (this.options.taps[i].type !== "sync" || unrollCounter++ > 20);
          if (unroll) {
            unrollCounter = 0;
            code += `function _next${i}() {
`;
            code += current();
            code += `}
`;
            current = () => `${somethingReturns ? "return " : ""}_next${i}();
`;
          }
          const done = current;
          const doneBreak = (skipDone) => {
            if (skipDone)
              return "";
            return onDone();
          };
          const content = this.callTap(i, {
            onError: (error) => onError(i, error, done, doneBreak),
            onResult: onResult && ((result) => {
              return onResult(i, result, done, doneBreak);
            }),
            onDone: !onResult && done,
            rethrowIfPossible: rethrowIfPossible && (firstAsync < 0 || i < firstAsync)
          });
          current = () => content;
        }
        code += current();
        return code;
      }
      callTapsLooping({ onError, onDone, rethrowIfPossible }) {
        if (this.options.taps.length === 0)
          return onDone();
        const syncOnly = this.options.taps.every((t) => t.type === "sync");
        let code = "";
        if (!syncOnly) {
          code += "var _looper = (function() {\n";
          code += "var _loopAsync = false;\n";
        }
        code += "var _loop;\n";
        code += "do {\n";
        code += "_loop = false;\n";
        for (let i = 0; i < this.options.interceptors.length; i++) {
          const interceptor = this.options.interceptors[i];
          if (interceptor.loop) {
            code += `${this.getInterceptor(i)}.loop(${this.args({
              before: interceptor.context ? "_context" : void 0
            })});
`;
          }
        }
        code += this.callTapsSeries({
          onError,
          onResult: (i, result, next, doneBreak) => {
            let code2 = "";
            code2 += `if(${result} !== undefined) {
`;
            code2 += "_loop = true;\n";
            if (!syncOnly)
              code2 += "if(_loopAsync) _looper();\n";
            code2 += doneBreak(true);
            code2 += `} else {
`;
            code2 += next();
            code2 += `}
`;
            return code2;
          },
          onDone: onDone && (() => {
            let code2 = "";
            code2 += "if(!_loop) {\n";
            code2 += onDone();
            code2 += "}\n";
            return code2;
          }),
          rethrowIfPossible: rethrowIfPossible && syncOnly
        });
        code += "} while(_loop);\n";
        if (!syncOnly) {
          code += "_loopAsync = true;\n";
          code += "});\n";
          code += "_looper();\n";
        }
        return code;
      }
      callTapsParallel({
        onError,
        onResult,
        onDone,
        rethrowIfPossible,
        onTap = (i, run) => run()
      }) {
        if (this.options.taps.length <= 1) {
          return this.callTapsSeries({
            onError,
            onResult,
            onDone,
            rethrowIfPossible
          });
        }
        let code = "";
        code += "do {\n";
        code += `var _counter = ${this.options.taps.length};
`;
        if (onDone) {
          code += "var _done = (function() {\n";
          code += onDone();
          code += "});\n";
        }
        for (let i = 0; i < this.options.taps.length; i++) {
          const done = () => {
            if (onDone)
              return "if(--_counter === 0) _done();\n";
            else
              return "--_counter;";
          };
          const doneBreak = (skipDone) => {
            if (skipDone || !onDone)
              return "_counter = 0;\n";
            else
              return "_counter = 0;\n_done();\n";
          };
          code += "if(_counter <= 0) break;\n";
          code += onTap(i, () => this.callTap(i, {
            onError: (error) => {
              let code2 = "";
              code2 += "if(_counter > 0) {\n";
              code2 += onError(i, error, done, doneBreak);
              code2 += "}\n";
              return code2;
            },
            onResult: onResult && ((result) => {
              let code2 = "";
              code2 += "if(_counter > 0) {\n";
              code2 += onResult(i, result, done, doneBreak);
              code2 += "}\n";
              return code2;
            }),
            onDone: !onResult && (() => {
              return done();
            }),
            rethrowIfPossible
          }), done, doneBreak);
        }
        code += "} while(false);\n";
        return code;
      }
      args({ before, after } = {}) {
        let allArgs = this._args;
        if (before)
          allArgs = [before].concat(allArgs);
        if (after)
          allArgs = allArgs.concat(after);
        if (allArgs.length === 0) {
          return "";
        } else {
          return allArgs.join(", ");
        }
      }
      getTapFn(idx) {
        return `_x[${idx}]`;
      }
      getTap(idx) {
        return `_taps[${idx}]`;
      }
      getInterceptor(idx) {
        return `_interceptors[${idx}]`;
      }
    };
    module2.exports = HookCodeFactory;
  }
});

// ../../../node_modules/tapable/lib/SyncHook.js
var require_SyncHook = __commonJS({
  "../../../node_modules/tapable/lib/SyncHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
          onError: (i, err) => onError(err),
          onDone,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncHookCodeFactory();
    var TAP_ASYNC = () => {
      throw new Error("tapAsync is not supported on a SyncHook");
    };
    var TAP_PROMISE = () => {
      throw new Error("tapPromise is not supported on a SyncHook");
    };
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function SyncHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = SyncHook;
      hook.tapAsync = TAP_ASYNC;
      hook.tapPromise = TAP_PROMISE;
      hook.compile = COMPILE;
      return hook;
    }
    SyncHook.prototype = null;
    module2.exports = SyncHook;
  }
});

// ../../../node_modules/tapable/lib/SyncBailHook.js
var require_SyncBailHook = __commonJS({
  "../../../node_modules/tapable/lib/SyncBailHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncBailHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, resultReturns, onDone, rethrowIfPossible }) {
        return this.callTapsSeries({
          onError: (i, err) => onError(err),
          onResult: (i, result, next) => `if(${result} !== undefined) {
${onResult(result)};
} else {
${next()}}
`,
          resultReturns,
          onDone,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncBailHookCodeFactory();
    var TAP_ASYNC = () => {
      throw new Error("tapAsync is not supported on a SyncBailHook");
    };
    var TAP_PROMISE = () => {
      throw new Error("tapPromise is not supported on a SyncBailHook");
    };
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function SyncBailHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = SyncBailHook;
      hook.tapAsync = TAP_ASYNC;
      hook.tapPromise = TAP_PROMISE;
      hook.compile = COMPILE;
      return hook;
    }
    SyncBailHook.prototype = null;
    module2.exports = SyncBailHook;
  }
});

// ../../../node_modules/tapable/lib/SyncWaterfallHook.js
var require_SyncWaterfallHook = __commonJS({
  "../../../node_modules/tapable/lib/SyncWaterfallHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncWaterfallHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, resultReturns, rethrowIfPossible }) {
        return this.callTapsSeries({
          onError: (i, err) => onError(err),
          onResult: (i, result, next) => {
            let code = "";
            code += `if(${result} !== undefined) {
`;
            code += `${this._args[0]} = ${result};
`;
            code += `}
`;
            code += next();
            return code;
          },
          onDone: () => onResult(this._args[0]),
          doneReturns: resultReturns,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncWaterfallHookCodeFactory();
    var TAP_ASYNC = () => {
      throw new Error("tapAsync is not supported on a SyncWaterfallHook");
    };
    var TAP_PROMISE = () => {
      throw new Error("tapPromise is not supported on a SyncWaterfallHook");
    };
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function SyncWaterfallHook(args = [], name = void 0) {
      if (args.length < 1)
        throw new Error("Waterfall hooks must have at least one argument");
      const hook = new Hook(args, name);
      hook.constructor = SyncWaterfallHook;
      hook.tapAsync = TAP_ASYNC;
      hook.tapPromise = TAP_PROMISE;
      hook.compile = COMPILE;
      return hook;
    }
    SyncWaterfallHook.prototype = null;
    module2.exports = SyncWaterfallHook;
  }
});

// ../../../node_modules/tapable/lib/SyncLoopHook.js
var require_SyncLoopHook = __commonJS({
  "../../../node_modules/tapable/lib/SyncLoopHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var SyncLoopHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone, rethrowIfPossible }) {
        return this.callTapsLooping({
          onError: (i, err) => onError(err),
          onDone,
          rethrowIfPossible
        });
      }
    };
    var factory = new SyncLoopHookCodeFactory();
    var TAP_ASYNC = () => {
      throw new Error("tapAsync is not supported on a SyncLoopHook");
    };
    var TAP_PROMISE = () => {
      throw new Error("tapPromise is not supported on a SyncLoopHook");
    };
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function SyncLoopHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = SyncLoopHook;
      hook.tapAsync = TAP_ASYNC;
      hook.tapPromise = TAP_PROMISE;
      hook.compile = COMPILE;
      return hook;
    }
    SyncLoopHook.prototype = null;
    module2.exports = SyncLoopHook;
  }
});

// ../../../node_modules/tapable/lib/AsyncParallelHook.js
var require_AsyncParallelHook = __commonJS({
  "../../../node_modules/tapable/lib/AsyncParallelHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncParallelHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone }) {
        return this.callTapsParallel({
          onError: (i, err, done, doneBreak) => onError(err) + doneBreak(true),
          onDone
        });
      }
    };
    var factory = new AsyncParallelHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncParallelHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncParallelHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncParallelHook.prototype = null;
    module2.exports = AsyncParallelHook;
  }
});

// ../../../node_modules/tapable/lib/AsyncParallelBailHook.js
var require_AsyncParallelBailHook = __commonJS({
  "../../../node_modules/tapable/lib/AsyncParallelBailHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncParallelBailHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, onDone }) {
        let code = "";
        code += `var _results = new Array(${this.options.taps.length});
`;
        code += "var _checkDone = function() {\n";
        code += "for(var i = 0; i < _results.length; i++) {\n";
        code += "var item = _results[i];\n";
        code += "if(item === undefined) return false;\n";
        code += "if(item.result !== undefined) {\n";
        code += onResult("item.result");
        code += "return true;\n";
        code += "}\n";
        code += "if(item.error) {\n";
        code += onError("item.error");
        code += "return true;\n";
        code += "}\n";
        code += "}\n";
        code += "return false;\n";
        code += "}\n";
        code += this.callTapsParallel({
          onError: (i, err, done, doneBreak) => {
            let code2 = "";
            code2 += `if(${i} < _results.length && ((_results.length = ${i + 1}), (_results[${i}] = { error: ${err} }), _checkDone())) {
`;
            code2 += doneBreak(true);
            code2 += "} else {\n";
            code2 += done();
            code2 += "}\n";
            return code2;
          },
          onResult: (i, result, done, doneBreak) => {
            let code2 = "";
            code2 += `if(${i} < _results.length && (${result} !== undefined && (_results.length = ${i + 1}), (_results[${i}] = { result: ${result} }), _checkDone())) {
`;
            code2 += doneBreak(true);
            code2 += "} else {\n";
            code2 += done();
            code2 += "}\n";
            return code2;
          },
          onTap: (i, run, done, doneBreak) => {
            let code2 = "";
            if (i > 0) {
              code2 += `if(${i} >= _results.length) {
`;
              code2 += done();
              code2 += "} else {\n";
            }
            code2 += run();
            if (i > 0)
              code2 += "}\n";
            return code2;
          },
          onDone
        });
        return code;
      }
    };
    var factory = new AsyncParallelBailHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncParallelBailHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncParallelBailHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncParallelBailHook.prototype = null;
    module2.exports = AsyncParallelBailHook;
  }
});

// ../../../node_modules/tapable/lib/AsyncSeriesHook.js
var require_AsyncSeriesHook = __commonJS({
  "../../../node_modules/tapable/lib/AsyncSeriesHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone }) {
        return this.callTapsSeries({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onDone
        });
      }
    };
    var factory = new AsyncSeriesHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncSeriesHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncSeriesHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncSeriesHook.prototype = null;
    module2.exports = AsyncSeriesHook;
  }
});

// ../../../node_modules/tapable/lib/AsyncSeriesBailHook.js
var require_AsyncSeriesBailHook = __commonJS({
  "../../../node_modules/tapable/lib/AsyncSeriesBailHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesBailHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, resultReturns, onDone }) {
        return this.callTapsSeries({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onResult: (i, result, next) => `if(${result} !== undefined) {
${onResult(result)}
} else {
${next()}}
`,
          resultReturns,
          onDone
        });
      }
    };
    var factory = new AsyncSeriesBailHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncSeriesBailHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncSeriesBailHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncSeriesBailHook.prototype = null;
    module2.exports = AsyncSeriesBailHook;
  }
});

// ../../../node_modules/tapable/lib/AsyncSeriesLoopHook.js
var require_AsyncSeriesLoopHook = __commonJS({
  "../../../node_modules/tapable/lib/AsyncSeriesLoopHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesLoopHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onDone }) {
        return this.callTapsLooping({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onDone
        });
      }
    };
    var factory = new AsyncSeriesLoopHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncSeriesLoopHook(args = [], name = void 0) {
      const hook = new Hook(args, name);
      hook.constructor = AsyncSeriesLoopHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncSeriesLoopHook.prototype = null;
    module2.exports = AsyncSeriesLoopHook;
  }
});

// ../../../node_modules/tapable/lib/AsyncSeriesWaterfallHook.js
var require_AsyncSeriesWaterfallHook = __commonJS({
  "../../../node_modules/tapable/lib/AsyncSeriesWaterfallHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var HookCodeFactory = require_HookCodeFactory();
    var AsyncSeriesWaterfallHookCodeFactory = class extends HookCodeFactory {
      content({ onError, onResult, onDone }) {
        return this.callTapsSeries({
          onError: (i, err, next, doneBreak) => onError(err) + doneBreak(true),
          onResult: (i, result, next) => {
            let code = "";
            code += `if(${result} !== undefined) {
`;
            code += `${this._args[0]} = ${result};
`;
            code += `}
`;
            code += next();
            return code;
          },
          onDone: () => onResult(this._args[0])
        });
      }
    };
    var factory = new AsyncSeriesWaterfallHookCodeFactory();
    var COMPILE = function(options) {
      factory.setup(this, options);
      return factory.create(options);
    };
    function AsyncSeriesWaterfallHook(args = [], name = void 0) {
      if (args.length < 1)
        throw new Error("Waterfall hooks must have at least one argument");
      const hook = new Hook(args, name);
      hook.constructor = AsyncSeriesWaterfallHook;
      hook.compile = COMPILE;
      hook._call = void 0;
      hook.call = void 0;
      return hook;
    }
    AsyncSeriesWaterfallHook.prototype = null;
    module2.exports = AsyncSeriesWaterfallHook;
  }
});

// ../../../node_modules/tapable/lib/HookMap.js
var require_HookMap = __commonJS({
  "../../../node_modules/tapable/lib/HookMap.js"(exports, module2) {
    "use strict";
    var util = require("util");
    var defaultFactory = (key, hook) => hook;
    var HookMap = class {
      constructor(factory, name = void 0) {
        this._map = new Map();
        this.name = name;
        this._factory = factory;
        this._interceptors = [];
      }
      get(key) {
        return this._map.get(key);
      }
      for(key) {
        const hook = this.get(key);
        if (hook !== void 0) {
          return hook;
        }
        let newHook = this._factory(key);
        const interceptors = this._interceptors;
        for (let i = 0; i < interceptors.length; i++) {
          newHook = interceptors[i].factory(key, newHook);
        }
        this._map.set(key, newHook);
        return newHook;
      }
      intercept(interceptor) {
        this._interceptors.push(Object.assign({
          factory: defaultFactory
        }, interceptor));
      }
    };
    HookMap.prototype.tap = util.deprecate(function(key, options, fn) {
      return this.for(key).tap(options, fn);
    }, "HookMap#tap(key,\u2026) is deprecated. Use HookMap#for(key).tap(\u2026) instead.");
    HookMap.prototype.tapAsync = util.deprecate(function(key, options, fn) {
      return this.for(key).tapAsync(options, fn);
    }, "HookMap#tapAsync(key,\u2026) is deprecated. Use HookMap#for(key).tapAsync(\u2026) instead.");
    HookMap.prototype.tapPromise = util.deprecate(function(key, options, fn) {
      return this.for(key).tapPromise(options, fn);
    }, "HookMap#tapPromise(key,\u2026) is deprecated. Use HookMap#for(key).tapPromise(\u2026) instead.");
    module2.exports = HookMap;
  }
});

// ../../../node_modules/tapable/lib/MultiHook.js
var require_MultiHook = __commonJS({
  "../../../node_modules/tapable/lib/MultiHook.js"(exports, module2) {
    "use strict";
    var Hook = require_Hook();
    var MultiHook = class {
      constructor(hooks, name = void 0) {
        this.hooks = hooks;
        this.name = name;
      }
      tap(options, fn) {
        for (const hook of this.hooks) {
          hook.tap(options, fn);
        }
      }
      tapAsync(options, fn) {
        for (const hook of this.hooks) {
          hook.tapAsync(options, fn);
        }
      }
      tapPromise(options, fn) {
        for (const hook of this.hooks) {
          hook.tapPromise(options, fn);
        }
      }
      isUsed() {
        for (const hook of this.hooks) {
          if (hook.isUsed())
            return true;
        }
        return false;
      }
      intercept(interceptor) {
        for (const hook of this.hooks) {
          hook.intercept(interceptor);
        }
      }
      withOptions(options) {
        return new MultiHook(this.hooks.map((h) => h.withOptions(options)), this.name);
      }
    };
    module2.exports = MultiHook;
  }
});

// ../../../node_modules/tapable/lib/index.js
var require_lib = __commonJS({
  "../../../node_modules/tapable/lib/index.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.SyncHook = require_SyncHook();
    exports.SyncBailHook = require_SyncBailHook();
    exports.SyncWaterfallHook = require_SyncWaterfallHook();
    exports.SyncLoopHook = require_SyncLoopHook();
    exports.AsyncParallelHook = require_AsyncParallelHook();
    exports.AsyncParallelBailHook = require_AsyncParallelBailHook();
    exports.AsyncSeriesHook = require_AsyncSeriesHook();
    exports.AsyncSeriesBailHook = require_AsyncSeriesBailHook();
    exports.AsyncSeriesLoopHook = require_AsyncSeriesLoopHook();
    exports.AsyncSeriesWaterfallHook = require_AsyncSeriesWaterfallHook();
    exports.HookMap = require_HookMap();
    exports.MultiHook = require_MultiHook();
  }
});

// ../../../node_modules/enhanced-resolve/lib/createInnerContext.js
var require_createInnerContext = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/createInnerContext.js"(exports, module2) {
    "use strict";
    module2.exports = function createInnerContext(options, message) {
      let messageReported = false;
      let innerLog = void 0;
      if (options.log) {
        if (message) {
          innerLog = (msg) => {
            if (!messageReported) {
              options.log(message);
              messageReported = true;
            }
            options.log("  " + msg);
          };
        } else {
          innerLog = options.log;
        }
      }
      return {
        log: innerLog,
        yield: options.yield,
        fileDependencies: options.fileDependencies,
        contextDependencies: options.contextDependencies,
        missingDependencies: options.missingDependencies,
        stack: options.stack
      };
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/util/identifier.js
var require_identifier = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/util/identifier.js"(exports, module2) {
    "use strict";
    var PATH_QUERY_FRAGMENT_REGEXP = /^(#?(?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
    function parseIdentifier(identifier) {
      const match = PATH_QUERY_FRAGMENT_REGEXP.exec(identifier);
      if (!match)
        return null;
      return [
        match[1].replace(/\0(.)/g, "$1"),
        match[2] ? match[2].replace(/\0(.)/g, "$1") : "",
        match[3] || ""
      ];
    }
    module2.exports.parseIdentifier = parseIdentifier;
  }
});

// ../../../node_modules/enhanced-resolve/lib/util/path.js
var require_path = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/util/path.js"(exports) {
    "use strict";
    var path = require("path");
    var CHAR_HASH = "#".charCodeAt(0);
    var CHAR_SLASH = "/".charCodeAt(0);
    var CHAR_BACKSLASH = "\\".charCodeAt(0);
    var CHAR_A = "A".charCodeAt(0);
    var CHAR_Z = "Z".charCodeAt(0);
    var CHAR_LOWER_A = "a".charCodeAt(0);
    var CHAR_LOWER_Z = "z".charCodeAt(0);
    var CHAR_DOT = ".".charCodeAt(0);
    var CHAR_COLON = ":".charCodeAt(0);
    var posixNormalize = path.posix.normalize;
    var winNormalize = path.win32.normalize;
    var PathType = Object.freeze({
      Empty: 0,
      Normal: 1,
      Relative: 2,
      AbsoluteWin: 3,
      AbsolutePosix: 4,
      Internal: 5
    });
    exports.PathType = PathType;
    var getType = (p) => {
      switch (p.length) {
        case 0:
          return PathType.Empty;
        case 1: {
          const c02 = p.charCodeAt(0);
          switch (c02) {
            case CHAR_DOT:
              return PathType.Relative;
            case CHAR_SLASH:
              return PathType.AbsolutePosix;
            case CHAR_HASH:
              return PathType.Internal;
          }
          return PathType.Normal;
        }
        case 2: {
          const c02 = p.charCodeAt(0);
          switch (c02) {
            case CHAR_DOT: {
              const c13 = p.charCodeAt(1);
              switch (c13) {
                case CHAR_DOT:
                case CHAR_SLASH:
                  return PathType.Relative;
              }
              return PathType.Normal;
            }
            case CHAR_SLASH:
              return PathType.AbsolutePosix;
            case CHAR_HASH:
              return PathType.Internal;
          }
          const c12 = p.charCodeAt(1);
          if (c12 === CHAR_COLON) {
            if (c02 >= CHAR_A && c02 <= CHAR_Z || c02 >= CHAR_LOWER_A && c02 <= CHAR_LOWER_Z) {
              return PathType.AbsoluteWin;
            }
          }
          return PathType.Normal;
        }
      }
      const c0 = p.charCodeAt(0);
      switch (c0) {
        case CHAR_DOT: {
          const c12 = p.charCodeAt(1);
          switch (c12) {
            case CHAR_SLASH:
              return PathType.Relative;
            case CHAR_DOT: {
              const c2 = p.charCodeAt(2);
              if (c2 === CHAR_SLASH)
                return PathType.Relative;
              return PathType.Normal;
            }
          }
          return PathType.Normal;
        }
        case CHAR_SLASH:
          return PathType.AbsolutePosix;
        case CHAR_HASH:
          return PathType.Internal;
      }
      const c1 = p.charCodeAt(1);
      if (c1 === CHAR_COLON) {
        const c2 = p.charCodeAt(2);
        if ((c2 === CHAR_BACKSLASH || c2 === CHAR_SLASH) && (c0 >= CHAR_A && c0 <= CHAR_Z || c0 >= CHAR_LOWER_A && c0 <= CHAR_LOWER_Z)) {
          return PathType.AbsoluteWin;
        }
      }
      return PathType.Normal;
    };
    exports.getType = getType;
    var normalize = (p) => {
      switch (getType(p)) {
        case PathType.Empty:
          return p;
        case PathType.AbsoluteWin:
          return winNormalize(p);
        case PathType.Relative: {
          const r = posixNormalize(p);
          return getType(r) === PathType.Relative ? r : `./${r}`;
        }
      }
      return posixNormalize(p);
    };
    exports.normalize = normalize;
    var join = (rootPath, request) => {
      if (!request)
        return normalize(rootPath);
      const requestType = getType(request);
      switch (requestType) {
        case PathType.AbsolutePosix:
          return posixNormalize(request);
        case PathType.AbsoluteWin:
          return winNormalize(request);
      }
      switch (getType(rootPath)) {
        case PathType.Normal:
        case PathType.Relative:
        case PathType.AbsolutePosix:
          return posixNormalize(`${rootPath}/${request}`);
        case PathType.AbsoluteWin:
          return winNormalize(`${rootPath}\\${request}`);
      }
      switch (requestType) {
        case PathType.Empty:
          return rootPath;
        case PathType.Relative: {
          const r = posixNormalize(rootPath);
          return getType(r) === PathType.Relative ? r : `./${r}`;
        }
      }
      return posixNormalize(rootPath);
    };
    exports.join = join;
    var joinCache = new Map();
    var cachedJoin = (rootPath, request) => {
      let cacheEntry;
      let cache = joinCache.get(rootPath);
      if (cache === void 0) {
        joinCache.set(rootPath, cache = new Map());
      } else {
        cacheEntry = cache.get(request);
        if (cacheEntry !== void 0)
          return cacheEntry;
      }
      cacheEntry = join(rootPath, request);
      cache.set(request, cacheEntry);
      return cacheEntry;
    };
    exports.cachedJoin = cachedJoin;
    var checkImportsExportsFieldTarget = (relativePath) => {
      let lastNonSlashIndex = 0;
      let slashIndex = relativePath.indexOf("/", 1);
      let cd = 0;
      while (slashIndex !== -1) {
        const folder = relativePath.slice(lastNonSlashIndex, slashIndex);
        switch (folder) {
          case "..": {
            cd--;
            if (cd < 0)
              return new Error(`Trying to access out of package scope. Requesting ${relativePath}`);
            break;
          }
          case ".":
            break;
          default:
            cd++;
            break;
        }
        lastNonSlashIndex = slashIndex + 1;
        slashIndex = relativePath.indexOf("/", lastNonSlashIndex);
      }
    };
    exports.checkImportsExportsFieldTarget = checkImportsExportsFieldTarget;
  }
});

// ../../../node_modules/enhanced-resolve/lib/Resolver.js
var require_Resolver = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/Resolver.js"(exports, module2) {
    "use strict";
    var { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook } = require_lib();
    var createInnerContext = require_createInnerContext();
    var { parseIdentifier } = require_identifier();
    var {
      normalize,
      cachedJoin: join,
      getType,
      PathType
    } = require_path();
    function toCamelCase(str) {
      return str.replace(/-([a-z])/g, (str2) => str2.slice(1).toUpperCase());
    }
    var Resolver = class {
      static createStackEntry(hook, request) {
        return hook.name + ": (" + request.path + ") " + (request.request || "") + (request.query || "") + (request.fragment || "") + (request.directory ? " directory" : "") + (request.module ? " module" : "");
      }
      constructor(fileSystem, options) {
        this.fileSystem = fileSystem;
        this.options = options;
        this.hooks = {
          resolveStep: new SyncHook(["hook", "request"], "resolveStep"),
          noResolve: new SyncHook(["request", "error"], "noResolve"),
          resolve: new AsyncSeriesBailHook(["request", "resolveContext"], "resolve"),
          result: new AsyncSeriesHook(["result", "resolveContext"], "result")
        };
      }
      ensureHook(name) {
        if (typeof name !== "string") {
          return name;
        }
        name = toCamelCase(name);
        if (/^before/.test(name)) {
          return this.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({
            stage: -10
          });
        }
        if (/^after/.test(name)) {
          return this.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({
            stage: 10
          });
        }
        const hook = this.hooks[name];
        if (!hook) {
          this.hooks[name] = new AsyncSeriesBailHook(["request", "resolveContext"], name);
          return this.hooks[name];
        }
        return hook;
      }
      getHook(name) {
        if (typeof name !== "string") {
          return name;
        }
        name = toCamelCase(name);
        if (/^before/.test(name)) {
          return this.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({
            stage: -10
          });
        }
        if (/^after/.test(name)) {
          return this.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({
            stage: 10
          });
        }
        const hook = this.hooks[name];
        if (!hook) {
          throw new Error(`Hook ${name} doesn't exist`);
        }
        return hook;
      }
      resolveSync(context, path, request) {
        let err = void 0;
        let result = void 0;
        let sync = false;
        this.resolve(context, path, request, {}, (e, r) => {
          err = e;
          result = r;
          sync = true;
        });
        if (!sync) {
          throw new Error("Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!");
        }
        if (err)
          throw err;
        if (result === void 0)
          throw new Error("No result");
        return result;
      }
      resolve(context, path, request, resolveContext, callback) {
        if (!context || typeof context !== "object")
          return callback(new Error("context argument is not an object"));
        if (typeof path !== "string")
          return callback(new Error("path argument is not a string"));
        if (typeof request !== "string")
          return callback(new Error("request argument is not a string"));
        if (!resolveContext)
          return callback(new Error("resolveContext argument is not set"));
        const obj = {
          context,
          path,
          request
        };
        let yield_;
        let yieldCalled = false;
        let finishYield;
        if (typeof resolveContext.yield === "function") {
          const old = resolveContext.yield;
          yield_ = (obj2) => {
            old(obj2);
            yieldCalled = true;
          };
          finishYield = (result) => {
            if (result) {
              yield_(result);
            }
            callback(null);
          };
        }
        const message = `resolve '${request}' in '${path}'`;
        const finishResolved = (result) => {
          return callback(null, result.path === false ? false : `${result.path.replace(/#/g, "\0#")}${result.query ? result.query.replace(/#/g, "\0#") : ""}${result.fragment || ""}`, result);
        };
        const finishWithoutResolve = (log) => {
          const error = new Error("Can't " + message);
          error.details = log.join("\n");
          this.hooks.noResolve.call(obj, error);
          return callback(error);
        };
        if (resolveContext.log) {
          const parentLog = resolveContext.log;
          const log = [];
          return this.doResolve(this.hooks.resolve, obj, message, {
            log: (msg) => {
              parentLog(msg);
              log.push(msg);
            },
            yield: yield_,
            fileDependencies: resolveContext.fileDependencies,
            contextDependencies: resolveContext.contextDependencies,
            missingDependencies: resolveContext.missingDependencies,
            stack: resolveContext.stack
          }, (err, result) => {
            if (err)
              return callback(err);
            if (yieldCalled || result && yield_) {
              return finishYield(result);
            }
            if (result)
              return finishResolved(result);
            return finishWithoutResolve(log);
          });
        } else {
          return this.doResolve(this.hooks.resolve, obj, message, {
            log: void 0,
            yield: yield_,
            fileDependencies: resolveContext.fileDependencies,
            contextDependencies: resolveContext.contextDependencies,
            missingDependencies: resolveContext.missingDependencies,
            stack: resolveContext.stack
          }, (err, result) => {
            if (err)
              return callback(err);
            if (yieldCalled || result && yield_) {
              return finishYield(result);
            }
            if (result)
              return finishResolved(result);
            const log = [];
            return this.doResolve(this.hooks.resolve, obj, message, {
              log: (msg) => log.push(msg),
              yield: yield_,
              stack: resolveContext.stack
            }, (err2, result2) => {
              if (err2)
                return callback(err2);
              if (yieldCalled || result2 && yield_) {
                return finishYield(result2);
              }
              return finishWithoutResolve(log);
            });
          });
        }
      }
      doResolve(hook, request, message, resolveContext, callback) {
        const stackEntry = Resolver.createStackEntry(hook, request);
        let newStack;
        if (resolveContext.stack) {
          newStack = new Set(resolveContext.stack);
          if (resolveContext.stack.has(stackEntry)) {
            const recursionError = new Error("Recursion in resolving\nStack:\n  " + Array.from(newStack).join("\n  "));
            recursionError.recursion = true;
            if (resolveContext.log)
              resolveContext.log("abort resolving because of recursion");
            return callback(recursionError);
          }
          newStack.add(stackEntry);
        } else {
          newStack = new Set([stackEntry]);
        }
        this.hooks.resolveStep.call(hook, request);
        if (hook.isUsed()) {
          const innerContext = createInnerContext({
            log: resolveContext.log,
            yield: resolveContext.yield,
            fileDependencies: resolveContext.fileDependencies,
            contextDependencies: resolveContext.contextDependencies,
            missingDependencies: resolveContext.missingDependencies,
            stack: newStack
          }, message);
          return hook.callAsync(request, innerContext, (err, result) => {
            if (err)
              return callback(err);
            if (result)
              return callback(null, result);
            callback();
          });
        } else {
          callback();
        }
      }
      parse(identifier) {
        const part = {
          request: "",
          query: "",
          fragment: "",
          module: false,
          directory: false,
          file: false,
          internal: false
        };
        const parsedIdentifier = parseIdentifier(identifier);
        if (!parsedIdentifier)
          return part;
        [part.request, part.query, part.fragment] = parsedIdentifier;
        if (part.request.length > 0) {
          part.internal = this.isPrivate(identifier);
          part.module = this.isModule(part.request);
          part.directory = this.isDirectory(part.request);
          if (part.directory) {
            part.request = part.request.slice(0, -1);
          }
        }
        return part;
      }
      isModule(path) {
        return getType(path) === PathType.Normal;
      }
      isPrivate(path) {
        return getType(path) === PathType.Internal;
      }
      isDirectory(path) {
        return path.endsWith("/");
      }
      join(path, request) {
        return join(path, request);
      }
      normalize(path) {
        return normalize(path);
      }
    };
    module2.exports = Resolver;
  }
});

// ../../../node_modules/enhanced-resolve/lib/SyncAsyncFileSystemDecorator.js
var require_SyncAsyncFileSystemDecorator = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/SyncAsyncFileSystemDecorator.js"(exports, module2) {
    "use strict";
    function SyncAsyncFileSystemDecorator(fs2) {
      this.fs = fs2;
      this.lstat = void 0;
      this.lstatSync = void 0;
      const lstatSync = fs2.lstatSync;
      if (lstatSync) {
        this.lstat = (arg, options, callback) => {
          let result;
          try {
            result = lstatSync.call(fs2, arg);
          } catch (e) {
            return (callback || options)(e);
          }
          (callback || options)(null, result);
        };
        this.lstatSync = (arg, options) => lstatSync.call(fs2, arg, options);
      }
      this.stat = (arg, options, callback) => {
        let result;
        try {
          result = callback ? fs2.statSync(arg, options) : fs2.statSync(arg);
        } catch (e) {
          return (callback || options)(e);
        }
        (callback || options)(null, result);
      };
      this.statSync = (arg, options) => fs2.statSync(arg, options);
      this.readdir = (arg, options, callback) => {
        let result;
        try {
          result = fs2.readdirSync(arg);
        } catch (e) {
          return (callback || options)(e);
        }
        (callback || options)(null, result);
      };
      this.readdirSync = (arg, options) => fs2.readdirSync(arg, options);
      this.readFile = (arg, options, callback) => {
        let result;
        try {
          result = fs2.readFileSync(arg);
        } catch (e) {
          return (callback || options)(e);
        }
        (callback || options)(null, result);
      };
      this.readFileSync = (arg, options) => fs2.readFileSync(arg, options);
      this.readlink = (arg, options, callback) => {
        let result;
        try {
          result = fs2.readlinkSync(arg);
        } catch (e) {
          return (callback || options)(e);
        }
        (callback || options)(null, result);
      };
      this.readlinkSync = (arg, options) => fs2.readlinkSync(arg, options);
      this.readJson = void 0;
      this.readJsonSync = void 0;
      const readJsonSync = fs2.readJsonSync;
      if (readJsonSync) {
        this.readJson = (arg, options, callback) => {
          let result;
          try {
            result = readJsonSync.call(fs2, arg);
          } catch (e) {
            return (callback || options)(e);
          }
          (callback || options)(null, result);
        };
        this.readJsonSync = (arg, options) => readJsonSync.call(fs2, arg, options);
      }
    }
    module2.exports = SyncAsyncFileSystemDecorator;
  }
});

// ../../../node_modules/enhanced-resolve/lib/forEachBail.js
var require_forEachBail = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/forEachBail.js"(exports, module2) {
    "use strict";
    module2.exports = function forEachBail(array, iterator, callback) {
      if (array.length === 0)
        return callback();
      let i = 0;
      const next = () => {
        let loop = void 0;
        iterator(array[i++], (err, result) => {
          if (err || result !== void 0 || i >= array.length) {
            return callback(err, result);
          }
          if (loop === false)
            while (next())
              ;
          loop = true;
        }, i);
        if (!loop)
          loop = false;
        return loop;
      };
      while (next())
        ;
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/DescriptionFileUtils.js
var require_DescriptionFileUtils = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/DescriptionFileUtils.js"(exports) {
    "use strict";
    var forEachBail = require_forEachBail();
    function loadDescriptionFile(resolver, directory, filenames, oldInfo, resolveContext, callback) {
      (function findDescriptionFile() {
        if (oldInfo && oldInfo.directory === directory) {
          return callback(null, oldInfo);
        }
        forEachBail(filenames, (filename, callback2) => {
          const descriptionFilePath = resolver.join(directory, filename);
          if (resolver.fileSystem.readJson) {
            resolver.fileSystem.readJson(descriptionFilePath, (err, content) => {
              if (err) {
                if (typeof err.code !== "undefined") {
                  if (resolveContext.missingDependencies) {
                    resolveContext.missingDependencies.add(descriptionFilePath);
                  }
                  return callback2();
                }
                if (resolveContext.fileDependencies) {
                  resolveContext.fileDependencies.add(descriptionFilePath);
                }
                return onJson(err);
              }
              if (resolveContext.fileDependencies) {
                resolveContext.fileDependencies.add(descriptionFilePath);
              }
              onJson(null, content);
            });
          } else {
            resolver.fileSystem.readFile(descriptionFilePath, (err, content) => {
              if (err) {
                if (resolveContext.missingDependencies) {
                  resolveContext.missingDependencies.add(descriptionFilePath);
                }
                return callback2();
              }
              if (resolveContext.fileDependencies) {
                resolveContext.fileDependencies.add(descriptionFilePath);
              }
              let json;
              if (content) {
                try {
                  json = JSON.parse(content.toString());
                } catch (e) {
                  return onJson(e);
                }
              } else {
                return onJson(new Error("No content in file"));
              }
              onJson(null, json);
            });
          }
          function onJson(err, content) {
            if (err) {
              if (resolveContext.log)
                resolveContext.log(descriptionFilePath + " (directory description file): " + err);
              else
                err.message = descriptionFilePath + " (directory description file): " + err;
              return callback2(err);
            }
            callback2(null, {
              content,
              directory,
              path: descriptionFilePath
            });
          }
        }, (err, result) => {
          if (err)
            return callback(err);
          if (result) {
            return callback(null, result);
          } else {
            const dir = cdUp(directory);
            if (!dir) {
              return callback();
            } else {
              directory = dir;
              return findDescriptionFile();
            }
          }
        });
      })();
    }
    function getField(content, field) {
      if (!content)
        return void 0;
      if (Array.isArray(field)) {
        let current = content;
        for (let j = 0; j < field.length; j++) {
          if (current === null || typeof current !== "object") {
            current = null;
            break;
          }
          current = current[field[j]];
        }
        return current;
      } else {
        return content[field];
      }
    }
    function cdUp(directory) {
      if (directory === "/")
        return null;
      const i = directory.lastIndexOf("/"), j = directory.lastIndexOf("\\");
      const p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
      if (p < 0)
        return null;
      return directory.slice(0, p || 1);
    }
    exports.loadDescriptionFile = loadDescriptionFile;
    exports.getField = getField;
    exports.cdUp = cdUp;
  }
});

// ../../../node_modules/enhanced-resolve/lib/getInnerRequest.js
var require_getInnerRequest = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/getInnerRequest.js"(exports, module2) {
    "use strict";
    module2.exports = function getInnerRequest(resolver, request) {
      if (typeof request.__innerRequest === "string" && request.__innerRequest_request === request.request && request.__innerRequest_relativePath === request.relativePath)
        return request.__innerRequest;
      let innerRequest;
      if (request.request) {
        innerRequest = request.request;
        if (/^\.\.?(?:\/|$)/.test(innerRequest) && request.relativePath) {
          innerRequest = resolver.join(request.relativePath, innerRequest);
        }
      } else {
        innerRequest = request.relativePath;
      }
      request.__innerRequest_request = request.request;
      request.__innerRequest_relativePath = request.relativePath;
      return request.__innerRequest = innerRequest;
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/AliasFieldPlugin.js
var require_AliasFieldPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/AliasFieldPlugin.js"(exports, module2) {
    "use strict";
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var getInnerRequest = require_getInnerRequest();
    module2.exports = class AliasFieldPlugin {
      constructor(source, field, target) {
        this.source = source;
        this.field = field;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AliasFieldPlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFileData)
            return callback();
          const innerRequest = getInnerRequest(resolver, request);
          if (!innerRequest)
            return callback();
          const fieldData = DescriptionFileUtils.getField(request.descriptionFileData, this.field);
          if (fieldData === null || typeof fieldData !== "object") {
            if (resolveContext.log)
              resolveContext.log("Field '" + this.field + "' doesn't contain a valid alias configuration");
            return callback();
          }
          const data = Object.prototype.hasOwnProperty.call(fieldData, innerRequest) ? fieldData[innerRequest] : innerRequest.startsWith("./") ? fieldData[innerRequest.slice(2)] : void 0;
          if (data === innerRequest)
            return callback();
          if (data === void 0)
            return callback();
          if (data === false) {
            const ignoreObj = {
              ...request,
              path: false
            };
            if (typeof resolveContext.yield === "function") {
              resolveContext.yield(ignoreObj);
              return callback(null, null);
            }
            return callback(null, ignoreObj);
          }
          const obj = {
            ...request,
            path: request.descriptionFileRoot,
            request: data,
            fullySpecified: false
          };
          resolver.doResolve(target, obj, "aliased from description file " + request.descriptionFilePath + " with mapping '" + innerRequest + "' to '" + data + "'", resolveContext, (err, result) => {
            if (err)
              return callback(err);
            if (result === void 0)
              return callback(null, null);
            callback(null, result);
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/AliasPlugin.js
var require_AliasPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/AliasPlugin.js"(exports, module2) {
    "use strict";
    var forEachBail = require_forEachBail();
    var { PathType, getType } = require_path();
    module2.exports = class AliasPlugin {
      constructor(source, options, target) {
        this.source = source;
        this.options = Array.isArray(options) ? options : [options];
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const getAbsolutePathWithSlashEnding = (maybeAbsolutePath) => {
          const type = getType(maybeAbsolutePath);
          if (type === PathType.AbsolutePosix || type === PathType.AbsoluteWin) {
            return resolver.join(maybeAbsolutePath, "_").slice(0, -1);
          }
          return null;
        };
        const isSubPath = (path, maybeSubPath) => {
          const absolutePath = getAbsolutePathWithSlashEnding(maybeSubPath);
          if (!absolutePath)
            return false;
          return path.startsWith(absolutePath);
        };
        resolver.getHook(this.source).tapAsync("AliasPlugin", (request, resolveContext, callback) => {
          const innerRequest = request.request || request.path;
          if (!innerRequest)
            return callback();
          forEachBail(this.options, (item, callback2) => {
            let shouldStop = false;
            if (innerRequest === item.name || !item.onlyModule && (request.request ? innerRequest.startsWith(`${item.name}/`) : isSubPath(innerRequest, item.name))) {
              const remainingRequest = innerRequest.slice(item.name.length);
              const resolveWithAlias = (alias, callback3) => {
                if (alias === false) {
                  const ignoreObj = {
                    ...request,
                    path: false
                  };
                  if (typeof resolveContext.yield === "function") {
                    resolveContext.yield(ignoreObj);
                    return callback3(null, null);
                  }
                  return callback3(null, ignoreObj);
                }
                if (innerRequest !== alias && !innerRequest.startsWith(alias + "/")) {
                  shouldStop = true;
                  const newRequestStr = alias + remainingRequest;
                  const obj = {
                    ...request,
                    request: newRequestStr,
                    fullySpecified: false
                  };
                  return resolver.doResolve(target, obj, "aliased with mapping '" + item.name + "': '" + alias + "' to '" + newRequestStr + "'", resolveContext, (err, result) => {
                    if (err)
                      return callback3(err);
                    if (result)
                      return callback3(null, result);
                    return callback3();
                  });
                }
                return callback3();
              };
              const stoppingCallback = (err, result) => {
                if (err)
                  return callback2(err);
                if (result)
                  return callback2(null, result);
                if (shouldStop)
                  return callback2(null, null);
                return callback2();
              };
              if (Array.isArray(item.alias)) {
                return forEachBail(item.alias, resolveWithAlias, stoppingCallback);
              } else {
                return resolveWithAlias(item.alias, stoppingCallback);
              }
            }
            return callback2();
          }, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/AppendPlugin.js
var require_AppendPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/AppendPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class AppendPlugin {
      constructor(source, appending, target) {
        this.source = source;
        this.appending = appending;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("AppendPlugin", (request, resolveContext, callback) => {
          const obj = {
            ...request,
            path: request.path + this.appending,
            relativePath: request.relativePath && request.relativePath + this.appending
          };
          resolver.doResolve(target, obj, this.appending, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/ConditionalPlugin.js
var require_ConditionalPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ConditionalPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class ConditionalPlugin {
      constructor(source, test, message, allowAlternatives, target) {
        this.source = source;
        this.test = test;
        this.message = message;
        this.allowAlternatives = allowAlternatives;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const { test, message, allowAlternatives } = this;
        const keys = Object.keys(test);
        resolver.getHook(this.source).tapAsync("ConditionalPlugin", (request, resolveContext, callback) => {
          for (const prop of keys) {
            if (request[prop] !== test[prop])
              return callback();
          }
          resolver.doResolve(target, request, message, resolveContext, allowAlternatives ? callback : (err, result) => {
            if (err)
              return callback(err);
            if (result === void 0)
              return callback(null, null);
            callback(null, result);
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/DescriptionFilePlugin.js
var require_DescriptionFilePlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/DescriptionFilePlugin.js"(exports, module2) {
    "use strict";
    var DescriptionFileUtils = require_DescriptionFileUtils();
    module2.exports = class DescriptionFilePlugin {
      constructor(source, filenames, pathIsFile, target) {
        this.source = source;
        this.filenames = filenames;
        this.pathIsFile = pathIsFile;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("DescriptionFilePlugin", (request, resolveContext, callback) => {
          const path = request.path;
          if (!path)
            return callback();
          const directory = this.pathIsFile ? DescriptionFileUtils.cdUp(path) : path;
          if (!directory)
            return callback();
          DescriptionFileUtils.loadDescriptionFile(resolver, directory, this.filenames, request.descriptionFilePath ? {
            path: request.descriptionFilePath,
            content: request.descriptionFileData,
            directory: request.descriptionFileRoot
          } : void 0, resolveContext, (err, result) => {
            if (err)
              return callback(err);
            if (!result) {
              if (resolveContext.log)
                resolveContext.log(`No description file found in ${directory} or above`);
              return callback();
            }
            const relativePath = "." + path.slice(result.directory.length).replace(/\\/g, "/");
            const obj = {
              ...request,
              descriptionFilePath: result.path,
              descriptionFileData: result.content,
              descriptionFileRoot: result.directory,
              relativePath
            };
            resolver.doResolve(target, obj, "using description file: " + result.path + " (relative path: " + relativePath + ")", resolveContext, (err2, result2) => {
              if (err2)
                return callback(err2);
              if (result2 === void 0)
                return callback(null, null);
              callback(null, result2);
            });
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/DirectoryExistsPlugin.js
var require_DirectoryExistsPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/DirectoryExistsPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class DirectoryExistsPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("DirectoryExistsPlugin", (request, resolveContext, callback) => {
          const fs2 = resolver.fileSystem;
          const directory = request.path;
          if (!directory)
            return callback();
          fs2.stat(directory, (err, stat) => {
            if (err || !stat) {
              if (resolveContext.missingDependencies)
                resolveContext.missingDependencies.add(directory);
              if (resolveContext.log)
                resolveContext.log(directory + " doesn't exist");
              return callback();
            }
            if (!stat.isDirectory()) {
              if (resolveContext.missingDependencies)
                resolveContext.missingDependencies.add(directory);
              if (resolveContext.log)
                resolveContext.log(directory + " is not a directory");
              return callback();
            }
            if (resolveContext.fileDependencies)
              resolveContext.fileDependencies.add(directory);
            resolver.doResolve(target, request, `existing directory ${directory}`, resolveContext, callback);
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/util/entrypoints.js
var require_entrypoints = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/util/entrypoints.js"(exports, module2) {
    "use strict";
    var slashCode = "/".charCodeAt(0);
    var dotCode = ".".charCodeAt(0);
    var hashCode = "#".charCodeAt(0);
    var patternRegEx = /\*/g;
    module2.exports.processExportsField = function processExportsField(exportsField) {
      return createFieldProcessor(buildExportsField(exportsField), (request) => request.length === 0 ? "." : "./" + request, assertExportsFieldRequest, assertExportTarget);
    };
    module2.exports.processImportsField = function processImportsField(importsField) {
      return createFieldProcessor(buildImportsField(importsField), (request) => "#" + request, assertImportsFieldRequest, assertImportTarget);
    };
    function createFieldProcessor(field, normalizeRequest, assertRequest, assertTarget) {
      return function fieldProcessor(request, conditionNames) {
        request = assertRequest(request);
        const match = findMatch(normalizeRequest(request), field);
        if (match === null)
          return [];
        const [mapping, remainingRequest, isSubpathMapping, isPattern] = match;
        let direct = null;
        if (isConditionalMapping(mapping)) {
          direct = conditionalMapping(mapping, conditionNames);
          if (direct === null)
            return [];
        } else {
          direct = mapping;
        }
        return directMapping(remainingRequest, isPattern, isSubpathMapping, direct, conditionNames, assertTarget);
      };
    }
    function assertExportsFieldRequest(request) {
      if (request.charCodeAt(0) !== dotCode) {
        throw new Error('Request should be relative path and start with "."');
      }
      if (request.length === 1)
        return "";
      if (request.charCodeAt(1) !== slashCode) {
        throw new Error('Request should be relative path and start with "./"');
      }
      if (request.charCodeAt(request.length - 1) === slashCode) {
        throw new Error("Only requesting file allowed");
      }
      return request.slice(2);
    }
    function assertImportsFieldRequest(request) {
      if (request.charCodeAt(0) !== hashCode) {
        throw new Error('Request should start with "#"');
      }
      if (request.length === 1) {
        throw new Error("Request should have at least 2 characters");
      }
      if (request.charCodeAt(1) === slashCode) {
        throw new Error('Request should not start with "#/"');
      }
      if (request.charCodeAt(request.length - 1) === slashCode) {
        throw new Error("Only requesting file allowed");
      }
      return request.slice(1);
    }
    function assertExportTarget(exp, expectFolder) {
      if (exp.charCodeAt(0) === slashCode || exp.charCodeAt(0) === dotCode && exp.charCodeAt(1) !== slashCode) {
        throw new Error(`Export should be relative path and start with "./", got ${JSON.stringify(exp)}.`);
      }
      const isFolder = exp.charCodeAt(exp.length - 1) === slashCode;
      if (isFolder !== expectFolder) {
        throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(exp)} should end with "/"` : `Expecting file to file mapping. ${JSON.stringify(exp)} should not end with "/"`);
      }
    }
    function assertImportTarget(imp, expectFolder) {
      const isFolder = imp.charCodeAt(imp.length - 1) === slashCode;
      if (isFolder !== expectFolder) {
        throw new Error(expectFolder ? `Expecting folder to folder mapping. ${JSON.stringify(imp)} should end with "/"` : `Expecting file to file mapping. ${JSON.stringify(imp)} should not end with "/"`);
      }
    }
    function patternKeyCompare(a, b) {
      const aPatternIndex = a.indexOf("*");
      const bPatternIndex = b.indexOf("*");
      const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
      const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
      if (baseLenA > baseLenB)
        return -1;
      if (baseLenB > baseLenA)
        return 1;
      if (aPatternIndex === -1)
        return 1;
      if (bPatternIndex === -1)
        return -1;
      if (a.length > b.length)
        return -1;
      if (b.length > a.length)
        return 1;
      return 0;
    }
    function findMatch(request, field) {
      if (Object.prototype.hasOwnProperty.call(field, request) && !request.includes("*") && !request.endsWith("/")) {
        const target2 = field[request];
        return [target2, "", false, false];
      }
      let bestMatch = "";
      let bestMatchSubpath;
      const keys = Object.getOwnPropertyNames(field);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const patternIndex = key.indexOf("*");
        if (patternIndex !== -1 && request.startsWith(key.slice(0, patternIndex))) {
          const patternTrailer = key.slice(patternIndex + 1);
          if (request.length >= key.length && request.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
            bestMatch = key;
            bestMatchSubpath = request.slice(patternIndex, request.length - patternTrailer.length);
          }
        } else if (key[key.length - 1] === "/" && request.startsWith(key) && patternKeyCompare(bestMatch, key) === 1) {
          bestMatch = key;
          bestMatchSubpath = request.slice(key.length);
        }
      }
      if (bestMatch === "")
        return null;
      const target = field[bestMatch];
      const isSubpathMapping = bestMatch.endsWith("/");
      const isPattern = bestMatch.includes("*");
      return [
        target,
        bestMatchSubpath,
        isSubpathMapping,
        isPattern
      ];
    }
    function isConditionalMapping(mapping) {
      return mapping !== null && typeof mapping === "object" && !Array.isArray(mapping);
    }
    function directMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, conditionNames, assert) {
      if (mappingTarget === null)
        return [];
      if (typeof mappingTarget === "string") {
        return [
          targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert)
        ];
      }
      const targets = [];
      for (const exp of mappingTarget) {
        if (typeof exp === "string") {
          targets.push(targetMapping(remainingRequest, isPattern, isSubpathMapping, exp, assert));
          continue;
        }
        const mapping = conditionalMapping(exp, conditionNames);
        if (!mapping)
          continue;
        const innerExports = directMapping(remainingRequest, isPattern, isSubpathMapping, mapping, conditionNames, assert);
        for (const innerExport of innerExports) {
          targets.push(innerExport);
        }
      }
      return targets;
    }
    function targetMapping(remainingRequest, isPattern, isSubpathMapping, mappingTarget, assert) {
      if (remainingRequest === void 0) {
        assert(mappingTarget, false);
        return mappingTarget;
      }
      if (isSubpathMapping) {
        assert(mappingTarget, true);
        return mappingTarget + remainingRequest;
      }
      assert(mappingTarget, false);
      let result = mappingTarget;
      if (isPattern) {
        result = result.replace(patternRegEx, remainingRequest.replace(/\$/g, "$$"));
      }
      return result;
    }
    function conditionalMapping(conditionalMapping_, conditionNames) {
      let lookup = [[conditionalMapping_, Object.keys(conditionalMapping_), 0]];
      loop:
        while (lookup.length > 0) {
          const [mapping, conditions, j] = lookup[lookup.length - 1];
          const last = conditions.length - 1;
          for (let i = j; i < conditions.length; i++) {
            const condition = conditions[i];
            if (i !== last) {
              if (condition === "default") {
                throw new Error("Default condition should be last one");
              }
            } else if (condition === "default") {
              const innerMapping = mapping[condition];
              if (isConditionalMapping(innerMapping)) {
                const conditionalMapping2 = innerMapping;
                lookup[lookup.length - 1][2] = i + 1;
                lookup.push([conditionalMapping2, Object.keys(conditionalMapping2), 0]);
                continue loop;
              }
              return innerMapping;
            }
            if (conditionNames.has(condition)) {
              const innerMapping = mapping[condition];
              if (isConditionalMapping(innerMapping)) {
                const conditionalMapping2 = innerMapping;
                lookup[lookup.length - 1][2] = i + 1;
                lookup.push([conditionalMapping2, Object.keys(conditionalMapping2), 0]);
                continue loop;
              }
              return innerMapping;
            }
          }
          lookup.pop();
        }
      return null;
    }
    function buildExportsField(field) {
      if (typeof field === "string" || Array.isArray(field)) {
        return { ".": field };
      }
      const keys = Object.keys(field);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key.charCodeAt(0) !== dotCode) {
          if (i === 0) {
            while (i < keys.length) {
              const charCode = keys[i].charCodeAt(0);
              if (charCode === dotCode || charCode === slashCode) {
                throw new Error(`Exports field key should be relative path and start with "." (key: ${JSON.stringify(key)})`);
              }
              i++;
            }
            return { ".": field };
          }
          throw new Error(`Exports field key should be relative path and start with "." (key: ${JSON.stringify(key)})`);
        }
        if (key.length === 1) {
          continue;
        }
        if (key.charCodeAt(1) !== slashCode) {
          throw new Error(`Exports field key should be relative path and start with "./" (key: ${JSON.stringify(key)})`);
        }
      }
      return field;
    }
    function buildImportsField(field) {
      const keys = Object.keys(field);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if (key.charCodeAt(0) !== hashCode) {
          throw new Error(`Imports field key should start with "#" (key: ${JSON.stringify(key)})`);
        }
        if (key.length === 1) {
          throw new Error(`Imports field key should have at least 2 characters (key: ${JSON.stringify(key)})`);
        }
        if (key.charCodeAt(1) === slashCode) {
          throw new Error(`Imports field key should not start with "#/" (key: ${JSON.stringify(key)})`);
        }
      }
      return field;
    }
  }
});

// ../../../node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js
var require_ExportsFieldPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ExportsFieldPlugin.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var forEachBail = require_forEachBail();
    var { processExportsField } = require_entrypoints();
    var { parseIdentifier } = require_identifier();
    var { checkImportsExportsFieldTarget } = require_path();
    module2.exports = class ExportsFieldPlugin {
      constructor(source, conditionNames, fieldNamePath, target) {
        this.source = source;
        this.target = target;
        this.conditionNames = conditionNames;
        this.fieldName = fieldNamePath;
        this.fieldProcessorCache = new WeakMap();
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ExportsFieldPlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFilePath)
            return callback();
          if (request.relativePath !== "." || request.request === void 0)
            return callback();
          const remainingRequest = request.query || request.fragment ? (request.request === "." ? "./" : request.request) + request.query + request.fragment : request.request;
          const exportsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);
          if (!exportsField)
            return callback();
          if (request.directory) {
            return callback(new Error(`Resolving to directories is not possible with the exports field (request was ${remainingRequest}/)`));
          }
          let paths;
          try {
            let fieldProcessor = this.fieldProcessorCache.get(request.descriptionFileData);
            if (fieldProcessor === void 0) {
              fieldProcessor = processExportsField(exportsField);
              this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);
            }
            paths = fieldProcessor(remainingRequest, this.conditionNames);
          } catch (err) {
            if (resolveContext.log) {
              resolveContext.log(`Exports field in ${request.descriptionFilePath} can't be processed: ${err}`);
            }
            return callback(err);
          }
          if (paths.length === 0) {
            return callback(new Error(`Package path ${remainingRequest} is not exported from package ${request.descriptionFileRoot} (see exports field in ${request.descriptionFilePath})`));
          }
          forEachBail(paths, (p, callback2) => {
            const parsedIdentifier = parseIdentifier(p);
            if (!parsedIdentifier)
              return callback2();
            const [relativePath, query, fragment] = parsedIdentifier;
            const error = checkImportsExportsFieldTarget(relativePath);
            if (error) {
              return callback2(error);
            }
            const obj = {
              ...request,
              request: void 0,
              path: path.join(request.descriptionFileRoot, relativePath),
              relativePath,
              query,
              fragment
            };
            resolver.doResolve(target, obj, "using exports field: " + p, resolveContext, callback2);
          }, (err, result) => callback(err, result || null));
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/ExtensionAliasPlugin.js
var require_ExtensionAliasPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ExtensionAliasPlugin.js"(exports, module2) {
    "use strict";
    var forEachBail = require_forEachBail();
    module2.exports = class ExtensionAliasPlugin {
      constructor(source, options, target) {
        this.source = source;
        this.options = options;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const { extension, alias } = this.options;
        resolver.getHook(this.source).tapAsync("ExtensionAliasPlugin", (request, resolveContext, callback) => {
          const requestPath = request.request;
          if (!requestPath || !requestPath.endsWith(extension))
            return callback();
          const isAliasString = typeof alias === "string";
          const resolve2 = (alias2, callback2, index) => {
            const newRequest = `${requestPath.slice(0, -extension.length)}${alias2}`;
            return resolver.doResolve(target, {
              ...request,
              request: newRequest,
              fullySpecified: true
            }, `aliased from extension alias with mapping '${extension}' to '${alias2}'`, resolveContext, (err, result) => {
              if (!isAliasString && index) {
                if (index !== this.options.alias.length) {
                  if (resolveContext.log) {
                    resolveContext.log(`Failed to alias from extension alias with mapping '${extension}' to '${alias2}' for '${newRequest}': ${err}`);
                  }
                  return callback2(null, result);
                }
                return callback2(err, result);
              } else {
                callback2(err, result);
              }
            });
          };
          const stoppingCallback = (err, result) => {
            if (err)
              return callback(err);
            if (result)
              return callback(null, result);
            return callback(null, null);
          };
          if (isAliasString) {
            resolve2(alias, stoppingCallback);
          } else if (alias.length > 1) {
            forEachBail(alias, resolve2, stoppingCallback);
          } else {
            resolve2(alias[0], stoppingCallback);
          }
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/FileExistsPlugin.js
var require_FileExistsPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/FileExistsPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class FileExistsPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const fs2 = resolver.fileSystem;
        resolver.getHook(this.source).tapAsync("FileExistsPlugin", (request, resolveContext, callback) => {
          const file = request.path;
          if (!file)
            return callback();
          fs2.stat(file, (err, stat) => {
            if (err || !stat) {
              if (resolveContext.missingDependencies)
                resolveContext.missingDependencies.add(file);
              if (resolveContext.log)
                resolveContext.log(file + " doesn't exist");
              return callback();
            }
            if (!stat.isFile()) {
              if (resolveContext.missingDependencies)
                resolveContext.missingDependencies.add(file);
              if (resolveContext.log)
                resolveContext.log(file + " is not a file");
              return callback();
            }
            if (resolveContext.fileDependencies)
              resolveContext.fileDependencies.add(file);
            resolver.doResolve(target, request, "existing file: " + file, resolveContext, callback);
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js
var require_ImportsFieldPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ImportsFieldPlugin.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var forEachBail = require_forEachBail();
    var { processImportsField } = require_entrypoints();
    var { parseIdentifier } = require_identifier();
    var { checkImportsExportsFieldTarget } = require_path();
    var dotCode = ".".charCodeAt(0);
    module2.exports = class ImportsFieldPlugin {
      constructor(source, conditionNames, fieldNamePath, targetFile, targetPackage) {
        this.source = source;
        this.targetFile = targetFile;
        this.targetPackage = targetPackage;
        this.conditionNames = conditionNames;
        this.fieldName = fieldNamePath;
        this.fieldProcessorCache = new WeakMap();
      }
      apply(resolver) {
        const targetFile = resolver.ensureHook(this.targetFile);
        const targetPackage = resolver.ensureHook(this.targetPackage);
        resolver.getHook(this.source).tapAsync("ImportsFieldPlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFilePath || request.request === void 0) {
            return callback();
          }
          const remainingRequest = request.request + request.query + request.fragment;
          const importsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);
          if (!importsField)
            return callback();
          if (request.directory) {
            return callback(new Error(`Resolving to directories is not possible with the imports field (request was ${remainingRequest}/)`));
          }
          let paths;
          try {
            let fieldProcessor = this.fieldProcessorCache.get(request.descriptionFileData);
            if (fieldProcessor === void 0) {
              fieldProcessor = processImportsField(importsField);
              this.fieldProcessorCache.set(request.descriptionFileData, fieldProcessor);
            }
            paths = fieldProcessor(remainingRequest, this.conditionNames);
          } catch (err) {
            if (resolveContext.log) {
              resolveContext.log(`Imports field in ${request.descriptionFilePath} can't be processed: ${err}`);
            }
            return callback(err);
          }
          if (paths.length === 0) {
            return callback(new Error(`Package import ${remainingRequest} is not imported from package ${request.descriptionFileRoot} (see imports field in ${request.descriptionFilePath})`));
          }
          forEachBail(paths, (p, callback2) => {
            const parsedIdentifier = parseIdentifier(p);
            if (!parsedIdentifier)
              return callback2();
            const [path_, query, fragment] = parsedIdentifier;
            const error = checkImportsExportsFieldTarget(path_);
            if (error) {
              return callback2(error);
            }
            switch (path_.charCodeAt(0)) {
              case dotCode: {
                const obj = {
                  ...request,
                  request: void 0,
                  path: path.join(request.descriptionFileRoot, path_),
                  relativePath: path_,
                  query,
                  fragment
                };
                resolver.doResolve(targetFile, obj, "using imports field: " + p, resolveContext, callback2);
                break;
              }
              default: {
                const obj = {
                  ...request,
                  request: path_,
                  relativePath: path_,
                  fullySpecified: true,
                  query,
                  fragment
                };
                resolver.doResolve(targetPackage, obj, "using imports field: " + p, resolveContext, callback2);
              }
            }
          }, (err, result) => callback(err, result || null));
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/JoinRequestPartPlugin.js
var require_JoinRequestPartPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/JoinRequestPartPlugin.js"(exports, module2) {
    "use strict";
    var namespaceStartCharCode = "@".charCodeAt(0);
    module2.exports = class JoinRequestPartPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("JoinRequestPartPlugin", (request, resolveContext, callback) => {
          const req = request.request || "";
          let i = req.indexOf("/", 3);
          if (i >= 0 && req.charCodeAt(2) === namespaceStartCharCode) {
            i = req.indexOf("/", i + 1);
          }
          let moduleName;
          let remainingRequest;
          let fullySpecified;
          if (i < 0) {
            moduleName = req;
            remainingRequest = ".";
            fullySpecified = false;
          } else {
            moduleName = req.slice(0, i);
            remainingRequest = "." + req.slice(i);
            fullySpecified = request.fullySpecified;
          }
          const obj = {
            ...request,
            path: resolver.join(request.path, moduleName),
            relativePath: request.relativePath && resolver.join(request.relativePath, moduleName),
            request: remainingRequest,
            fullySpecified
          };
          resolver.doResolve(target, obj, null, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/JoinRequestPlugin.js
var require_JoinRequestPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/JoinRequestPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class JoinRequestPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("JoinRequestPlugin", (request, resolveContext, callback) => {
          const requestPath = request.path;
          const requestRequest = request.request;
          const obj = {
            ...request,
            path: resolver.join(requestPath, requestRequest),
            relativePath: request.relativePath && resolver.join(request.relativePath, requestRequest),
            request: void 0
          };
          resolver.doResolve(target, obj, null, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/MainFieldPlugin.js
var require_MainFieldPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/MainFieldPlugin.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var alreadyTriedMainField = Symbol("alreadyTriedMainField");
    module2.exports = class MainFieldPlugin {
      constructor(source, options, target) {
        this.source = source;
        this.options = options;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("MainFieldPlugin", (request, resolveContext, callback) => {
          if (request.path !== request.descriptionFileRoot || request[alreadyTriedMainField] === request.descriptionFilePath || !request.descriptionFilePath)
            return callback();
          const filename = path.basename(request.descriptionFilePath);
          let mainModule = DescriptionFileUtils.getField(request.descriptionFileData, this.options.name);
          if (!mainModule || typeof mainModule !== "string" || mainModule === "." || mainModule === "./") {
            return callback();
          }
          if (this.options.forceRelative && !/^\.\.?\//.test(mainModule))
            mainModule = "./" + mainModule;
          const obj = {
            ...request,
            request: mainModule,
            module: false,
            directory: mainModule.endsWith("/"),
            [alreadyTriedMainField]: request.descriptionFilePath
          };
          return resolver.doResolve(target, obj, "use " + mainModule + " from " + this.options.name + " in " + filename, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/getPaths.js
var require_getPaths = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/getPaths.js"(exports, module2) {
    "use strict";
    module2.exports = function getPaths(path) {
      if (path === "/")
        return { paths: ["/"], segments: [""] };
      const parts = path.split(/(.*?[\\/]+)/);
      const paths = [path];
      const segments = [parts[parts.length - 1]];
      let part = parts[parts.length - 1];
      path = path.substring(0, path.length - part.length - 1);
      for (let i = parts.length - 2; i > 2; i -= 2) {
        paths.push(path);
        part = parts[i];
        path = path.substring(0, path.length - part.length) || "/";
        segments.push(part.slice(0, -1));
      }
      part = parts[1];
      segments.push(part);
      paths.push(part);
      return {
        paths,
        segments
      };
    };
    module2.exports.basename = function basename(path) {
      const i = path.lastIndexOf("/"), j = path.lastIndexOf("\\");
      const p = i < 0 ? j : j < 0 ? i : i < j ? j : i;
      if (p < 0)
        return null;
      const s = path.slice(p + 1);
      return s;
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/ModulesInHierarchicalDirectoriesPlugin.js
var require_ModulesInHierarchicalDirectoriesPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ModulesInHierarchicalDirectoriesPlugin.js"(exports, module2) {
    "use strict";
    var forEachBail = require_forEachBail();
    var getPaths = require_getPaths();
    module2.exports = class ModulesInHierarchicalDirectoriesPlugin {
      constructor(source, directories, target) {
        this.source = source;
        this.directories = [].concat(directories);
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ModulesInHierarchicalDirectoriesPlugin", (request, resolveContext, callback) => {
          const fs2 = resolver.fileSystem;
          const addrs = getPaths(request.path).paths.map((p) => {
            return this.directories.map((d) => resolver.join(p, d));
          }).reduce((array, p) => {
            array.push.apply(array, p);
            return array;
          }, []);
          forEachBail(addrs, (addr, callback2) => {
            fs2.stat(addr, (err, stat) => {
              if (!err && stat && stat.isDirectory()) {
                const obj = {
                  ...request,
                  path: addr,
                  request: "./" + request.request,
                  module: false
                };
                const message = "looking for modules in " + addr;
                return resolver.doResolve(target, obj, message, resolveContext, callback2);
              }
              if (resolveContext.log)
                resolveContext.log(addr + " doesn't exist or is not a directory");
              if (resolveContext.missingDependencies)
                resolveContext.missingDependencies.add(addr);
              return callback2();
            });
          }, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/ModulesInRootPlugin.js
var require_ModulesInRootPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ModulesInRootPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class ModulesInRootPlugin {
      constructor(source, path, target) {
        this.source = source;
        this.path = path;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ModulesInRootPlugin", (request, resolveContext, callback) => {
          const obj = {
            ...request,
            path: this.path,
            request: "./" + request.request,
            module: false
          };
          resolver.doResolve(target, obj, "looking for modules in " + this.path, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/NextPlugin.js
var require_NextPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/NextPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class NextPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("NextPlugin", (request, resolveContext, callback) => {
          resolver.doResolve(target, request, null, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/ParsePlugin.js
var require_ParsePlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ParsePlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class ParsePlugin {
      constructor(source, requestOptions, target) {
        this.source = source;
        this.requestOptions = requestOptions;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("ParsePlugin", (request, resolveContext, callback) => {
          const parsed = resolver.parse(request.request);
          const obj = { ...request, ...parsed, ...this.requestOptions };
          if (request.query && !parsed.query) {
            obj.query = request.query;
          }
          if (request.fragment && !parsed.fragment) {
            obj.fragment = request.fragment;
          }
          if (parsed && resolveContext.log) {
            if (parsed.module)
              resolveContext.log("Parsed request is a module");
            if (parsed.directory)
              resolveContext.log("Parsed request is a directory");
          }
          if (obj.request && !obj.query && obj.fragment) {
            const directory = obj.fragment.endsWith("/");
            const alternative = {
              ...obj,
              directory,
              request: obj.request + (obj.directory ? "/" : "") + (directory ? obj.fragment.slice(0, -1) : obj.fragment),
              fragment: ""
            };
            resolver.doResolve(target, alternative, null, resolveContext, (err, result) => {
              if (err)
                return callback(err);
              if (result)
                return callback(null, result);
              resolver.doResolve(target, obj, null, resolveContext, callback);
            });
            return;
          }
          resolver.doResolve(target, obj, null, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/PnpPlugin.js
var require_PnpPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/PnpPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class PnpPlugin {
      constructor(source, pnpApi, target) {
        this.source = source;
        this.pnpApi = pnpApi;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("PnpPlugin", (request, resolveContext, callback) => {
          const req = request.request;
          if (!req)
            return callback();
          const issuer = `${request.path}/`;
          const packageMatch = /^(@[^/]+\/)?[^/]+/.exec(req);
          if (!packageMatch)
            return callback();
          const packageName = packageMatch[0];
          const innerRequest = `.${req.slice(packageName.length)}`;
          let resolution;
          let apiResolution;
          try {
            resolution = this.pnpApi.resolveToUnqualified(packageName, issuer, {
              considerBuiltins: false
            });
            if (resolveContext.fileDependencies) {
              apiResolution = this.pnpApi.resolveToUnqualified("pnpapi", issuer, {
                considerBuiltins: false
              });
            }
          } catch (error) {
            if (error.code === "MODULE_NOT_FOUND" && error.pnpCode === "UNDECLARED_DEPENDENCY") {
              if (resolveContext.log) {
                resolveContext.log(`request is not managed by the pnpapi`);
                for (const line of error.message.split("\n").filter(Boolean))
                  resolveContext.log(`  ${line}`);
              }
              return callback();
            }
            return callback(error);
          }
          if (resolution === packageName)
            return callback();
          if (apiResolution && resolveContext.fileDependencies) {
            resolveContext.fileDependencies.add(apiResolution);
          }
          const obj = {
            ...request,
            path: resolution,
            request: innerRequest,
            ignoreSymlinks: true,
            fullySpecified: request.fullySpecified && innerRequest !== "."
          };
          resolver.doResolve(target, obj, `resolved by pnp to ${resolution}`, resolveContext, (err, result) => {
            if (err)
              return callback(err);
            if (result)
              return callback(null, result);
            return callback(null, null);
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/RestrictionsPlugin.js
var require_RestrictionsPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/RestrictionsPlugin.js"(exports, module2) {
    "use strict";
    var slashCode = "/".charCodeAt(0);
    var backslashCode = "\\".charCodeAt(0);
    var isInside = (path, parent) => {
      if (!path.startsWith(parent))
        return false;
      if (path.length === parent.length)
        return true;
      const charCode = path.charCodeAt(parent.length);
      return charCode === slashCode || charCode === backslashCode;
    };
    module2.exports = class RestrictionsPlugin {
      constructor(source, restrictions) {
        this.source = source;
        this.restrictions = restrictions;
      }
      apply(resolver) {
        resolver.getHook(this.source).tapAsync("RestrictionsPlugin", (request, resolveContext, callback) => {
          if (typeof request.path === "string") {
            const path = request.path;
            for (const rule of this.restrictions) {
              if (typeof rule === "string") {
                if (!isInside(path, rule)) {
                  if (resolveContext.log) {
                    resolveContext.log(`${path} is not inside of the restriction ${rule}`);
                  }
                  return callback(null, null);
                }
              } else if (!rule.test(path)) {
                if (resolveContext.log) {
                  resolveContext.log(`${path} doesn't match the restriction ${rule}`);
                }
                return callback(null, null);
              }
            }
          }
          callback();
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/ResultPlugin.js
var require_ResultPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ResultPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class ResultPlugin {
      constructor(source) {
        this.source = source;
      }
      apply(resolver) {
        this.source.tapAsync("ResultPlugin", (request, resolverContext, callback) => {
          const obj = { ...request };
          if (resolverContext.log)
            resolverContext.log("reporting result " + obj.path);
          resolver.hooks.result.callAsync(obj, resolverContext, (err) => {
            if (err)
              return callback(err);
            if (typeof resolverContext.yield === "function") {
              resolverContext.yield(obj);
              callback(null, null);
            } else {
              callback(null, obj);
            }
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/RootsPlugin.js
var require_RootsPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/RootsPlugin.js"(exports, module2) {
    "use strict";
    var forEachBail = require_forEachBail();
    var RootsPlugin = class {
      constructor(source, roots, target) {
        this.roots = Array.from(roots);
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("RootsPlugin", (request, resolveContext, callback) => {
          const req = request.request;
          if (!req)
            return callback();
          if (!req.startsWith("/"))
            return callback();
          forEachBail(this.roots, (root, callback2) => {
            const path = resolver.join(root, req.slice(1));
            const obj = {
              ...request,
              path,
              relativePath: request.relativePath && path
            };
            resolver.doResolve(target, obj, `root path ${root}`, resolveContext, callback2);
          }, callback);
        });
      }
    };
    module2.exports = RootsPlugin;
  }
});

// ../../../node_modules/enhanced-resolve/lib/SelfReferencePlugin.js
var require_SelfReferencePlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/SelfReferencePlugin.js"(exports, module2) {
    "use strict";
    var DescriptionFileUtils = require_DescriptionFileUtils();
    var slashCode = "/".charCodeAt(0);
    module2.exports = class SelfReferencePlugin {
      constructor(source, fieldNamePath, target) {
        this.source = source;
        this.target = target;
        this.fieldName = fieldNamePath;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("SelfReferencePlugin", (request, resolveContext, callback) => {
          if (!request.descriptionFilePath)
            return callback();
          const req = request.request;
          if (!req)
            return callback();
          const exportsField = DescriptionFileUtils.getField(request.descriptionFileData, this.fieldName);
          if (!exportsField)
            return callback();
          const name = DescriptionFileUtils.getField(request.descriptionFileData, "name");
          if (typeof name !== "string")
            return callback();
          if (req.startsWith(name) && (req.length === name.length || req.charCodeAt(name.length) === slashCode)) {
            const remainingRequest = `.${req.slice(name.length)}`;
            const obj = {
              ...request,
              request: remainingRequest,
              path: request.descriptionFileRoot,
              relativePath: "."
            };
            resolver.doResolve(target, obj, "self reference", resolveContext, callback);
          } else {
            return callback();
          }
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/SymlinkPlugin.js
var require_SymlinkPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/SymlinkPlugin.js"(exports, module2) {
    "use strict";
    var forEachBail = require_forEachBail();
    var getPaths = require_getPaths();
    var { getType, PathType } = require_path();
    module2.exports = class SymlinkPlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        const fs2 = resolver.fileSystem;
        resolver.getHook(this.source).tapAsync("SymlinkPlugin", (request, resolveContext, callback) => {
          if (request.ignoreSymlinks)
            return callback();
          const pathsResult = getPaths(request.path);
          const pathSegments = pathsResult.segments;
          const paths = pathsResult.paths;
          let containsSymlink = false;
          let idx = -1;
          forEachBail(paths, (path, callback2) => {
            idx++;
            if (resolveContext.fileDependencies)
              resolveContext.fileDependencies.add(path);
            fs2.readlink(path, (err, result) => {
              if (!err && result) {
                pathSegments[idx] = result;
                containsSymlink = true;
                const resultType = getType(result.toString());
                if (resultType === PathType.AbsoluteWin || resultType === PathType.AbsolutePosix) {
                  return callback2(null, idx);
                }
              }
              callback2();
            });
          }, (err, idx2) => {
            if (!containsSymlink)
              return callback();
            const resultSegments = typeof idx2 === "number" ? pathSegments.slice(0, idx2 + 1) : pathSegments.slice();
            const result = resultSegments.reduceRight((a, b) => {
              return resolver.join(a, b);
            });
            const obj = {
              ...request,
              path: result
            };
            resolver.doResolve(target, obj, "resolved symlink to " + result, resolveContext, callback);
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/TryNextPlugin.js
var require_TryNextPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/TryNextPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class TryNextPlugin {
      constructor(source, message, target) {
        this.source = source;
        this.message = message;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("TryNextPlugin", (request, resolveContext, callback) => {
          resolver.doResolve(target, request, this.message, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js
var require_UnsafeCachePlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/UnsafeCachePlugin.js"(exports, module2) {
    "use strict";
    function getCacheId(type, request, withContext) {
      return JSON.stringify({
        type,
        context: withContext ? request.context : "",
        path: request.path,
        query: request.query,
        fragment: request.fragment,
        request: request.request
      });
    }
    module2.exports = class UnsafeCachePlugin {
      constructor(source, filterPredicate, cache, withContext, target) {
        this.source = source;
        this.filterPredicate = filterPredicate;
        this.withContext = withContext;
        this.cache = cache;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("UnsafeCachePlugin", (request, resolveContext, callback) => {
          if (!this.filterPredicate(request))
            return callback();
          const isYield = typeof resolveContext.yield === "function";
          const cacheId = getCacheId(isYield ? "yield" : "default", request, this.withContext);
          const cacheEntry = this.cache[cacheId];
          if (cacheEntry) {
            if (isYield) {
              const yield_2 = resolveContext.yield;
              if (Array.isArray(cacheEntry)) {
                for (const result of cacheEntry)
                  yield_2(result);
              } else {
                yield_2(cacheEntry);
              }
              return callback(null, null);
            }
            return callback(null, cacheEntry);
          }
          let yieldFn;
          let yield_;
          const yieldResult = [];
          if (isYield) {
            yieldFn = resolveContext.yield;
            yield_ = (result) => {
              yieldResult.push(result);
            };
          }
          resolver.doResolve(target, request, null, yield_ ? { ...resolveContext, yield: yield_ } : resolveContext, (err, result) => {
            if (err)
              return callback(err);
            if (isYield) {
              if (result)
                yieldResult.push(result);
              for (const result2 of yieldResult) {
                yieldFn(result2);
              }
              this.cache[cacheId] = yieldResult;
              return callback(null, null);
            }
            if (result)
              return callback(null, this.cache[cacheId] = result);
            callback();
          });
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/UseFilePlugin.js
var require_UseFilePlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/UseFilePlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class UseFilePlugin {
      constructor(source, filename, target) {
        this.source = source;
        this.filename = filename;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("UseFilePlugin", (request, resolveContext, callback) => {
          const filePath = resolver.join(request.path, this.filename);
          const obj = {
            ...request,
            path: filePath,
            relativePath: request.relativePath && resolver.join(request.relativePath, this.filename)
          };
          resolver.doResolve(target, obj, "using path: " + filePath, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/ResolverFactory.js
var require_ResolverFactory = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/ResolverFactory.js"(exports) {
    "use strict";
    var versions = require("process").versions;
    var Resolver = require_Resolver();
    var { getType, PathType } = require_path();
    var SyncAsyncFileSystemDecorator = require_SyncAsyncFileSystemDecorator();
    var AliasFieldPlugin = require_AliasFieldPlugin();
    var AliasPlugin = require_AliasPlugin();
    var AppendPlugin = require_AppendPlugin();
    var ConditionalPlugin = require_ConditionalPlugin();
    var DescriptionFilePlugin = require_DescriptionFilePlugin();
    var DirectoryExistsPlugin = require_DirectoryExistsPlugin();
    var ExportsFieldPlugin = require_ExportsFieldPlugin();
    var ExtensionAliasPlugin = require_ExtensionAliasPlugin();
    var FileExistsPlugin = require_FileExistsPlugin();
    var ImportsFieldPlugin = require_ImportsFieldPlugin();
    var JoinRequestPartPlugin = require_JoinRequestPartPlugin();
    var JoinRequestPlugin = require_JoinRequestPlugin();
    var MainFieldPlugin = require_MainFieldPlugin();
    var ModulesInHierarchicalDirectoriesPlugin = require_ModulesInHierarchicalDirectoriesPlugin();
    var ModulesInRootPlugin = require_ModulesInRootPlugin();
    var NextPlugin = require_NextPlugin();
    var ParsePlugin = require_ParsePlugin();
    var PnpPlugin = require_PnpPlugin();
    var RestrictionsPlugin = require_RestrictionsPlugin();
    var ResultPlugin = require_ResultPlugin();
    var RootsPlugin = require_RootsPlugin();
    var SelfReferencePlugin = require_SelfReferencePlugin();
    var SymlinkPlugin = require_SymlinkPlugin();
    var TryNextPlugin = require_TryNextPlugin();
    var UnsafeCachePlugin = require_UnsafeCachePlugin();
    var UseFilePlugin = require_UseFilePlugin();
    function processPnpApiOption(option) {
      if (option === void 0 && versions.pnp) {
        return require("pnpapi");
      }
      return option || null;
    }
    function normalizeAlias(alias) {
      return typeof alias === "object" && !Array.isArray(alias) && alias !== null ? Object.keys(alias).map((key) => {
        const obj = { name: key, onlyModule: false, alias: alias[key] };
        if (/\$$/.test(key)) {
          obj.onlyModule = true;
          obj.name = key.slice(0, -1);
        }
        return obj;
      }) : alias || [];
    }
    function createOptions(options) {
      const mainFieldsSet = new Set(options.mainFields || ["main"]);
      const mainFields = [];
      for (const item of mainFieldsSet) {
        if (typeof item === "string") {
          mainFields.push({
            name: [item],
            forceRelative: true
          });
        } else if (Array.isArray(item)) {
          mainFields.push({
            name: item,
            forceRelative: true
          });
        } else {
          mainFields.push({
            name: Array.isArray(item.name) ? item.name : [item.name],
            forceRelative: item.forceRelative
          });
        }
      }
      return {
        alias: normalizeAlias(options.alias),
        fallback: normalizeAlias(options.fallback),
        aliasFields: new Set(options.aliasFields),
        cachePredicate: options.cachePredicate || function() {
          return true;
        },
        cacheWithContext: typeof options.cacheWithContext !== "undefined" ? options.cacheWithContext : true,
        exportsFields: new Set(options.exportsFields || ["exports"]),
        importsFields: new Set(options.importsFields || ["imports"]),
        conditionNames: new Set(options.conditionNames),
        descriptionFiles: Array.from(new Set(options.descriptionFiles || ["package.json"])),
        enforceExtension: options.enforceExtension === void 0 ? options.extensions && options.extensions.includes("") ? true : false : options.enforceExtension,
        extensions: new Set(options.extensions || [".js", ".json", ".node"]),
        extensionAlias: options.extensionAlias ? Object.keys(options.extensionAlias).map((k) => ({
          extension: k,
          alias: options.extensionAlias[k]
        })) : [],
        fileSystem: options.useSyncFileSystemCalls ? new SyncAsyncFileSystemDecorator(options.fileSystem) : options.fileSystem,
        unsafeCache: options.unsafeCache && typeof options.unsafeCache !== "object" ? {} : options.unsafeCache || false,
        symlinks: typeof options.symlinks !== "undefined" ? options.symlinks : true,
        resolver: options.resolver,
        modules: mergeFilteredToArray(Array.isArray(options.modules) ? options.modules : options.modules ? [options.modules] : ["node_modules"], (item) => {
          const type = getType(item);
          return type === PathType.Normal || type === PathType.Relative;
        }),
        mainFields,
        mainFiles: new Set(options.mainFiles || ["index"]),
        plugins: options.plugins || [],
        pnpApi: processPnpApiOption(options.pnpApi),
        roots: new Set(options.roots || void 0),
        fullySpecified: options.fullySpecified || false,
        resolveToContext: options.resolveToContext || false,
        preferRelative: options.preferRelative || false,
        preferAbsolute: options.preferAbsolute || false,
        restrictions: new Set(options.restrictions)
      };
    }
    exports.createResolver = function(options) {
      const normalizedOptions = createOptions(options);
      const {
        alias,
        fallback,
        aliasFields,
        cachePredicate,
        cacheWithContext,
        conditionNames,
        descriptionFiles,
        enforceExtension,
        exportsFields,
        extensionAlias,
        importsFields,
        extensions,
        fileSystem,
        fullySpecified,
        mainFields,
        mainFiles,
        modules,
        plugins: userPlugins,
        pnpApi,
        resolveToContext,
        preferRelative,
        preferAbsolute,
        symlinks,
        unsafeCache,
        resolver: customResolver,
        restrictions,
        roots
      } = normalizedOptions;
      const plugins = userPlugins.slice();
      const resolver = customResolver ? customResolver : new Resolver(fileSystem, normalizedOptions);
      resolver.ensureHook("resolve");
      resolver.ensureHook("internalResolve");
      resolver.ensureHook("newInternalResolve");
      resolver.ensureHook("parsedResolve");
      resolver.ensureHook("describedResolve");
      resolver.ensureHook("rawResolve");
      resolver.ensureHook("normalResolve");
      resolver.ensureHook("internal");
      resolver.ensureHook("rawModule");
      resolver.ensureHook("module");
      resolver.ensureHook("resolveAsModule");
      resolver.ensureHook("undescribedResolveInPackage");
      resolver.ensureHook("resolveInPackage");
      resolver.ensureHook("resolveInExistingDirectory");
      resolver.ensureHook("relative");
      resolver.ensureHook("describedRelative");
      resolver.ensureHook("directory");
      resolver.ensureHook("undescribedExistingDirectory");
      resolver.ensureHook("existingDirectory");
      resolver.ensureHook("undescribedRawFile");
      resolver.ensureHook("rawFile");
      resolver.ensureHook("file");
      resolver.ensureHook("finalFile");
      resolver.ensureHook("existingFile");
      resolver.ensureHook("resolved");
      resolver.hooks.newInteralResolve = resolver.hooks.newInternalResolve;
      for (const { source, resolveOptions } of [
        { source: "resolve", resolveOptions: { fullySpecified } },
        { source: "internal-resolve", resolveOptions: { fullySpecified: false } }
      ]) {
        if (unsafeCache) {
          plugins.push(new UnsafeCachePlugin(source, cachePredicate, unsafeCache, cacheWithContext, `new-${source}`));
          plugins.push(new ParsePlugin(`new-${source}`, resolveOptions, "parsed-resolve"));
        } else {
          plugins.push(new ParsePlugin(source, resolveOptions, "parsed-resolve"));
        }
      }
      plugins.push(new DescriptionFilePlugin("parsed-resolve", descriptionFiles, false, "described-resolve"));
      plugins.push(new NextPlugin("after-parsed-resolve", "described-resolve"));
      plugins.push(new NextPlugin("described-resolve", "raw-resolve"));
      if (fallback.length > 0) {
        plugins.push(new AliasPlugin("described-resolve", fallback, "internal-resolve"));
      }
      if (alias.length > 0) {
        plugins.push(new AliasPlugin("raw-resolve", alias, "internal-resolve"));
      }
      aliasFields.forEach((item) => {
        plugins.push(new AliasFieldPlugin("raw-resolve", item, "internal-resolve"));
      });
      extensionAlias.forEach((item) => plugins.push(new ExtensionAliasPlugin("raw-resolve", item, "normal-resolve")));
      plugins.push(new NextPlugin("raw-resolve", "normal-resolve"));
      if (preferRelative) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
      }
      plugins.push(new ConditionalPlugin("after-normal-resolve", { module: true }, "resolve as module", false, "raw-module"));
      plugins.push(new ConditionalPlugin("after-normal-resolve", { internal: true }, "resolve as internal import", false, "internal"));
      if (preferAbsolute) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
      }
      if (roots.size > 0) {
        plugins.push(new RootsPlugin("after-normal-resolve", roots, "relative"));
      }
      if (!preferRelative && !preferAbsolute) {
        plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
      }
      importsFields.forEach((importsField) => {
        plugins.push(new ImportsFieldPlugin("internal", conditionNames, importsField, "relative", "internal-resolve"));
      });
      exportsFields.forEach((exportsField) => {
        plugins.push(new SelfReferencePlugin("raw-module", exportsField, "resolve-as-module"));
      });
      modules.forEach((item) => {
        if (Array.isArray(item)) {
          if (item.includes("node_modules") && pnpApi) {
            plugins.push(new ModulesInHierarchicalDirectoriesPlugin("raw-module", item.filter((i) => i !== "node_modules"), "module"));
            plugins.push(new PnpPlugin("raw-module", pnpApi, "undescribed-resolve-in-package"));
          } else {
            plugins.push(new ModulesInHierarchicalDirectoriesPlugin("raw-module", item, "module"));
          }
        } else {
          plugins.push(new ModulesInRootPlugin("raw-module", item, "module"));
        }
      });
      plugins.push(new JoinRequestPartPlugin("module", "resolve-as-module"));
      if (!resolveToContext) {
        plugins.push(new ConditionalPlugin("resolve-as-module", { directory: false, request: "." }, "single file module", true, "undescribed-raw-file"));
      }
      plugins.push(new DirectoryExistsPlugin("resolve-as-module", "undescribed-resolve-in-package"));
      plugins.push(new DescriptionFilePlugin("undescribed-resolve-in-package", descriptionFiles, false, "resolve-in-package"));
      plugins.push(new NextPlugin("after-undescribed-resolve-in-package", "resolve-in-package"));
      exportsFields.forEach((exportsField) => {
        plugins.push(new ExportsFieldPlugin("resolve-in-package", conditionNames, exportsField, "relative"));
      });
      plugins.push(new NextPlugin("resolve-in-package", "resolve-in-existing-directory"));
      plugins.push(new JoinRequestPlugin("resolve-in-existing-directory", "relative"));
      plugins.push(new DescriptionFilePlugin("relative", descriptionFiles, true, "described-relative"));
      plugins.push(new NextPlugin("after-relative", "described-relative"));
      if (resolveToContext) {
        plugins.push(new NextPlugin("described-relative", "directory"));
      } else {
        plugins.push(new ConditionalPlugin("described-relative", { directory: false }, null, true, "raw-file"));
        plugins.push(new ConditionalPlugin("described-relative", { fullySpecified: false }, "as directory", true, "directory"));
      }
      plugins.push(new DirectoryExistsPlugin("directory", "undescribed-existing-directory"));
      if (resolveToContext) {
        plugins.push(new NextPlugin("undescribed-existing-directory", "resolved"));
      } else {
        plugins.push(new DescriptionFilePlugin("undescribed-existing-directory", descriptionFiles, false, "existing-directory"));
        mainFiles.forEach((item) => {
          plugins.push(new UseFilePlugin("undescribed-existing-directory", item, "undescribed-raw-file"));
        });
        mainFields.forEach((item) => {
          plugins.push(new MainFieldPlugin("existing-directory", item, "resolve-in-existing-directory"));
        });
        mainFiles.forEach((item) => {
          plugins.push(new UseFilePlugin("existing-directory", item, "undescribed-raw-file"));
        });
        plugins.push(new DescriptionFilePlugin("undescribed-raw-file", descriptionFiles, true, "raw-file"));
        plugins.push(new NextPlugin("after-undescribed-raw-file", "raw-file"));
        plugins.push(new ConditionalPlugin("raw-file", { fullySpecified: true }, null, false, "file"));
        if (!enforceExtension) {
          plugins.push(new TryNextPlugin("raw-file", "no extension", "file"));
        }
        extensions.forEach((item) => {
          plugins.push(new AppendPlugin("raw-file", item, "file"));
        });
        if (alias.length > 0)
          plugins.push(new AliasPlugin("file", alias, "internal-resolve"));
        aliasFields.forEach((item) => {
          plugins.push(new AliasFieldPlugin("file", item, "internal-resolve"));
        });
        plugins.push(new NextPlugin("file", "final-file"));
        plugins.push(new FileExistsPlugin("final-file", "existing-file"));
        if (symlinks)
          plugins.push(new SymlinkPlugin("existing-file", "existing-file"));
        plugins.push(new NextPlugin("existing-file", "resolved"));
      }
      const resolved = resolver.hooks.resolved;
      if (restrictions.size > 0) {
        plugins.push(new RestrictionsPlugin(resolved, restrictions));
      }
      plugins.push(new ResultPlugin(resolved));
      for (const plugin of plugins) {
        if (typeof plugin === "function") {
          plugin.call(resolver, resolver);
        } else if (plugin) {
          plugin.apply(resolver);
        }
      }
      return resolver;
    };
    function mergeFilteredToArray(array, filter) {
      const result = [];
      const set = new Set(array);
      for (const item of set) {
        if (filter(item)) {
          const lastElement = result.length > 0 ? result[result.length - 1] : void 0;
          if (Array.isArray(lastElement)) {
            lastElement.push(item);
          } else {
            result.push([item]);
          }
        } else {
          result.push(item);
        }
      }
      return result;
    }
  }
});

// ../../../node_modules/enhanced-resolve/lib/CloneBasenamePlugin.js
var require_CloneBasenamePlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/CloneBasenamePlugin.js"(exports, module2) {
    "use strict";
    var basename = require_getPaths().basename;
    module2.exports = class CloneBasenamePlugin {
      constructor(source, target) {
        this.source = source;
        this.target = target;
      }
      apply(resolver) {
        const target = resolver.ensureHook(this.target);
        resolver.getHook(this.source).tapAsync("CloneBasenamePlugin", (request, resolveContext, callback) => {
          const requestPath = request.path;
          const filename = basename(requestPath);
          const filePath = resolver.join(requestPath, filename);
          const obj = {
            ...request,
            path: filePath,
            relativePath: request.relativePath && resolver.join(request.relativePath, filename)
          };
          resolver.doResolve(target, obj, "using path: " + filePath, resolveContext, callback);
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/LogInfoPlugin.js
var require_LogInfoPlugin = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/LogInfoPlugin.js"(exports, module2) {
    "use strict";
    module2.exports = class LogInfoPlugin {
      constructor(source) {
        this.source = source;
      }
      apply(resolver) {
        const source = this.source;
        resolver.getHook(this.source).tapAsync("LogInfoPlugin", (request, resolveContext, callback) => {
          if (!resolveContext.log)
            return callback();
          const log = resolveContext.log;
          const prefix = "[" + source + "] ";
          if (request.path)
            log(prefix + "Resolving in directory: " + request.path);
          if (request.request)
            log(prefix + "Resolving request: " + request.request);
          if (request.module)
            log(prefix + "Request is an module request.");
          if (request.directory)
            log(prefix + "Request is a directory request.");
          if (request.query)
            log(prefix + "Resolving request query: " + request.query);
          if (request.fragment)
            log(prefix + "Resolving request fragment: " + request.fragment);
          if (request.descriptionFilePath)
            log(prefix + "Has description data from " + request.descriptionFilePath);
          if (request.relativePath)
            log(prefix + "Relative path from description file is: " + request.relativePath);
          callback();
        });
      }
    };
  }
});

// ../../../node_modules/enhanced-resolve/lib/index.js
var require_lib2 = __commonJS({
  "../../../node_modules/enhanced-resolve/lib/index.js"(exports, module2) {
    "use strict";
    var fs2 = require_graceful_fs();
    var CachedInputFileSystem2 = require_CachedInputFileSystem();
    var ResolverFactory2 = require_ResolverFactory();
    var nodeFileSystem2 = new CachedInputFileSystem2(fs2, 4e3);
    var nodeContext2 = {
      environments: ["node+es3+es5+process+native"]
    };
    var asyncResolver = ResolverFactory2.createResolver({
      conditionNames: ["node"],
      extensions: [".js", ".json", ".node"],
      fileSystem: nodeFileSystem2
    });
    var resolve2 = (context, path, request, resolveContext, callback) => {
      if (typeof context === "string") {
        callback = resolveContext;
        resolveContext = request;
        request = path;
        path = context;
        context = nodeContext2;
      }
      if (typeof callback !== "function") {
        callback = resolveContext;
      }
      asyncResolver.resolve(context, path, request, resolveContext, callback);
    };
    var syncResolver = ResolverFactory2.createResolver({
      conditionNames: ["node"],
      extensions: [".js", ".json", ".node"],
      useSyncFileSystemCalls: true,
      fileSystem: nodeFileSystem2
    });
    var resolveSync = (context, path, request) => {
      if (typeof context === "string") {
        request = path;
        path = context;
        context = nodeContext2;
      }
      return syncResolver.resolveSync(context, path, request);
    };
    function create(options) {
      const resolver = ResolverFactory2.createResolver({
        fileSystem: nodeFileSystem2,
        ...options
      });
      return function(context, path, request, resolveContext, callback) {
        if (typeof context === "string") {
          callback = resolveContext;
          resolveContext = request;
          request = path;
          path = context;
          context = nodeContext2;
        }
        if (typeof callback !== "function") {
          callback = resolveContext;
        }
        resolver.resolve(context, path, request, resolveContext, callback);
      };
    }
    function createSync(options) {
      const resolver = ResolverFactory2.createResolver({
        useSyncFileSystemCalls: true,
        fileSystem: nodeFileSystem2,
        ...options
      });
      return function(context, path, request) {
        if (typeof context === "string") {
          request = path;
          path = context;
          context = nodeContext2;
        }
        return resolver.resolveSync(context, path, request);
      };
    }
    var mergeExports = (obj, exports2) => {
      const descriptors = Object.getOwnPropertyDescriptors(exports2);
      Object.defineProperties(obj, descriptors);
      return Object.freeze(obj);
    };
    module2.exports = mergeExports(resolve2, {
      get sync() {
        return resolveSync;
      },
      create: mergeExports(create, {
        get sync() {
          return createSync;
        }
      }),
      ResolverFactory: ResolverFactory2,
      CachedInputFileSystem: CachedInputFileSystem2,
      get CloneBasenamePlugin() {
        return require_CloneBasenamePlugin();
      },
      get LogInfoPlugin() {
        return require_LogInfoPlugin();
      },
      get forEachBail() {
        return require_forEachBail();
      }
    });
  }
});

// src/tools/codegen.ts
__export(exports, {
  createDebugHandler: () => createDebugHandler,
  createDefaultState: () => createDefaultState,
  createDependencies: () => createDependencies,
  createRouteHandler: () => createRouteHandler
});

// ../../tooling/piral-cli/src/external/resolve.ts
var fs = __toModule(require_graceful_fs());
var import_enhanced_resolve = __toModule(require_lib2());
var nodeFileSystem = new import_enhanced_resolve.CachedInputFileSystem(fs, 100);
var nodeContext = {
  environments: ["node+es3+es5+process+native"]
};
var enhancedResolve = import_enhanced_resolve.ResolverFactory.createResolver({
  aliasFields: ["browser"],
  conditionNames: ["import", "module", "webpack", "development", "browser"],
  extensions: [".js", ".jsx", ".mjs", ".ts", ".tsx", ".json"],
  exportsFields: ["exports"],
  importsFields: ["imports"],
  mainFields: ["browser", "module", "main"],
  useSyncFileSystemCalls: true,
  fileSystem: nodeFileSystem
});
function getModulePath(root, moduleName) {
  const res = enhancedResolve.resolveSync(nodeContext, root, moduleName);
  if (!res) {
    throw new Error(`Could not find module "${moduleName}".`);
  }
  return res;
}

// src/tools/codegen.ts
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
function findPackagePath(moduleDir) {
  const packageJson = "package.json";
  const packagePath = (0, import_path.resolve)(moduleDir, packageJson);
  if ((0, import_fs.existsSync)(packagePath)) {
    return packagePath;
  }
  const newDir = (0, import_path.resolve)(moduleDir, "..");
  if (newDir !== moduleDir) {
    return findPackagePath(newDir);
  }
  return void 0;
}
function getPackageJson(root, packageName) {
  const moduleDir = (0, import_path.dirname)(getModulePath(root, packageName));
  try {
    const packagePath = findPackagePath(moduleDir);
    const content = (0, import_fs.readFileSync)(packagePath, "utf8");
    return JSON.parse(content) || {};
  } catch {
    return {};
  }
}
function getRouterVersion(root) {
  const router = "react-router";
  try {
    const { version } = getPackageJson(root, router);
    const [major] = version.split(".");
    return parseInt(major, 10);
  } catch {
    console.warn(`\u26A0 Could not determine version of ${router}. Falling back to v5.`);
    return 5;
  }
}
function getIdentifiers(root, packageName) {
  const identifiers = [packageName];
  try {
    const details = getPackageJson(root, packageName);
    if (details.version) {
      identifiers.push(`${packageName}@${details.version}`);
      if (details.name && details.name !== packageName) {
        identifiers.push(`${details.name}@${details.version}`);
      }
    }
  } catch {
  }
  return identifiers;
}
function getModulePathOrDefault(root, origin, name) {
  try {
    const absPath = getModulePath(root, name);
    const relPath = (0, import_path.relative)(origin, absPath);
    const path = relPath.split(import_path.sep).join(import_path.posix.sep);
    return path;
  } catch {
    return name;
  }
}
function createDependencies(imports, exports, opts) {
  const { root, appName, externals, origin } = opts;
  const assignments = [];
  const asyncAssignments = [];
  if (appName) {
    assignments.push(`deps['${appName}']={}`);
  }
  for (const external of externals) {
    if (external.endsWith("?")) {
      const name = external.replace(/\?+$/, "");
      const identifiers = getIdentifiers(root, name);
      const path = getModulePathOrDefault(root, origin, name);
      for (const id of identifiers) {
        asyncAssignments.push(`registerModule(${JSON.stringify(id)}, () => import(${JSON.stringify(path)}))`);
      }
    } else {
      const name = external;
      const identifiers = getIdentifiers(root, name);
      const path = getModulePathOrDefault(root, origin, name);
      const ref = `_${imports.length}`;
      imports.push(`import * as ${ref} from ${JSON.stringify(path)}`);
      for (const id of identifiers) {
        assignments.push(`deps[${JSON.stringify(id)}]=${ref}`);
      }
    }
  }
  if (asyncAssignments.length) {
    imports.push(`import { registerModule } from 'piral-base'`);
    assignments.push(...asyncAssignments);
  }
  exports.push(`
    export function fillDependencies(deps) {
      ${assignments.join(";")}
    }
  `);
}
function createDefaultState(imports, exports, opts) {
  const { root, cat, publicPath, isolation } = opts;
  const routerVersion = getRouterVersion(root);
  const wrap = isolation === "modern" ? "true" : "false";
  imports.push(`import { DefaultErrorInfo } from 'piral-core/${cat}/defaults/DefaultErrorInfo.js';`, `import { DefaultLoadingIndicator } from 'piral-core/${cat}/defaults/DefaultLoadingIndicator.js';`, `import { DefaultLayout } from 'piral-core/${cat}/defaults/DefaultLayout.js';`);
  if (routerVersion < 6) {
    imports.push(`import { DefaultRouter } from 'piral-core/${cat}/defaults/DefaultRouter_v5.js';`, `import { DefaultRouteSwitch } from 'piral-core/${cat}/defaults/DefaultRouteSwitch_v5.js';`, `import { createRedirect, createNavigation, useCurrentNavigation, useRouterContext } from 'piral-core/${cat}/defaults/navigator_v5.js'`);
  } else {
    imports.push(`import { DefaultRouter } from 'piral-core/${cat}/defaults/DefaultRouter_v6.js';`, `import { DefaultRouteSwitch } from 'piral-core/${cat}/defaults/DefaultRouteSwitch_v6.js';`, `import { createRedirect, createNavigation, useCurrentNavigation, useRouterContext } from 'piral-core/${cat}/defaults/navigator_v6.js'`);
  }
  exports.push(`
    export { createRedirect, createNavigation, useRouterContext };
  `);
  exports.push(`
    export const publicPath = ${JSON.stringify(publicPath)};
  `);
  exports.push(`
    export function createDefaultState() {
      return {
        app: {
          error: undefined,
          loading: typeof window !== 'undefined',
          wrap: ${wrap},
        },
        components: {
          ErrorInfo: DefaultErrorInfo,
          LoadingIndicator: DefaultLoadingIndicator,
          Router: DefaultRouter,
          RouteSwitch: DefaultRouteSwitch,
          Layout: DefaultLayout,
        },
        errorComponents: {},
        registry: {
          extensions: {},
          pages: {},
          wrappers: {},
        },
        routes: {},
        data: {},
        portals: {},
        modules: [],
      };
    }
  `);
}
function createDebugHandler(imports, exports, opts) {
  const { cat, debug, emulator } = opts;
  if (debug) {
    const originalCall = `originalDebugger(context, options, {
      defaultSettings: ${JSON.stringify(debug)},
      emulator: ${JSON.stringify(emulator)},
      ...debug,
    })`;
    imports.push(`import { integrateDebugger as originalDebugger } from "piral-core/${cat}/tools/debugger.js"`);
    exports.push(`export function integrateDebugger(context, options, debug) { return ${originalCall}; }`);
  } else {
    exports.push(`export function integrateDebugger() {}`);
  }
  if (emulator) {
    imports.push(`import { integrateEmulator } from "piral-core/${cat}/tools/emulator.js"`);
    exports.push(`export { integrateEmulator }`);
  } else {
    exports.push(`export function integrateEmulator() {}`);
  }
}
function createRouteHandler(imports, exports, opts) {
  const { cat, emulator } = opts;
  const assignments = [];
  imports.push(`import { useGlobalStateContext } from 'piral-core/${cat}/hooks/globalState.js';`);
  assignments.push(`
    useCurrentNavigation();
  `);
  if (emulator) {
    imports.push(`import { useDebugRouteFilter } from 'piral-debug-utils';`);
    assignments.push("return useDebugRouteFilter(paths);");
  } else {
    assignments.push("return paths;");
  }
  exports.push(`
    export function useRouteFilter(paths) {
      ${assignments.join("\n")}
    }
  `);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createDebugHandler,
  createDefaultState,
  createDependencies,
  createRouteHandler
});
