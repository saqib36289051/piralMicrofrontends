#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/yargs/build/lib/common-types.js
var require_common_types = __commonJS({
  "node_modules/yargs/build/lib/common-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectKeys = exports.assertSingleKey = exports.assertNotStrictEqual = void 0;
    var assert_1 = require("assert");
    function assertNotStrictEqual(actual, expected, message) {
      assert_1.notStrictEqual(actual, expected, message);
    }
    exports.assertNotStrictEqual = assertNotStrictEqual;
    function assertSingleKey(actual) {
      assert_1.strictEqual(typeof actual, "string");
    }
    exports.assertSingleKey = assertSingleKey;
    function objectKeys(object) {
      return Object.keys(object);
    }
    exports.objectKeys = objectKeys;
  }
});

// node_modules/yargs/build/lib/is-promise.js
var require_is_promise = __commonJS({
  "node_modules/yargs/build/lib/is-promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isPromise = void 0;
    function isPromise(maybePromise) {
      return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
    }
    exports.isPromise = isPromise;
  }
});

// node_modules/yargs/build/lib/yerror.js
var require_yerror = __commonJS({
  "node_modules/yargs/build/lib/yerror.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.YError = void 0;
    var YError = class extends Error {
      constructor(msg) {
        super(msg || "yargs error");
        this.name = "YError";
        Error.captureStackTrace(this, YError);
      }
    };
    exports.YError = YError;
  }
});

// node_modules/yargs/build/lib/parse-command.js
var require_parse_command = __commonJS({
  "node_modules/yargs/build/lib/parse-command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseCommand = void 0;
    function parseCommand(cmd) {
      const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
      const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
      const bregex = /\.*[\][<>]/g;
      const firstCommand = splitCommand.shift();
      if (!firstCommand)
        throw new Error(`No command found in: ${cmd}`);
      const parsedCommand = {
        cmd: firstCommand.replace(bregex, ""),
        demanded: [],
        optional: []
      };
      splitCommand.forEach((cmd2, i) => {
        let variadic = false;
        cmd2 = cmd2.replace(/\s/g, "");
        if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1)
          variadic = true;
        if (/^\[/.test(cmd2)) {
          parsedCommand.optional.push({
            cmd: cmd2.replace(bregex, "").split("|"),
            variadic
          });
        } else {
          parsedCommand.demanded.push({
            cmd: cmd2.replace(bregex, "").split("|"),
            variadic
          });
        }
      });
      return parsedCommand;
    }
    exports.parseCommand = parseCommand;
  }
});

// node_modules/yargs/build/lib/argsert.js
var require_argsert = __commonJS({
  "node_modules/yargs/build/lib/argsert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argsert = void 0;
    var yerror_1 = require_yerror();
    var parse_command_1 = require_parse_command();
    var positionName = ["first", "second", "third", "fourth", "fifth", "sixth"];
    function argsert(arg1, arg2, arg3) {
      function parseArgs() {
        return typeof arg1 === "object" ? [{ demanded: [], optional: [] }, arg1, arg2] : [parse_command_1.parseCommand(`cmd ${arg1}`), arg2, arg3];
      }
      try {
        let position = 0;
        let [parsed, callerArguments, length] = parseArgs();
        const args2 = [].slice.call(callerArguments);
        while (args2.length && args2[args2.length - 1] === void 0)
          args2.pop();
        length = length || args2.length;
        if (length < parsed.demanded.length) {
          throw new yerror_1.YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args2.length}.`);
        }
        const totalCommands = parsed.demanded.length + parsed.optional.length;
        if (length > totalCommands) {
          throw new yerror_1.YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
        }
        parsed.demanded.forEach((demanded) => {
          const arg = args2.shift();
          const observedType = guessType(arg);
          const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
          if (matchingTypes.length === 0)
            argumentTypeError(observedType, demanded.cmd, position);
          position += 1;
        });
        parsed.optional.forEach((optional) => {
          if (args2.length === 0)
            return;
          const arg = args2.shift();
          const observedType = guessType(arg);
          const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
          if (matchingTypes.length === 0)
            argumentTypeError(observedType, optional.cmd, position);
          position += 1;
        });
      } catch (err) {
        console.warn(err.stack);
      }
    }
    exports.argsert = argsert;
    function guessType(arg) {
      if (Array.isArray(arg)) {
        return "array";
      } else if (arg === null) {
        return "null";
      }
      return typeof arg;
    }
    function argumentTypeError(observedType, allowedTypes, position) {
      throw new yerror_1.YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
    }
  }
});

// node_modules/yargs/build/lib/middleware.js
var require_middleware = __commonJS({
  "node_modules/yargs/build/lib/middleware.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applyMiddleware = exports.commandMiddlewareFactory = exports.globalMiddlewareFactory = void 0;
    var argsert_1 = require_argsert();
    var is_promise_1 = require_is_promise();
    function globalMiddlewareFactory(globalMiddleware, context) {
      return function(callback, applyBeforeValidation = false) {
        argsert_1.argsert("<array|function> [boolean]", [callback, applyBeforeValidation], arguments.length);
        if (Array.isArray(callback)) {
          for (let i = 0; i < callback.length; i++) {
            if (typeof callback[i] !== "function") {
              throw Error("middleware must be a function");
            }
            callback[i].applyBeforeValidation = applyBeforeValidation;
          }
          Array.prototype.push.apply(globalMiddleware, callback);
        } else if (typeof callback === "function") {
          callback.applyBeforeValidation = applyBeforeValidation;
          globalMiddleware.push(callback);
        }
        return context;
      };
    }
    exports.globalMiddlewareFactory = globalMiddlewareFactory;
    function commandMiddlewareFactory(commandMiddleware) {
      if (!commandMiddleware)
        return [];
      return commandMiddleware.map((middleware) => {
        middleware.applyBeforeValidation = false;
        return middleware;
      });
    }
    exports.commandMiddlewareFactory = commandMiddlewareFactory;
    function applyMiddleware(argv, yargs2, middlewares, beforeValidation) {
      const beforeValidationError = new Error("middleware cannot return a promise when applyBeforeValidation is true");
      return middlewares.reduce((acc, middleware) => {
        if (middleware.applyBeforeValidation !== beforeValidation) {
          return acc;
        }
        if (is_promise_1.isPromise(acc)) {
          return acc.then((initialObj) => Promise.all([initialObj, middleware(initialObj, yargs2)])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
        } else {
          const result = middleware(acc, yargs2);
          if (beforeValidation && is_promise_1.isPromise(result))
            throw beforeValidationError;
          return is_promise_1.isPromise(result) ? result.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result);
        }
      }, argv);
    }
    exports.applyMiddleware = applyMiddleware;
  }
});

// node_modules/require-directory/index.js
var require_require_directory = __commonJS({
  "node_modules/require-directory/index.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var join = require("path").join;
    var resolve4 = require("path").resolve;
    var dirname3 = require("path").dirname;
    var defaultOptions = {
      extensions: ["js", "json", "coffee"],
      recurse: true,
      rename: function(name) {
        return name;
      },
      visit: function(obj) {
        return obj;
      }
    };
    function checkFileInclusion(path, filename, options) {
      return (
        // verify file has valid extension
        new RegExp("\\.(" + options.extensions.join("|") + ")$", "i").test(filename) && // if options.include is a RegExp, evaluate it and make sure the path passes
        !(options.include && options.include instanceof RegExp && !options.include.test(path)) && // if options.include is a function, evaluate it and make sure the path passes
        !(options.include && typeof options.include === "function" && !options.include(path, filename)) && // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass
        !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) && // if options.exclude is a function, evaluate it and make sure the path doesn't pass
        !(options.exclude && typeof options.exclude === "function" && options.exclude(path, filename))
      );
    }
    function requireDirectory(m, path, options) {
      var retval = {};
      if (path && !options && typeof path !== "string") {
        options = path;
        path = null;
      }
      options = options || {};
      for (var prop in defaultOptions) {
        if (typeof options[prop] === "undefined") {
          options[prop] = defaultOptions[prop];
        }
      }
      path = !path ? dirname3(m.filename) : resolve4(dirname3(m.filename), path);
      fs.readdirSync(path).forEach(function(filename) {
        var joined = join(path, filename), files2, key, obj;
        if (fs.statSync(joined).isDirectory() && options.recurse) {
          files2 = requireDirectory(m, joined, options);
          if (Object.keys(files2).length) {
            retval[options.rename(filename, joined, filename)] = files2;
          }
        } else {
          if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {
            key = filename.substring(0, filename.lastIndexOf("."));
            obj = m.require(joined);
            retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;
          }
        }
      });
      return retval;
    }
    module2.exports = requireDirectory;
    module2.exports.defaults = defaultOptions;
  }
});

// node_modules/which-module/index.js
var require_which_module = __commonJS({
  "node_modules/which-module/index.js"(exports, module2) {
    "use strict";
    module2.exports = function whichModule(exported) {
      for (var i = 0, files2 = Object.keys(require.cache), mod; i < files2.length; i++) {
        mod = require.cache[files2[i]];
        if (mod.exports === exported)
          return mod;
      }
      return null;
    };
  }
});

// node_modules/camelcase/index.js
var require_camelcase = __commonJS({
  "node_modules/camelcase/index.js"(exports, module2) {
    "use strict";
    var preserveCamelCase = (string) => {
      let isLastCharLower = false;
      let isLastCharUpper = false;
      let isLastLastCharUpper = false;
      for (let i = 0; i < string.length; i++) {
        const character = string[i];
        if (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {
          string = string.slice(0, i) + "-" + string.slice(i);
          isLastCharLower = false;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = true;
          i++;
        } else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {
          string = string.slice(0, i - 1) + "-" + string.slice(i - 1);
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = false;
          isLastCharLower = true;
        } else {
          isLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;
          isLastLastCharUpper = isLastCharUpper;
          isLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;
        }
      }
      return string;
    };
    var camelCase = (input, options) => {
      if (!(typeof input === "string" || Array.isArray(input))) {
        throw new TypeError("Expected the input to be `string | string[]`");
      }
      options = Object.assign({
        pascalCase: false
      }, options);
      const postProcess = (x) => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;
      if (Array.isArray(input)) {
        input = input.map((x) => x.trim()).filter((x) => x.length).join("-");
      } else {
        input = input.trim();
      }
      if (input.length === 0) {
        return "";
      }
      if (input.length === 1) {
        return options.pascalCase ? input.toUpperCase() : input.toLowerCase();
      }
      const hasUpperCase = input !== input.toLowerCase();
      if (hasUpperCase) {
        input = preserveCamelCase(input);
      }
      input = input.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (_, p1) => p1.toUpperCase()).replace(/\d+(\w|$)/g, (m) => m.toUpperCase());
      return postProcess(input);
    };
    module2.exports = camelCase;
    module2.exports.default = camelCase;
  }
});

// node_modules/decamelize/index.js
var require_decamelize = __commonJS({
  "node_modules/decamelize/index.js"(exports, module2) {
    "use strict";
    module2.exports = function(str, sep) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      sep = typeof sep === "undefined" ? "_" : sep;
      return str.replace(/([a-z\d])([A-Z])/g, "$1" + sep + "$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1" + sep + "$2").toLowerCase();
    };
  }
});

// node_modules/yargs/node_modules/yargs-parser/lib/tokenize-arg-string.js
var require_tokenize_arg_string = __commonJS({
  "node_modules/yargs/node_modules/yargs-parser/lib/tokenize-arg-string.js"(exports, module2) {
    module2.exports = function(argString) {
      if (Array.isArray(argString)) {
        return argString.map((e) => typeof e !== "string" ? e + "" : e);
      }
      argString = argString.trim();
      let i = 0;
      let prevC = null;
      let c = null;
      let opening = null;
      const args2 = [];
      for (let ii = 0; ii < argString.length; ii++) {
        prevC = c;
        c = argString.charAt(ii);
        if (c === " " && !opening) {
          if (!(prevC === " ")) {
            i++;
          }
          continue;
        }
        if (c === opening) {
          opening = null;
        } else if ((c === "'" || c === '"') && !opening) {
          opening = c;
        }
        if (!args2[i])
          args2[i] = "";
        args2[i] += c;
      }
      return args2;
    };
  }
});

// node_modules/yargs/node_modules/yargs-parser/index.js
var require_yargs_parser = __commonJS({
  "node_modules/yargs/node_modules/yargs-parser/index.js"(exports, module2) {
    var camelCase = require_camelcase();
    var decamelize = require_decamelize();
    var path = require("path");
    var tokenizeArgString = require_tokenize_arg_string();
    var util = require("util");
    function parse(args2, opts) {
      opts = Object.assign(/* @__PURE__ */ Object.create(null), opts);
      args2 = tokenizeArgString(args2);
      const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
      const configuration = Object.assign({
        "boolean-negation": true,
        "camel-case-expansion": true,
        "combine-arrays": false,
        "dot-notation": true,
        "duplicate-arguments-array": true,
        "flatten-duplicate-arrays": true,
        "greedy-arrays": true,
        "halt-at-non-option": false,
        "nargs-eats-options": false,
        "negation-prefix": "no-",
        "parse-numbers": true,
        "populate--": false,
        "set-placeholder-key": false,
        "short-option-groups": true,
        "strip-aliased": false,
        "strip-dashed": false,
        "unknown-options-as-args": false
      }, opts.configuration);
      const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
      const configObjects = opts.configObjects || [];
      const envPrefix = opts.envPrefix;
      const notFlagsOption = configuration["populate--"];
      const notFlagsArgv = notFlagsOption ? "--" : "_";
      const newAliases = /* @__PURE__ */ Object.create(null);
      const defaulted = /* @__PURE__ */ Object.create(null);
      const __ = opts.__ || util.format;
      const flags = {
        aliases: /* @__PURE__ */ Object.create(null),
        arrays: /* @__PURE__ */ Object.create(null),
        bools: /* @__PURE__ */ Object.create(null),
        strings: /* @__PURE__ */ Object.create(null),
        numbers: /* @__PURE__ */ Object.create(null),
        counts: /* @__PURE__ */ Object.create(null),
        normalize: /* @__PURE__ */ Object.create(null),
        configs: /* @__PURE__ */ Object.create(null),
        nargs: /* @__PURE__ */ Object.create(null),
        coercions: /* @__PURE__ */ Object.create(null),
        keys: []
      };
      const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
      const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
      [].concat(opts.array).filter(Boolean).forEach(function(opt) {
        const key = opt.key || opt;
        const assignment = Object.keys(opt).map(function(key2) {
          return {
            boolean: "bools",
            string: "strings",
            number: "numbers"
          }[key2];
        }).filter(Boolean).pop();
        if (assignment) {
          flags[assignment][key] = true;
        }
        flags.arrays[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.boolean).filter(Boolean).forEach(function(key) {
        flags.bools[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key) {
        flags.strings[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.number).filter(Boolean).forEach(function(key) {
        flags.numbers[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.count).filter(Boolean).forEach(function(key) {
        flags.counts[key] = true;
        flags.keys.push(key);
      });
      [].concat(opts.normalize).filter(Boolean).forEach(function(key) {
        flags.normalize[key] = true;
        flags.keys.push(key);
      });
      Object.keys(opts.narg || {}).forEach(function(k) {
        flags.nargs[k] = opts.narg[k];
        flags.keys.push(k);
      });
      Object.keys(opts.coerce || {}).forEach(function(k) {
        flags.coercions[k] = opts.coerce[k];
        flags.keys.push(k);
      });
      if (Array.isArray(opts.config) || typeof opts.config === "string") {
        ;
        [].concat(opts.config).filter(Boolean).forEach(function(key) {
          flags.configs[key] = true;
        });
      } else {
        Object.keys(opts.config || {}).forEach(function(k) {
          flags.configs[k] = opts.config[k];
        });
      }
      extendAliases(opts.key, aliases, opts.default, flags.arrays);
      Object.keys(defaults).forEach(function(key) {
        (flags.aliases[key] || []).forEach(function(alias) {
          defaults[alias] = defaults[key];
        });
      });
      let error = null;
      checkConfiguration();
      let notFlags = [];
      const argv = Object.assign(/* @__PURE__ */ Object.create(null), { _: [] });
      const argvReturn = {};
      for (let i = 0; i < args2.length; i++) {
        const arg = args2[i];
        let broken;
        let key;
        let letters;
        let m;
        let next;
        let value;
        if (arg !== "--" && isUnknownOptionAsArg(arg)) {
          argv._.push(arg);
        } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
          m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
          if (checkAllAliases(m[1], flags.arrays)) {
            i = eatArray(i, m[1], args2, m[2]);
          } else if (checkAllAliases(m[1], flags.nargs) !== false) {
            i = eatNargs(i, m[1], args2, m[2]);
          } else {
            setArg(m[1], m[2]);
          }
        } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
          key = arg.match(negatedBoolean)[1];
          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);
        } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
          key = arg.match(/^--?(.+)/)[1];
          if (checkAllAliases(key, flags.arrays)) {
            i = eatArray(i, key, args2);
          } else if (checkAllAliases(key, flags.nargs) !== false) {
            i = eatNargs(i, key, args2);
          } else {
            next = args2[i + 1];
            if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
              setArg(key, next);
              i++;
            } else if (/^(true|false)$/.test(next)) {
              setArg(key, next);
              i++;
            } else {
              setArg(key, defaultValue(key));
            }
          }
        } else if (arg.match(/^-.\..+=/)) {
          m = arg.match(/^-([^=]+)=([\s\S]*)$/);
          setArg(m[1], m[2]);
        } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
          next = args2[i + 1];
          key = arg.match(/^-(.\..+)/)[1];
          if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
            setArg(key, next);
            i++;
          } else {
            setArg(key, defaultValue(key));
          }
        } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
          letters = arg.slice(1, -1).split("");
          broken = false;
          for (let j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (letters[j + 1] && letters[j + 1] === "=") {
              value = arg.slice(j + 3);
              key = letters[j];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args2, value);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args2, value);
              } else {
                setArg(key, value);
              }
              broken = true;
              break;
            }
            if (next === "-") {
              setArg(letters[j], next);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], next);
              broken = true;
              break;
            } else {
              setArg(letters[j], defaultValue(letters[j]));
            }
          }
          key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (checkAllAliases(key, flags.arrays)) {
              i = eatArray(i, key, args2);
            } else if (checkAllAliases(key, flags.nargs) !== false) {
              i = eatNargs(i, key, args2);
            } else {
              next = args2[i + 1];
              if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else if (/^(true|false)$/.test(next)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          }
        } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
          key = arg.slice(1);
          setArg(key, defaultValue(key));
        } else if (arg === "--") {
          notFlags = args2.slice(i + 1);
          break;
        } else if (configuration["halt-at-non-option"]) {
          notFlags = args2.slice(i);
          break;
        } else {
          argv._.push(maybeCoerceNumber("_", arg));
        }
      }
      applyEnvVars(argv, true);
      applyEnvVars(argv, false);
      setConfig(argv);
      setConfigObjects();
      applyDefaultsAndAliases(argv, flags.aliases, defaults, true);
      applyCoercions(argv);
      if (configuration["set-placeholder-key"])
        setPlaceholderKeys(argv);
      Object.keys(flags.counts).forEach(function(key) {
        if (!hasKey(argv, key.split(".")))
          setArg(key, 0);
      });
      if (notFlagsOption && notFlags.length)
        argv[notFlagsArgv] = [];
      notFlags.forEach(function(key) {
        argv[notFlagsArgv].push(key);
      });
      if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
        Object.keys(argv).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
          delete argv[key];
        });
      }
      if (configuration["strip-aliased"]) {
        ;
        [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
          if (configuration["camel-case-expansion"]) {
            delete argv[alias.split(".").map((prop) => camelCase(prop)).join(".")];
          }
          delete argv[alias];
        });
      }
      function eatNargs(i, key, args3, argAfterEqualSign) {
        let ii;
        let toEat = checkAllAliases(key, flags.nargs);
        toEat = isNaN(toEat) ? 1 : toEat;
        if (toEat === 0) {
          if (!isUndefined(argAfterEqualSign)) {
            error = Error(__("Argument unexpected for: %s", key));
          }
          setArg(key, defaultValue(key));
          return i;
        }
        let available = isUndefined(argAfterEqualSign) ? 0 : 1;
        if (configuration["nargs-eats-options"]) {
          if (args3.length - (i + 1) + available < toEat) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          available = toEat;
        } else {
          for (ii = i + 1; ii < args3.length; ii++) {
            if (!args3[ii].match(/^-[^0-9]/) || args3[ii].match(negative) || isUnknownOptionAsArg(args3[ii]))
              available++;
            else
              break;
          }
          if (available < toEat)
            error = Error(__("Not enough arguments following: %s", key));
        }
        let consumed = Math.min(available, toEat);
        if (!isUndefined(argAfterEqualSign) && consumed > 0) {
          setArg(key, argAfterEqualSign);
          consumed--;
        }
        for (ii = i + 1; ii < consumed + i + 1; ii++) {
          setArg(key, args3[ii]);
        }
        return i + consumed;
      }
      function eatArray(i, key, args3, argAfterEqualSign) {
        let argsToSet = [];
        let next = argAfterEqualSign || args3[i + 1];
        const nargsCount = checkAllAliases(key, flags.nargs);
        if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
          argsToSet.push(true);
        } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
          if (defaults[key] !== void 0) {
            const defVal = defaults[key];
            argsToSet = Array.isArray(defVal) ? defVal : [defVal];
          }
        } else {
          if (!isUndefined(argAfterEqualSign)) {
            argsToSet.push(processValue(key, argAfterEqualSign));
          }
          for (let ii = i + 1; ii < args3.length; ii++) {
            if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && argsToSet.length >= nargsCount)
              break;
            next = args3[ii];
            if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))
              break;
            i = ii;
            argsToSet.push(processValue(key, next));
          }
        }
        if (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0) {
          error = Error(__("Not enough arguments following: %s", key));
        }
        setArg(key, argsToSet);
        return i;
      }
      function setArg(key, val) {
        if (/-/.test(key) && configuration["camel-case-expansion"]) {
          const alias = key.split(".").map(function(prop) {
            return camelCase(prop);
          }).join(".");
          addNewAlias(key, alias);
        }
        const value = processValue(key, val);
        const splitKey = key.split(".");
        setKey(argv, splitKey, value);
        if (flags.aliases[key]) {
          flags.aliases[key].forEach(function(x) {
            x = x.split(".");
            setKey(argv, x, value);
          });
        }
        if (splitKey.length > 1 && configuration["dot-notation"]) {
          ;
          (flags.aliases[splitKey[0]] || []).forEach(function(x) {
            x = x.split(".");
            const a = [].concat(splitKey);
            a.shift();
            x = x.concat(a);
            if (!(flags.aliases[key] || []).includes(x.join("."))) {
              setKey(argv, x, value);
            }
          });
        }
        if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
          const keys = [key].concat(flags.aliases[key] || []);
          keys.forEach(function(key2) {
            Object.defineProperty(argvReturn, key2, {
              enumerable: true,
              get() {
                return val;
              },
              set(value2) {
                val = typeof value2 === "string" ? path.normalize(value2) : value2;
              }
            });
          });
        }
      }
      function addNewAlias(key, alias) {
        if (!(flags.aliases[key] && flags.aliases[key].length)) {
          flags.aliases[key] = [alias];
          newAliases[alias] = true;
        }
        if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
          addNewAlias(alias, key);
        }
      }
      function processValue(key, val) {
        if (typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0]) {
          val = val.substring(1, val.length - 1);
        }
        if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
          if (typeof val === "string")
            val = val === "true";
        }
        let value = Array.isArray(val) ? val.map(function(v) {
          return maybeCoerceNumber(key, v);
        }) : maybeCoerceNumber(key, val);
        if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === "boolean")) {
          value = increment;
        }
        if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
          if (Array.isArray(val))
            value = val.map(path.normalize);
          else
            value = path.normalize(val);
        }
        return value;
      }
      function maybeCoerceNumber(key, value) {
        if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {
          const shouldCoerceNumber = isNumber(value) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(value));
          if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers))
            value = Number(value);
        }
        return value;
      }
      function setConfig(argv2) {
        const configLookup = /* @__PURE__ */ Object.create(null);
        applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
        Object.keys(flags.configs).forEach(function(configKey) {
          const configPath = argv2[configKey] || configLookup[configKey];
          if (configPath) {
            try {
              let config = null;
              const resolvedConfigPath = path.resolve(process.cwd(), configPath);
              if (typeof flags.configs[configKey] === "function") {
                try {
                  config = flags.configs[configKey](resolvedConfigPath);
                } catch (e) {
                  config = e;
                }
                if (config instanceof Error) {
                  error = config;
                  return;
                }
              } else {
                config = require(resolvedConfigPath);
              }
              setConfigObject(config);
            } catch (ex) {
              if (argv2[configKey])
                error = Error(__("Invalid JSON config file: %s", configPath));
            }
          }
        });
      }
      function setConfigObject(config, prev) {
        Object.keys(config).forEach(function(key) {
          const value = config[key];
          const fullKey = prev ? prev + "." + key : key;
          if (typeof value === "object" && value !== null && !Array.isArray(value) && configuration["dot-notation"]) {
            setConfigObject(value, fullKey);
          } else {
            if (!hasKey(argv, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
              setArg(fullKey, value);
            }
          }
        });
      }
      function setConfigObjects() {
        if (typeof configObjects === "undefined")
          return;
        configObjects.forEach(function(configObject) {
          setConfigObject(configObject);
        });
      }
      function applyEnvVars(argv2, configOnly) {
        if (typeof envPrefix === "undefined")
          return;
        const prefix = typeof envPrefix === "string" ? envPrefix : "";
        Object.keys(process.env).forEach(function(envVar) {
          if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
            const keys = envVar.split("__").map(function(key, i) {
              if (i === 0) {
                key = key.substring(prefix.length);
              }
              return camelCase(key);
            });
            if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv2, keys)) {
              setArg(keys.join("."), process.env[envVar]);
            }
          }
        });
      }
      function applyCoercions(argv2) {
        let coerce;
        const applied = /* @__PURE__ */ new Set();
        Object.keys(argv2).forEach(function(key) {
          if (!applied.has(key)) {
            coerce = checkAllAliases(key, flags.coercions);
            if (typeof coerce === "function") {
              try {
                const value = maybeCoerceNumber(key, coerce(argv2[key]));
                [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                  applied.add(ali);
                  argv2[ali] = value;
                });
              } catch (err) {
                error = err;
              }
            }
          }
        });
      }
      function setPlaceholderKeys(argv2) {
        flags.keys.forEach((key) => {
          if (~key.indexOf("."))
            return;
          if (typeof argv2[key] === "undefined")
            argv2[key] = void 0;
        });
        return argv2;
      }
      function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
        Object.keys(defaults2).forEach(function(key) {
          if (!hasKey(obj, key.split("."))) {
            setKey(obj, key.split("."), defaults2[key]);
            if (canLog)
              defaulted[key] = true;
            (aliases2[key] || []).forEach(function(x) {
              if (hasKey(obj, x.split(".")))
                return;
              setKey(obj, x.split("."), defaults2[key]);
            });
          }
        });
      }
      function hasKey(obj, keys) {
        let o = obj;
        if (!configuration["dot-notation"])
          keys = [keys.join(".")];
        keys.slice(0, -1).forEach(function(key2) {
          o = o[key2] || {};
        });
        const key = keys[keys.length - 1];
        if (typeof o !== "object")
          return false;
        else
          return key in o;
      }
      function setKey(obj, keys, value) {
        let o = obj;
        if (!configuration["dot-notation"])
          keys = [keys.join(".")];
        keys.slice(0, -1).forEach(function(key2, index) {
          key2 = sanitizeKey(key2);
          if (typeof o === "object" && o[key2] === void 0) {
            o[key2] = {};
          }
          if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
            if (Array.isArray(o[key2])) {
              o[key2].push({});
            } else {
              o[key2] = [o[key2], {}];
            }
            o = o[key2][o[key2].length - 1];
          } else {
            o = o[key2];
          }
        });
        const key = sanitizeKey(keys[keys.length - 1]);
        const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
        const isValueArray = Array.isArray(value);
        let duplicate = configuration["duplicate-arguments-array"];
        if (!duplicate && checkAllAliases(key, flags.nargs)) {
          duplicate = true;
          if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
            o[key] = void 0;
          }
        }
        if (value === increment) {
          o[key] = increment(o[key]);
        } else if (Array.isArray(o[key])) {
          if (duplicate && isTypeArray && isValueArray) {
            o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);
          } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
            o[key] = value;
          } else {
            o[key] = o[key].concat([value]);
          }
        } else if (o[key] === void 0 && isTypeArray) {
          o[key] = isValueArray ? value : [value];
        } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
          o[key] = [o[key], value];
        } else {
          o[key] = value;
        }
      }
      function extendAliases(...args3) {
        args3.forEach(function(obj) {
          Object.keys(obj || {}).forEach(function(key) {
            if (flags.aliases[key])
              return;
            flags.aliases[key] = [].concat(aliases[key] || []);
            flags.aliases[key].concat(key).forEach(function(x) {
              if (/-/.test(x) && configuration["camel-case-expansion"]) {
                const c = camelCase(x);
                if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                  flags.aliases[key].push(c);
                  newAliases[c] = true;
                }
              }
            });
            flags.aliases[key].concat(key).forEach(function(x) {
              if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                const c = decamelize(x, "-");
                if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                  flags.aliases[key].push(c);
                  newAliases[c] = true;
                }
              }
            });
            flags.aliases[key].forEach(function(x) {
              flags.aliases[x] = [key].concat(flags.aliases[key].filter(function(y) {
                return x !== y;
              }));
            });
          });
        });
      }
      function checkAllAliases(key, flag) {
        const toCheck = [].concat(flags.aliases[key] || [], key);
        const keys = Object.keys(flag);
        const setAlias = toCheck.find((key2) => keys.includes(key2));
        return setAlias ? flag[setAlias] : false;
      }
      function hasAnyFlag(key) {
        const toCheck = [].concat(Object.keys(flags).map((k) => flags[k]));
        return toCheck.some(function(flag) {
          return Array.isArray(flag) ? flag.includes(key) : flag[key];
        });
      }
      function hasFlagsMatching(arg, ...patterns) {
        const toCheck = [].concat(...patterns);
        return toCheck.some(function(pattern) {
          const match = arg.match(pattern);
          return match && hasAnyFlag(match[1]);
        });
      }
      function hasAllShortFlags(arg) {
        if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
          return false;
        }
        let hasAllFlags = true;
        let next;
        const letters = arg.slice(1).split("");
        for (let j = 0; j < letters.length; j++) {
          next = arg.slice(j + 2);
          if (!hasAnyFlag(letters[j])) {
            hasAllFlags = false;
            break;
          }
          if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
            break;
          }
        }
        return hasAllFlags;
      }
      function isUnknownOptionAsArg(arg) {
        return configuration["unknown-options-as-args"] && isUnknownOption(arg);
      }
      function isUnknownOption(arg) {
        if (arg.match(negative)) {
          return false;
        }
        if (hasAllShortFlags(arg)) {
          return false;
        }
        const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
        const normalFlag = /^-+([^=]+?)$/;
        const flagEndingInHyphen = /^-+([^=]+?)-$/;
        const flagEndingInDigits = /^-+([^=]+?\d+)$/;
        const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
        return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
      }
      function defaultValue(key) {
        if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
          return defaults[key];
        } else {
          return defaultForType(guessType(key));
        }
      }
      function defaultForType(type) {
        const def = {
          boolean: true,
          string: "",
          number: void 0,
          array: []
        };
        return def[type];
      }
      function guessType(key) {
        let type = "boolean";
        if (checkAllAliases(key, flags.strings))
          type = "string";
        else if (checkAllAliases(key, flags.numbers))
          type = "number";
        else if (checkAllAliases(key, flags.bools))
          type = "boolean";
        else if (checkAllAliases(key, flags.arrays))
          type = "array";
        return type;
      }
      function isNumber(x) {
        if (x === null || x === void 0)
          return false;
        if (typeof x === "number")
          return true;
        if (/^0x[0-9a-f]+$/i.test(x))
          return true;
        if (x.length > 1 && x[0] === "0")
          return false;
        return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
      }
      function isUndefined(num) {
        return num === void 0;
      }
      function checkConfiguration() {
        Object.keys(flags.counts).find((key) => {
          if (checkAllAliases(key, flags.arrays)) {
            error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
            return true;
          } else if (checkAllAliases(key, flags.nargs)) {
            error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
            return true;
          }
        });
      }
      return {
        argv: Object.assign(argvReturn, argv),
        error,
        aliases: Object.assign({}, flags.aliases),
        newAliases: Object.assign({}, newAliases),
        defaulted: Object.assign({}, defaulted),
        configuration
      };
    }
    function combineAliases(aliases) {
      const aliasArrays = [];
      const combined = /* @__PURE__ */ Object.create(null);
      let change = true;
      Object.keys(aliases).forEach(function(key) {
        aliasArrays.push(
          [].concat(aliases[key], key)
        );
      });
      while (change) {
        change = false;
        for (let i = 0; i < aliasArrays.length; i++) {
          for (let ii = i + 1; ii < aliasArrays.length; ii++) {
            const intersect = aliasArrays[i].filter(function(v) {
              return aliasArrays[ii].indexOf(v) !== -1;
            });
            if (intersect.length) {
              aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
              aliasArrays.splice(ii, 1);
              change = true;
              break;
            }
          }
        }
      }
      aliasArrays.forEach(function(aliasArray) {
        aliasArray = aliasArray.filter(function(v, i, self) {
          return self.indexOf(v) === i;
        });
        combined[aliasArray.pop()] = aliasArray;
      });
      return combined;
    }
    function increment(orig) {
      return orig !== void 0 ? orig + 1 : 1;
    }
    function Parser(args2, opts) {
      const result = parse(args2.slice(), opts);
      return result.argv;
    }
    Parser.detailed = function(args2, opts) {
      return parse(args2.slice(), opts);
    };
    function sanitizeKey(key) {
      if (key === "__proto__")
        return "___proto___";
      return key;
    }
    module2.exports = Parser;
  }
});

// node_modules/yargs/build/lib/command.js
var require_command = __commonJS({
  "node_modules/yargs/build/lib/command.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isCommandBuilderCallback = exports.isCommandBuilderDefinition = exports.isCommandHandlerDefinition = exports.command = void 0;
    var common_types_1 = require_common_types();
    var is_promise_1 = require_is_promise();
    var middleware_1 = require_middleware();
    var parse_command_1 = require_parse_command();
    var path = require("path");
    var util_1 = require("util");
    var yargs_1 = require_yargs();
    var requireDirectory = require_require_directory();
    var whichModule = require_which_module();
    var Parser = require_yargs_parser();
    var DEFAULT_MARKER = /(^\*)|(^\$0)/;
    function command2(yargs2, usage, validation, globalMiddleware = []) {
      const self = {};
      let handlers = {};
      let aliasMap = {};
      let defaultCommand;
      self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        let aliases = [];
        const middlewares = middleware_1.commandMiddlewareFactory(commandMiddleware);
        handler = handler || (() => {
        });
        if (Array.isArray(cmd)) {
          aliases = cmd.slice(1);
          cmd = cmd[0];
        } else if (isCommandHandlerDefinition(cmd)) {
          let command3 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : moduleName(cmd);
          if (cmd.aliases)
            command3 = [].concat(command3).concat(cmd.aliases);
          self.addHandler(command3, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
          return;
        }
        if (isCommandBuilderDefinition(builder)) {
          self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
          return;
        }
        const parsedCommand = parse_command_1.parseCommand(cmd);
        aliases = aliases.map((alias) => parse_command_1.parseCommand(alias).cmd);
        let isDefault = false;
        const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {
          if (DEFAULT_MARKER.test(c)) {
            isDefault = true;
            return false;
          }
          return true;
        });
        if (parsedAliases.length === 0 && isDefault)
          parsedAliases.push("$0");
        if (isDefault) {
          parsedCommand.cmd = parsedAliases[0];
          aliases = parsedAliases.slice(1);
          cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
        }
        aliases.forEach((alias) => {
          aliasMap[alias] = parsedCommand.cmd;
        });
        if (description !== false) {
          usage.command(cmd, description, isDefault, aliases, deprecated);
        }
        handlers[parsedCommand.cmd] = {
          original: cmd,
          description,
          handler,
          builder: builder || {},
          middlewares,
          deprecated,
          demanded: parsedCommand.demanded,
          optional: parsedCommand.optional
        };
        if (isDefault)
          defaultCommand = handlers[parsedCommand.cmd];
      };
      self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {
        opts = opts || {};
        if (typeof opts.recurse !== "boolean")
          opts.recurse = false;
        if (!Array.isArray(opts.extensions))
          opts.extensions = ["js"];
        const parentVisit = typeof opts.visit === "function" ? opts.visit : (o) => o;
        opts.visit = function visit(obj, joined, filename) {
          const visited = parentVisit(obj, joined, filename);
          if (visited) {
            if (~context.files.indexOf(joined))
              return visited;
            context.files.push(joined);
            self.addHandler(visited);
          }
          return visited;
        };
        requireDirectory({ require: req, filename: callerFile }, dir, opts);
      };
      function moduleName(obj) {
        const mod = whichModule(obj);
        if (!mod)
          throw new Error(`No command name given for module: ${util_1.inspect(obj)}`);
        return commandFromFilename(mod.filename);
      }
      function commandFromFilename(filename) {
        return path.basename(filename, path.extname(filename));
      }
      function extractDesc({ describe, description, desc }) {
        for (const test of [describe, description, desc]) {
          if (typeof test === "string" || test === false)
            return test;
          common_types_1.assertNotStrictEqual(test, true);
        }
        return false;
      }
      self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));
      self.getCommandHandlers = () => handlers;
      self.hasDefaultCommand = () => !!defaultCommand;
      self.runCommand = function runCommand(command3, yargs3, parsed, commandIndex) {
        let aliases = parsed.aliases;
        const commandHandler = handlers[command3] || handlers[aliasMap[command3]] || defaultCommand;
        const currentContext = yargs3.getContext();
        let numFiles = currentContext.files.length;
        const parentCommands = currentContext.commands.slice();
        let innerArgv = parsed.argv;
        let positionalMap = {};
        if (command3) {
          currentContext.commands.push(command3);
          currentContext.fullCommands.push(commandHandler.original);
        }
        const builder = commandHandler.builder;
        if (isCommandBuilderCallback(builder)) {
          const builderOutput = builder(yargs3.reset(parsed.aliases));
          const innerYargs = yargs_1.isYargsInstance(builderOutput) ? builderOutput : yargs3;
          if (shouldUpdateUsage(innerYargs)) {
            innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
          }
          innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
          aliases = innerYargs.parsed.aliases;
        } else if (isCommandBuilderOptionDefinitions(builder)) {
          const innerYargs = yargs3.reset(parsed.aliases);
          if (shouldUpdateUsage(innerYargs)) {
            innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
          }
          Object.keys(commandHandler.builder).forEach((key) => {
            innerYargs.option(key, builder[key]);
          });
          innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
          aliases = innerYargs.parsed.aliases;
        }
        if (!yargs3._hasOutput()) {
          positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);
        }
        const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);
        middleware_1.applyMiddleware(innerArgv, yargs3, middlewares, true);
        if (!yargs3._hasOutput()) {
          yargs3._runValidation(innerArgv, aliases, positionalMap, yargs3.parsed.error, !command3);
        }
        if (commandHandler.handler && !yargs3._hasOutput()) {
          yargs3._setHasOutput();
          const populateDoubleDash = !!yargs3.getOptions().configuration["populate--"];
          if (!populateDoubleDash)
            yargs3._copyDoubleDash(innerArgv);
          innerArgv = middleware_1.applyMiddleware(innerArgv, yargs3, middlewares, false);
          let handlerResult;
          if (is_promise_1.isPromise(innerArgv)) {
            handlerResult = innerArgv.then((argv) => commandHandler.handler(argv));
          } else {
            handlerResult = commandHandler.handler(innerArgv);
          }
          const handlerFinishCommand = yargs3.getHandlerFinishCommand();
          if (is_promise_1.isPromise(handlerResult)) {
            yargs3.getUsageInstance().cacheHelpMessage();
            handlerResult.then((value) => {
              if (handlerFinishCommand) {
                handlerFinishCommand(value);
              }
            }).catch((error) => {
              try {
                yargs3.getUsageInstance().fail(null, error);
              } catch (err) {
              }
            }).then(() => {
              yargs3.getUsageInstance().clearCachedHelpMessage();
            });
          } else {
            if (handlerFinishCommand) {
              handlerFinishCommand(handlerResult);
            }
          }
        }
        if (command3) {
          currentContext.commands.pop();
          currentContext.fullCommands.pop();
        }
        numFiles = currentContext.files.length - numFiles;
        if (numFiles > 0)
          currentContext.files.splice(numFiles * -1, numFiles);
        return innerArgv;
      };
      function shouldUpdateUsage(yargs3) {
        return !yargs3.getUsageInstance().getUsageDisabled() && yargs3.getUsageInstance().getUsage().length === 0;
      }
      function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
        const pc = parentCommands.filter((c2) => {
          return !DEFAULT_MARKER.test(c2);
        });
        pc.push(c);
        return `$0 ${pc.join(" ")}`;
      }
      self.runDefaultBuilderOn = function(yargs3) {
        common_types_1.assertNotStrictEqual(defaultCommand, void 0);
        if (shouldUpdateUsage(yargs3)) {
          const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
          yargs3.getUsageInstance().usage(commandString, defaultCommand.description);
        }
        const builder = defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
          builder(yargs3);
        } else {
          Object.keys(builder).forEach((key) => {
            yargs3.option(key, builder[key]);
          });
        }
      };
      function populatePositionals(commandHandler, argv, context) {
        argv._ = argv._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = {};
        validation.positionalCount(demanded.length, argv._.length);
        while (demanded.length) {
          const demand = demanded.shift();
          populatePositional(demand, argv, positionalMap);
        }
        while (optional.length) {
          const maybe = optional.shift();
          populatePositional(maybe, argv, positionalMap);
        }
        argv._ = context.commands.concat(argv._);
        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));
        return positionalMap;
      }
      function populatePositional(positional, argv, positionalMap) {
        const cmd = positional.cmd[0];
        if (positional.variadic) {
          positionalMap[cmd] = argv._.splice(0).map(String);
        } else {
          if (argv._.length)
            positionalMap[cmd] = [String(argv._.shift())];
        }
      }
      function postProcessPositionals(argv, positionalMap, parseOptions) {
        const options = Object.assign({}, yargs2.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)) {
          options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
        }
        options.array = options.array.concat(parseOptions.array);
        delete options.config;
        const unparsed = [];
        Object.keys(positionalMap).forEach((key) => {
          positionalMap[key].map((value) => {
            if (options.configuration["unknown-options-as-args"])
              options.key[key] = true;
            unparsed.push(`--${key}`);
            unparsed.push(value);
          });
        });
        if (!unparsed.length)
          return;
        const config = Object.assign({}, options.configuration, {
          "populate--": true
        });
        const parsed = Parser.detailed(unparsed, Object.assign({}, options, {
          configuration: config
        }));
        if (parsed.error) {
          yargs2.getUsageInstance().fail(parsed.error.message, parsed.error);
        } else {
          const positionalKeys = Object.keys(positionalMap);
          Object.keys(positionalMap).forEach((key) => {
            positionalKeys.push(...parsed.aliases[key]);
          });
          Object.keys(parsed.argv).forEach((key) => {
            if (positionalKeys.indexOf(key) !== -1) {
              if (!positionalMap[key])
                positionalMap[key] = parsed.argv[key];
              argv[key] = parsed.argv[key];
            }
          });
        }
      }
      self.cmdToParseOptions = function(cmdString) {
        const parseOptions = {
          array: [],
          default: {},
          alias: {},
          demand: {}
        };
        const parsed = parse_command_1.parseCommand(cmdString);
        parsed.demanded.forEach((d) => {
          const [cmd, ...aliases] = d.cmd;
          if (d.variadic) {
            parseOptions.array.push(cmd);
            parseOptions.default[cmd] = [];
          }
          parseOptions.alias[cmd] = aliases;
          parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach((o) => {
          const [cmd, ...aliases] = o.cmd;
          if (o.variadic) {
            parseOptions.array.push(cmd);
            parseOptions.default[cmd] = [];
          }
          parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
      };
      self.reset = () => {
        handlers = {};
        aliasMap = {};
        defaultCommand = void 0;
        return self;
      };
      const frozens = [];
      self.freeze = () => {
        frozens.push({
          handlers,
          aliasMap,
          defaultCommand
        });
      };
      self.unfreeze = () => {
        const frozen = frozens.pop();
        common_types_1.assertNotStrictEqual(frozen, void 0);
        ({
          handlers,
          aliasMap,
          defaultCommand
        } = frozen);
      };
      return self;
    }
    exports.command = command2;
    function isCommandHandlerDefinition(cmd) {
      return typeof cmd === "object";
    }
    exports.isCommandHandlerDefinition = isCommandHandlerDefinition;
    function isCommandBuilderDefinition(builder) {
      return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
    }
    exports.isCommandBuilderDefinition = isCommandBuilderDefinition;
    function isCommandBuilderCallback(builder) {
      return typeof builder === "function";
    }
    exports.isCommandBuilderCallback = isCommandBuilderCallback;
    function isCommandBuilderOptionDefinitions(builder) {
      return typeof builder === "object";
    }
  }
});

// node_modules/yargs/build/lib/obj-filter.js
var require_obj_filter = __commonJS({
  "node_modules/yargs/build/lib/obj-filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objFilter = void 0;
    var common_types_1 = require_common_types();
    function objFilter(original = {}, filter = () => true) {
      const obj = {};
      common_types_1.objectKeys(original).forEach((key) => {
        if (filter(key, original[key])) {
          obj[key] = original[key];
        }
      });
      return obj;
    }
    exports.objFilter = objFilter;
  }
});

// node_modules/set-blocking/index.js
var require_set_blocking = __commonJS({
  "node_modules/set-blocking/index.js"(exports, module2) {
    module2.exports = function(blocking) {
      [process.stdout, process.stderr].forEach(function(stream) {
        if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
          stream._handle.setBlocking(blocking);
        }
      });
    };
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// node_modules/is-fullwidth-code-point/index.js
var require_is_fullwidth_code_point = __commonJS({
  "node_modules/is-fullwidth-code-point/index.js"(exports, module2) {
    "use strict";
    var isFullwidthCodePoint = (codePoint) => {
      if (Number.isNaN(codePoint)) {
        return false;
      }
      if (codePoint >= 4352 && (codePoint <= 4447 || // Hangul Jamo
      codePoint === 9001 || // LEFT-POINTING ANGLE BRACKET
      codePoint === 9002 || // RIGHT-POINTING ANGLE BRACKET
      // CJK Radicals Supplement .. Enclosed CJK Letters and Months
      11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
      12880 <= codePoint && codePoint <= 19903 || // CJK Unified Ideographs .. Yi Radicals
      19968 <= codePoint && codePoint <= 42182 || // Hangul Jamo Extended-A
      43360 <= codePoint && codePoint <= 43388 || // Hangul Syllables
      44032 <= codePoint && codePoint <= 55203 || // CJK Compatibility Ideographs
      63744 <= codePoint && codePoint <= 64255 || // Vertical Forms
      65040 <= codePoint && codePoint <= 65049 || // CJK Compatibility Forms .. Small Form Variants
      65072 <= codePoint && codePoint <= 65131 || // Halfwidth and Fullwidth Forms
      65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || // Kana Supplement
      110592 <= codePoint && codePoint <= 110593 || // Enclosed Ideographic Supplement
      127488 <= codePoint && codePoint <= 127569 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
      131072 <= codePoint && codePoint <= 262141)) {
        return true;
      }
      return false;
    };
    module2.exports = isFullwidthCodePoint;
    module2.exports.default = isFullwidthCodePoint;
  }
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/emoji-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/string-width/index.js
var require_string_width = __commonJS({
  "node_modules/string-width/index.js"(exports, module2) {
    "use strict";
    var stripAnsi = require_strip_ansi();
    var isFullwidthCodePoint = require_is_fullwidth_code_point();
    var emojiRegex = require_emoji_regex();
    var stringWidth = (string) => {
      if (typeof string !== "string" || string.length === 0) {
        return 0;
      }
      string = stripAnsi(string);
      if (string.length === 0) {
        return 0;
      }
      string = string.replace(emojiRegex(), "  ");
      let width = 0;
      for (let i = 0; i < string.length; i++) {
        const code = string.codePointAt(i);
        if (code <= 31 || code >= 127 && code <= 159) {
          continue;
        }
        if (code >= 768 && code <= 879) {
          continue;
        }
        if (code > 65535) {
          i++;
        }
        width += isFullwidthCodePoint(code) ? 2 : 1;
      }
      return width;
    };
    module2.exports = stringWidth;
    module2.exports.default = stringWidth;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args2, saturation = null) {
      const [r, g, b] = args2;
      let value = saturation === null ? convert.rgb.hsv(args2)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args2) {
      return convert.rgb.ansi16(convert.hsv.rgb(args2), args2[2]);
    };
    convert.rgb.ansi256 = function(args2) {
      const r = args2[0];
      const g = args2[1];
      const b = args2[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args2) {
      let color = args2 % 10;
      if (color === 0 || color === 7) {
        if (args2 > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args2 > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args2) {
      if (args2 >= 232) {
        const c = (args2 - 232) * 10 + 8;
        return [c, c, c];
      }
      args2 -= 16;
      let rem;
      const r = Math.floor(args2 / 36) / 5 * 255;
      const g = Math.floor((rem = args2 % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args2) {
      const integer = ((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args2) {
      const match = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args2) {
      return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
    };
    convert.gray.hsl = function(args2) {
      return [0, 0, args2[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args2) {
        return to(from(args2));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args2) {
        const arg0 = args2[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args2 = arg0;
        }
        return fn(args2);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args2) {
        const arg0 = args2[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args2 = arg0;
        }
        const result = fn(args2);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args2) => {
      const code = fn(...args2);
      return `\x1B[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args2) => {
      const code = fn(...args2);
      return `\x1B[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args2) => {
      const rgb = fn(...args2);
      return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          // Bright color
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `\x1B[${style[0]}m`,
            close: `\x1B[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// node_modules/wrap-ansi/index.js
var require_wrap_ansi = __commonJS({
  "node_modules/wrap-ansi/index.js"(exports, module2) {
    "use strict";
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var ansiStyles = require_ansi_styles();
    var ESCAPES = /* @__PURE__ */ new Set([
      "\x1B",
      "\x9B"
    ]);
    var END_CODE = 39;
    var wrapAnsi = (code) => `${ESCAPES.values().next().value}[${code}m`;
    var wordLengths = (string) => string.split(" ").map((character) => stringWidth(character));
    var wrapWord = (rows, word, columns) => {
      const characters = [...word];
      let isInsideEscape = false;
      let visible = stringWidth(stripAnsi(rows[rows.length - 1]));
      for (const [index, character] of characters.entries()) {
        const characterLength = stringWidth(character);
        if (visible + characterLength <= columns) {
          rows[rows.length - 1] += character;
        } else {
          rows.push(character);
          visible = 0;
        }
        if (ESCAPES.has(character)) {
          isInsideEscape = true;
        } else if (isInsideEscape && character === "m") {
          isInsideEscape = false;
          continue;
        }
        if (isInsideEscape) {
          continue;
        }
        visible += characterLength;
        if (visible === columns && index < characters.length - 1) {
          rows.push("");
          visible = 0;
        }
      }
      if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
        rows[rows.length - 2] += rows.pop();
      }
    };
    var stringVisibleTrimSpacesRight = (str) => {
      const words = str.split(" ");
      let last = words.length;
      while (last > 0) {
        if (stringWidth(words[last - 1]) > 0) {
          break;
        }
        last--;
      }
      if (last === words.length) {
        return str;
      }
      return words.slice(0, last).join(" ") + words.slice(last).join("");
    };
    var exec2 = (string, columns, options = {}) => {
      if (options.trim !== false && string.trim() === "") {
        return "";
      }
      let pre = "";
      let ret = "";
      let escapeCode;
      const lengths = wordLengths(string);
      let rows = [""];
      for (const [index, word] of string.split(" ").entries()) {
        if (options.trim !== false) {
          rows[rows.length - 1] = rows[rows.length - 1].trimLeft();
        }
        let rowLength = stringWidth(rows[rows.length - 1]);
        if (index !== 0) {
          if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
            rows.push("");
            rowLength = 0;
          }
          if (rowLength > 0 || options.trim === false) {
            rows[rows.length - 1] += " ";
            rowLength++;
          }
        }
        if (options.hard && lengths[index] > columns) {
          const remainingColumns = columns - rowLength;
          const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
          const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
          if (breaksStartingNextLine < breaksStartingThisLine) {
            rows.push("");
          }
          wrapWord(rows, word, columns);
          continue;
        }
        if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {
          if (options.wordWrap === false && rowLength < columns) {
            wrapWord(rows, word, columns);
            continue;
          }
          rows.push("");
        }
        if (rowLength + lengths[index] > columns && options.wordWrap === false) {
          wrapWord(rows, word, columns);
          continue;
        }
        rows[rows.length - 1] += word;
      }
      if (options.trim !== false) {
        rows = rows.map(stringVisibleTrimSpacesRight);
      }
      pre = rows.join("\n");
      for (const [index, character] of [...pre].entries()) {
        ret += character;
        if (ESCAPES.has(character)) {
          const code2 = parseFloat(/\d[^m]*/.exec(pre.slice(index, index + 4)));
          escapeCode = code2 === END_CODE ? null : code2;
        }
        const code = ansiStyles.codes.get(Number(escapeCode));
        if (escapeCode && code) {
          if (pre[index + 1] === "\n") {
            ret += wrapAnsi(code);
          } else if (character === "\n") {
            ret += wrapAnsi(escapeCode);
          }
        }
      }
      return ret;
    };
    module2.exports = (string, columns, options) => {
      return String(string).normalize().replace(/\r\n/g, "\n").split("\n").map((line) => exec2(line, columns, options)).join("\n");
    };
  }
});

// node_modules/cliui/index.js
var require_cliui = __commonJS({
  "node_modules/cliui/index.js"(exports, module2) {
    "use strict";
    var stringWidth = require_string_width();
    var stripAnsi = require_strip_ansi();
    var wrap = require_wrap_ansi();
    var align = {
      right: alignRight,
      center: alignCenter
    };
    var top = 0;
    var right = 1;
    var bottom = 2;
    var left = 3;
    var UI = class {
      constructor(opts) {
        this.width = opts.width;
        this.wrap = opts.wrap;
        this.rows = [];
      }
      span(...args2) {
        const cols = this.div(...args2);
        cols.span = true;
      }
      resetOutput() {
        this.rows = [];
      }
      div(...args2) {
        if (args2.length === 0) {
          this.div("");
        }
        if (this.wrap && this._shouldApplyLayoutDSL(...args2)) {
          return this._applyLayoutDSL(args2[0]);
        }
        const cols = args2.map((arg) => {
          if (typeof arg === "string") {
            return this._colFromString(arg);
          }
          return arg;
        });
        this.rows.push(cols);
        return cols;
      }
      _shouldApplyLayoutDSL(...args2) {
        return args2.length === 1 && typeof args2[0] === "string" && /[\t\n]/.test(args2[0]);
      }
      _applyLayoutDSL(str) {
        const rows = str.split("\n").map((row) => row.split("	"));
        let leftColumnWidth = 0;
        rows.forEach((columns) => {
          if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {
            leftColumnWidth = Math.min(
              Math.floor(this.width * 0.5),
              stringWidth(columns[0])
            );
          }
        });
        rows.forEach((columns) => {
          this.div(...columns.map((r, i) => {
            return {
              text: r.trim(),
              padding: this._measurePadding(r),
              width: i === 0 && columns.length > 1 ? leftColumnWidth : void 0
            };
          }));
        });
        return this.rows[this.rows.length - 1];
      }
      _colFromString(text) {
        return {
          text,
          padding: this._measurePadding(text)
        };
      }
      _measurePadding(str) {
        const noAnsi = stripAnsi(str);
        return [0, noAnsi.match(/\s*$/)[0].length, 0, noAnsi.match(/^\s*/)[0].length];
      }
      toString() {
        const lines = [];
        this.rows.forEach((row) => {
          this.rowToString(row, lines);
        });
        return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
      }
      rowToString(row, lines) {
        this._rasterize(row).forEach((rrow, r) => {
          let str = "";
          rrow.forEach((col, c) => {
            const { width } = row[c];
            const wrapWidth = this._negatePadding(row[c]);
            let ts5 = col;
            if (wrapWidth > stringWidth(col)) {
              ts5 += " ".repeat(wrapWidth - stringWidth(col));
            }
            if (row[c].align && row[c].align !== "left" && this.wrap) {
              ts5 = align[row[c].align](ts5, wrapWidth);
              if (stringWidth(ts5) < wrapWidth) {
                ts5 += " ".repeat(width - stringWidth(ts5) - 1);
              }
            }
            const padding = row[c].padding || [0, 0, 0, 0];
            if (padding[left]) {
              str += " ".repeat(padding[left]);
            }
            str += addBorder(row[c], ts5, "| ");
            str += ts5;
            str += addBorder(row[c], ts5, " |");
            if (padding[right]) {
              str += " ".repeat(padding[right]);
            }
            if (r === 0 && lines.length > 0) {
              str = this._renderInline(str, lines[lines.length - 1]);
            }
          });
          lines.push({
            text: str.replace(/ +$/, ""),
            span: row.span
          });
        });
        return lines;
      }
      // if the full 'source' can render in
      // the target line, do so.
      _renderInline(source, previousLine) {
        const leadingWhitespace = source.match(/^ */)[0].length;
        const target = previousLine.text;
        const targetTextWidth = stringWidth(target.trimRight());
        if (!previousLine.span) {
          return source;
        }
        if (!this.wrap) {
          previousLine.hidden = true;
          return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
          return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
      }
      _rasterize(row) {
        const rrows = [];
        const widths = this._columnWidths(row);
        let wrapped;
        row.forEach((col, c) => {
          col.width = widths[c];
          if (this.wrap) {
            wrapped = wrap(col.text, this._negatePadding(col), { hard: true }).split("\n");
          } else {
            wrapped = col.text.split("\n");
          }
          if (col.border) {
            wrapped.unshift("." + "-".repeat(this._negatePadding(col) + 2) + ".");
            wrapped.push("'" + "-".repeat(this._negatePadding(col) + 2) + "'");
          }
          if (col.padding) {
            wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
            wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
          }
          wrapped.forEach((str, r) => {
            if (!rrows[r]) {
              rrows.push([]);
            }
            const rrow = rrows[r];
            for (let i = 0; i < c; i++) {
              if (rrow[i] === void 0) {
                rrow.push("");
              }
            }
            rrow.push(str);
          });
        });
        return rrows;
      }
      _negatePadding(col) {
        let wrapWidth = col.width;
        if (col.padding) {
          wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
          wrapWidth -= 4;
        }
        return wrapWidth;
      }
      _columnWidths(row) {
        if (!this.wrap) {
          return row.map((col) => {
            return col.width || stringWidth(col.text);
          });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map((col) => {
          if (col.width) {
            unset--;
            remainingWidth -= col.width;
            return col.width;
          }
          return void 0;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
          if (w === void 0) {
            return Math.max(unsetWidth, _minWidth(row[i]));
          }
          return w;
        });
      }
    };
    function addBorder(col, ts5, style) {
      if (col.border) {
        if (/[.']-+[.']/.test(ts5)) {
          return "";
        }
        if (ts5.trim().length !== 0) {
          return style;
        }
        return "  ";
      }
      return "";
    }
    function _minWidth(col) {
      const padding = col.padding || [];
      const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
      if (col.border) {
        return minWidth + 4;
      }
      return minWidth;
    }
    function getWindowWidth() {
      if (typeof process === "object" && process.stdout && process.stdout.columns) {
        return process.stdout.columns;
      }
    }
    function alignRight(str, width) {
      str = str.trim();
      const strWidth = stringWidth(str);
      if (strWidth < width) {
        return " ".repeat(width - strWidth) + str;
      }
      return str;
    }
    function alignCenter(str, width) {
      str = str.trim();
      const strWidth = stringWidth(str);
      if (strWidth >= width) {
        return str;
      }
      return " ".repeat(width - strWidth >> 1) + str;
    }
    module2.exports = function(opts = {}) {
      return new UI({
        width: opts.width || getWindowWidth() || /* istanbul ignore next */
        80,
        wrap: opts.wrap !== false
      });
    };
  }
});

// node_modules/yargs/build/lib/usage.js
var require_usage = __commonJS({
  "node_modules/yargs/build/lib/usage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.usage = void 0;
    var common_types_1 = require_common_types();
    var obj_filter_1 = require_obj_filter();
    var path = require("path");
    var yerror_1 = require_yerror();
    var decamelize = require_decamelize();
    var setBlocking = require_set_blocking();
    var stringWidth = require_string_width();
    function usage(yargs2, y18n) {
      const __ = y18n.__;
      const self = {};
      const fails = [];
      self.failFn = function failFn(f) {
        fails.push(f);
      };
      let failMessage = null;
      let showHelpOnFail = true;
      self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {
        function parseFunctionArgs() {
          return typeof arg1 === "string" ? [true, arg1] : [arg1, arg2];
        }
        const [enabled, message] = parseFunctionArgs();
        failMessage = message;
        showHelpOnFail = enabled;
        return self;
      };
      let failureOutput = false;
      self.fail = function fail(msg, err) {
        const logger = yargs2._getLoggerInstance();
        if (fails.length) {
          for (let i = fails.length - 1; i >= 0; --i) {
            fails[i](msg, err, self);
          }
        } else {
          if (yargs2.getExitProcess())
            setBlocking(true);
          if (!failureOutput) {
            failureOutput = true;
            if (showHelpOnFail) {
              yargs2.showHelp("error");
              logger.error();
            }
            if (msg || err)
              logger.error(msg || err);
            if (failMessage) {
              if (msg || err)
                logger.error("");
              logger.error(failMessage);
            }
          }
          err = err || new yerror_1.YError(msg);
          if (yargs2.getExitProcess()) {
            return yargs2.exit(1);
          } else if (yargs2._hasParseCallback()) {
            return yargs2.exit(1, err);
          } else {
            throw err;
          }
        }
      };
      let usages = [];
      let usageDisabled = false;
      self.usage = (msg, description) => {
        if (msg === null) {
          usageDisabled = true;
          usages = [];
          return self;
        }
        usageDisabled = false;
        usages.push([msg, description || ""]);
        return self;
      };
      self.getUsage = () => {
        return usages;
      };
      self.getUsageDisabled = () => {
        return usageDisabled;
      };
      self.getPositionalGroupName = () => {
        return __("Positionals:");
      };
      let examples = [];
      self.example = (cmd, description) => {
        examples.push([cmd, description || ""]);
      };
      let commands = [];
      self.command = function command2(cmd, description, isDefault, aliases, deprecated = false) {
        if (isDefault) {
          commands = commands.map((cmdArray) => {
            cmdArray[2] = false;
            return cmdArray;
          });
        }
        commands.push([cmd, description || "", isDefault, aliases, deprecated]);
      };
      self.getCommands = () => commands;
      let descriptions = {};
      self.describe = function describe(keyOrKeys, desc) {
        if (Array.isArray(keyOrKeys)) {
          keyOrKeys.forEach((k) => {
            self.describe(k, desc);
          });
        } else if (typeof keyOrKeys === "object") {
          Object.keys(keyOrKeys).forEach((k) => {
            self.describe(k, keyOrKeys[k]);
          });
        } else {
          descriptions[keyOrKeys] = desc;
        }
      };
      self.getDescriptions = () => descriptions;
      let epilogs = [];
      self.epilog = (msg) => {
        epilogs.push(msg);
      };
      let wrapSet = false;
      let wrap;
      self.wrap = (cols) => {
        wrapSet = true;
        wrap = cols;
      };
      function getWrap() {
        if (!wrapSet) {
          wrap = windowWidth();
          wrapSet = true;
        }
        return wrap;
      }
      const deferY18nLookupPrefix = "__yargsString__:";
      self.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
      self.help = function help() {
        if (cachedHelpMessage)
          return cachedHelpMessage;
        normalizeAliases();
        const base$0 = yargs2.customScriptName ? yargs2.$0 : path.basename(yargs2.$0);
        const demandedOptions = yargs2.getDemandedOptions();
        const demandedCommands = yargs2.getDemandedCommands();
        const deprecatedOptions = yargs2.getDeprecatedOptions();
        const groups = yargs2.getGroups();
        const options = yargs2.getOptions();
        let keys = [];
        keys = keys.concat(Object.keys(descriptions));
        keys = keys.concat(Object.keys(demandedOptions));
        keys = keys.concat(Object.keys(demandedCommands));
        keys = keys.concat(Object.keys(options.default));
        keys = keys.filter(filterHiddenOptions);
        keys = Object.keys(keys.reduce((acc, key) => {
          if (key !== "_")
            acc[key] = true;
          return acc;
        }, {}));
        const theWrap = getWrap();
        const ui = require_cliui()({
          width: theWrap,
          wrap: !!theWrap
        });
        if (!usageDisabled) {
          if (usages.length) {
            usages.forEach((usage2) => {
              ui.div(`${usage2[0].replace(/\$0/g, base$0)}`);
              if (usage2[1]) {
                ui.div({ text: `${usage2[1]}`, padding: [1, 0, 0, 0] });
              }
            });
            ui.div();
          } else if (commands.length) {
            let u = null;
            if (demandedCommands._) {
              u = `${base$0} <${__("command")}>
`;
            } else {
              u = `${base$0} [${__("command")}]
`;
            }
            ui.div(`${u}`);
          }
        }
        if (commands.length) {
          ui.div(__("Commands:"));
          const context = yargs2.getContext();
          const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
          if (yargs2.getParserConfiguration()["sort-commands"] === true) {
            commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
          }
          commands.forEach((command2) => {
            const commandString = `${base$0} ${parentCommands}${command2[0].replace(/^\$0 ?/, "")}`;
            ui.span({
              text: commandString,
              padding: [0, 2, 0, 2],
              width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
            }, { text: command2[1] });
            const hints = [];
            if (command2[2])
              hints.push(`[${__("default")}]`);
            if (command2[3] && command2[3].length) {
              hints.push(`[${__("aliases:")} ${command2[3].join(", ")}]`);
            }
            if (command2[4]) {
              if (typeof command2[4] === "string") {
                hints.push(`[${__("deprecated: %s", command2[4])}]`);
              } else {
                hints.push(`[${__("deprecated")}]`);
              }
            }
            if (hints.length) {
              ui.div({ text: hints.join(" "), padding: [0, 0, 0, 2], align: "right" });
            } else {
              ui.div();
            }
          });
          ui.div();
        }
        const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs2.parsed.newAliases) || []);
        keys = keys.filter((key) => !yargs2.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
        const defaultGroup = __("Options:");
        if (!groups[defaultGroup])
          groups[defaultGroup] = [];
        addUngroupedKeys(keys, options.alias, groups, defaultGroup);
        Object.keys(groups).forEach((groupName) => {
          if (!groups[groupName].length)
            return;
          const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
            if (~aliasKeys.indexOf(key))
              return key;
            for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== void 0; i++) {
              if (~(options.alias[aliasKey] || []).indexOf(key))
                return aliasKey;
            }
            return key;
          });
          if (normalizedKeys.length < 1)
            return;
          ui.div(groupName);
          const switches = normalizedKeys.reduce((acc, key) => {
            acc[key] = [key].concat(options.alias[key] || []).map((sw) => {
              if (groupName === self.getPositionalGroupName())
                return sw;
              else {
                return (
                  // matches yargs-parser logic in which single-digits
                  // aliases declared with a boolean type are now valid
                  (/^[0-9]$/.test(sw) ? ~options.boolean.indexOf(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw
                );
              }
            }).join(", ");
            return acc;
          }, {});
          normalizedKeys.forEach((key) => {
            const kswitch = switches[key];
            let desc = descriptions[key] || "";
            let type = null;
            if (~desc.lastIndexOf(deferY18nLookupPrefix))
              desc = __(desc.substring(deferY18nLookupPrefix.length));
            if (~options.boolean.indexOf(key))
              type = `[${__("boolean")}]`;
            if (~options.count.indexOf(key))
              type = `[${__("count")}]`;
            if (~options.string.indexOf(key))
              type = `[${__("string")}]`;
            if (~options.normalize.indexOf(key))
              type = `[${__("string")}]`;
            if (~options.array.indexOf(key))
              type = `[${__("array")}]`;
            if (~options.number.indexOf(key))
              type = `[${__("number")}]`;
            const deprecatedExtra = (deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`;
            const extra = [
              key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
              type,
              key in demandedOptions ? `[${__("required")}]` : null,
              options.choices && options.choices[key] ? `[${__("choices:")} ${self.stringifiedValues(options.choices[key])}]` : null,
              defaultString(options.default[key], options.defaultDescription[key])
            ].filter(Boolean).join(" ");
            ui.span({ text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4 }, desc);
            if (extra)
              ui.div({ text: extra, padding: [0, 0, 0, 2], align: "right" });
            else
              ui.div();
          });
          ui.div();
        });
        if (examples.length) {
          ui.div(__("Examples:"));
          examples.forEach((example) => {
            example[0] = example[0].replace(/\$0/g, base$0);
          });
          examples.forEach((example) => {
            if (example[1] === "") {
              ui.div({
                text: example[0],
                padding: [0, 2, 0, 2]
              });
            } else {
              ui.div({
                text: example[0],
                padding: [0, 2, 0, 2],
                width: maxWidth(examples, theWrap) + 4
              }, {
                text: example[1]
              });
            }
          });
          ui.div();
        }
        if (epilogs.length > 0) {
          const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
          ui.div(`${e}
`);
        }
        return ui.toString().replace(/\s*$/, "");
      };
      function maxWidth(table, theWrap, modifier) {
        let width = 0;
        if (!Array.isArray(table)) {
          table = Object.values(table).map((v) => [v]);
        }
        table.forEach((v) => {
          width = Math.max(stringWidth(modifier ? `${modifier} ${v[0]}` : v[0]), width);
        });
        if (theWrap)
          width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
        return width;
      }
      function normalizeAliases() {
        const demandedOptions = yargs2.getDemandedOptions();
        const options = yargs2.getOptions();
        (Object.keys(options.alias) || []).forEach((key) => {
          options.alias[key].forEach((alias) => {
            if (descriptions[alias])
              self.describe(key, descriptions[alias]);
            if (alias in demandedOptions)
              yargs2.demandOption(key, demandedOptions[alias]);
            if (~options.boolean.indexOf(alias))
              yargs2.boolean(key);
            if (~options.count.indexOf(alias))
              yargs2.count(key);
            if (~options.string.indexOf(alias))
              yargs2.string(key);
            if (~options.normalize.indexOf(alias))
              yargs2.normalize(key);
            if (~options.array.indexOf(alias))
              yargs2.array(key);
            if (~options.number.indexOf(alias))
              yargs2.number(key);
          });
        });
      }
      let cachedHelpMessage;
      self.cacheHelpMessage = function() {
        cachedHelpMessage = this.help();
      };
      self.clearCachedHelpMessage = function() {
        cachedHelpMessage = void 0;
      };
      function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
        let groupedKeys = [];
        let toCheck = null;
        Object.keys(groups).forEach((group) => {
          groupedKeys = groupedKeys.concat(groups[group]);
        });
        keys.forEach((key) => {
          toCheck = [key].concat(aliases[key]);
          if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
            groups[defaultGroup].push(key);
          }
        });
        return groupedKeys;
      }
      function filterHiddenOptions(key) {
        return yargs2.getOptions().hiddenOptions.indexOf(key) < 0 || yargs2.parsed.argv[yargs2.getOptions().showHiddenOpt];
      }
      self.showHelp = (level) => {
        const logger = yargs2._getLoggerInstance();
        if (!level)
          level = "error";
        const emit = typeof level === "function" ? level : logger[level];
        emit(self.help());
      };
      self.functionDescription = (fn) => {
        const description = fn.name ? decamelize(fn.name, "-") : __("generated-value");
        return ["(", description, ")"].join("");
      };
      self.stringifiedValues = function stringifiedValues(values, separator) {
        let string = "";
        const sep = separator || ", ";
        const array = [].concat(values);
        if (!values || !array.length)
          return string;
        array.forEach((value) => {
          if (string.length)
            string += sep;
          string += JSON.stringify(value);
        });
        return string;
      };
      function defaultString(value, defaultDescription) {
        let string = `[${__("default:")} `;
        if (value === void 0 && !defaultDescription)
          return null;
        if (defaultDescription) {
          string += defaultDescription;
        } else {
          switch (typeof value) {
            case "string":
              string += `"${value}"`;
              break;
            case "object":
              string += JSON.stringify(value);
              break;
            default:
              string += value;
          }
        }
        return `${string}]`;
      }
      function windowWidth() {
        const maxWidth2 = 80;
        if (typeof process === "object" && process.stdout && process.stdout.columns) {
          return Math.min(maxWidth2, process.stdout.columns);
        } else {
          return maxWidth2;
        }
      }
      let version = null;
      self.version = (ver) => {
        version = ver;
      };
      self.showVersion = () => {
        const logger = yargs2._getLoggerInstance();
        logger.log(version);
      };
      self.reset = function reset(localLookup) {
        failMessage = null;
        failureOutput = false;
        usages = [];
        usageDisabled = false;
        epilogs = [];
        examples = [];
        commands = [];
        descriptions = obj_filter_1.objFilter(descriptions, (k) => !localLookup[k]);
        return self;
      };
      const frozens = [];
      self.freeze = function freeze() {
        frozens.push({
          failMessage,
          failureOutput,
          usages,
          usageDisabled,
          epilogs,
          examples,
          commands,
          descriptions
        });
      };
      self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        common_types_1.assertNotStrictEqual(frozen, void 0);
        ({
          failMessage,
          failureOutput,
          usages,
          usageDisabled,
          epilogs,
          examples,
          commands,
          descriptions
        } = frozen);
      };
      return self;
    }
    exports.usage = usage;
  }
});

// node_modules/yargs/build/lib/completion-templates.js
var require_completion_templates = __commonJS({
  "node_modules/yargs/build/lib/completion-templates.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.completionZshTemplate = exports.completionShTemplate = void 0;
    exports.completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o default -F _yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
    exports.completionZshTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
  }
});

// node_modules/yargs/build/lib/completion.js
var require_completion = __commonJS({
  "node_modules/yargs/build/lib/completion.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.completion = void 0;
    var command_1 = require_command();
    var templates = require_completion_templates();
    var is_promise_1 = require_is_promise();
    var parse_command_1 = require_parse_command();
    var path = require("path");
    var common_types_1 = require_common_types();
    function completion(yargs2, usage, command2) {
      const self = {
        completionKey: "get-yargs-completions"
      };
      let aliases;
      self.setParsed = function setParsed(parsed) {
        aliases = parsed.aliases;
      };
      const zshShell = process.env.SHELL && process.env.SHELL.indexOf("zsh") !== -1 || process.env.ZSH_NAME && process.env.ZSH_NAME.indexOf("zsh") !== -1;
      self.getCompletion = function getCompletion(args2, done) {
        const completions = [];
        const current = args2.length ? args2[args2.length - 1] : "";
        const argv = yargs2.parse(args2, true);
        const parentCommands = yargs2.getContext().commands;
        function runCompletionFunction(argv2) {
          common_types_1.assertNotStrictEqual(completionFunction, null);
          if (isSyncCompletionFunction(completionFunction)) {
            const result = completionFunction(current, argv2);
            if (is_promise_1.isPromise(result)) {
              return result.then((list) => {
                process.nextTick(() => {
                  done(list);
                });
              }).catch((err) => {
                process.nextTick(() => {
                  throw err;
                });
              });
            }
            return done(result);
          } else {
            return completionFunction(current, argv2, (completions2) => {
              done(completions2);
            });
          }
        }
        if (completionFunction) {
          return is_promise_1.isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);
        }
        const handlers = command2.getCommandHandlers();
        for (let i = 0, ii = args2.length; i < ii; ++i) {
          if (handlers[args2[i]] && handlers[args2[i]].builder) {
            const builder = handlers[args2[i]].builder;
            if (command_1.isCommandBuilderCallback(builder)) {
              const y = yargs2.reset();
              builder(y);
              return y.argv;
            }
          }
        }
        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {
          usage.getCommands().forEach((usageCommand) => {
            const commandName = parse_command_1.parseCommand(usageCommand[0]).cmd;
            if (args2.indexOf(commandName) === -1) {
              if (!zshShell) {
                completions.push(commandName);
              } else {
                const desc = usageCommand[1] || "";
                completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
              }
            }
          });
        }
        if (current.match(/^-/) || current === "" && completions.length === 0) {
          const descs = usage.getDescriptions();
          const options = yargs2.getOptions();
          Object.keys(options.key).forEach((key) => {
            const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
            let keyAndAliases = [key].concat(aliases[key] || []);
            if (negable)
              keyAndAliases = keyAndAliases.concat(keyAndAliases.map((key2) => `no-${key2}`));
            function completeOptionKey(key2) {
              const notInArgs = keyAndAliases.every((val) => args2.indexOf(`--${val}`) === -1);
              if (notInArgs) {
                const startsByTwoDashes = (s) => /^--/.test(s);
                const isShortOption = (s) => /^[^0-9]$/.test(s);
                const dashes = !startsByTwoDashes(current) && isShortOption(key2) ? "-" : "--";
                if (!zshShell) {
                  completions.push(dashes + key2);
                } else {
                  const desc = descs[key2] || "";
                  completions.push(dashes + `${key2.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "")}`);
                }
              }
            }
            completeOptionKey(key);
            if (negable && !!options.default[key])
              completeOptionKey(`no-${key}`);
          });
        }
        done(completions);
      };
      self.generateCompletionScript = function generateCompletionScript($0, cmd) {
        let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;
        const name = path.basename($0);
        if ($0.match(/\.js$/))
          $0 = `./${$0}`;
        script = script.replace(/{{app_name}}/g, name);
        script = script.replace(/{{completion_command}}/g, cmd);
        return script.replace(/{{app_path}}/g, $0);
      };
      let completionFunction = null;
      self.registerFunction = (fn) => {
        completionFunction = fn;
      };
      return self;
    }
    exports.completion = completion;
    function isSyncCompletionFunction(completionFunction) {
      return completionFunction.length < 3;
    }
  }
});

// node_modules/yargs/build/lib/levenshtein.js
var require_levenshtein = __commonJS({
  "node_modules/yargs/build/lib/levenshtein.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.levenshtein = void 0;
    function levenshtein(a, b) {
      if (a.length === 0)
        return b.length;
      if (b.length === 0)
        return a.length;
      const matrix = [];
      let i;
      for (i = 0; i <= b.length; i++) {
        matrix[i] = [i];
      }
      let j;
      for (j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
      }
      for (i = 1; i <= b.length; i++) {
        for (j = 1; j <= a.length; j++) {
          if (b.charAt(i - 1) === a.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1,
              // substitution
              Math.min(
                matrix[i][j - 1] + 1,
                // insertion
                matrix[i - 1][j] + 1
              )
            );
          }
        }
      }
      return matrix[b.length][a.length];
    }
    exports.levenshtein = levenshtein;
  }
});

// node_modules/yargs/build/lib/validation.js
var require_validation = __commonJS({
  "node_modules/yargs/build/lib/validation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validation = void 0;
    var argsert_1 = require_argsert();
    var common_types_1 = require_common_types();
    var levenshtein_1 = require_levenshtein();
    var obj_filter_1 = require_obj_filter();
    var specialKeys = ["$0", "--", "_"];
    function validation(yargs2, usage, y18n) {
      const __ = y18n.__;
      const __n = y18n.__n;
      const self = {};
      self.nonOptionCount = function nonOptionCount(argv) {
        const demandedCommands = yargs2.getDemandedCommands();
        const _s = argv._.length - yargs2.getContext().commands.length;
        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
          if (_s < demandedCommands._.min) {
            if (demandedCommands._.minMsg !== void 0) {
              usage.fail(
                // replace $0 with observed, $1 with expected.
                demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null
              );
            } else {
              usage.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s, demandedCommands._.min));
            }
          } else if (_s > demandedCommands._.max) {
            if (demandedCommands._.maxMsg !== void 0) {
              usage.fail(
                // replace $0 with observed, $1 with expected.
                demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null
              );
            } else {
              usage.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s, demandedCommands._.max));
            }
          }
        }
      };
      self.positionalCount = function positionalCount(required, observed) {
        if (observed < required) {
          usage.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed, required));
        }
      };
      self.requiredArguments = function requiredArguments(argv) {
        const demandedOptions = yargs2.getDemandedOptions();
        let missing = null;
        for (const key of Object.keys(demandedOptions)) {
          if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === "undefined") {
            missing = missing || {};
            missing[key] = demandedOptions[key];
          }
        }
        if (missing) {
          const customMsgs = [];
          for (const key of Object.keys(missing)) {
            const msg = missing[key];
            if (msg && customMsgs.indexOf(msg) < 0) {
              customMsgs.push(msg);
            }
          }
          const customMsg = customMsgs.length ? `
${customMsgs.join("\n")}` : "";
          usage.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
        }
      };
      self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {
        const commandKeys = yargs2.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs2.getContext();
        Object.keys(argv).forEach((key) => {
          if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs2._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {
            unknown.push(key);
          }
        });
        if (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand) {
          argv._.slice(currentContext.commands.length).forEach((key) => {
            if (commandKeys.indexOf(key) === -1) {
              unknown.push(key);
            }
          });
        }
        if (unknown.length > 0) {
          usage.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.join(", ")));
        }
      };
      self.unknownCommands = function unknownCommands(argv) {
        const commandKeys = yargs2.getCommandInstance().getCommands();
        const unknown = [];
        const currentContext = yargs2.getContext();
        if (currentContext.commands.length > 0 || commandKeys.length > 0) {
          argv._.slice(currentContext.commands.length).forEach((key) => {
            if (commandKeys.indexOf(key) === -1) {
              unknown.push(key);
            }
          });
        }
        if (unknown.length > 0) {
          usage.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
          return true;
        } else {
          return false;
        }
      };
      self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {
        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
          return false;
        }
        const newAliases = yargs2.parsed.newAliases;
        for (const a of [key, ...aliases[key]]) {
          if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {
            return true;
          }
        }
        return false;
      };
      self.limitedChoices = function limitedChoices(argv) {
        const options = yargs2.getOptions();
        const invalid = {};
        if (!Object.keys(options.choices).length)
          return;
        Object.keys(argv).forEach((key) => {
          if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
            [].concat(argv[key]).forEach((value) => {
              if (options.choices[key].indexOf(value) === -1 && value !== void 0) {
                invalid[key] = (invalid[key] || []).concat(value);
              }
            });
          }
        });
        const invalidKeys = Object.keys(invalid);
        if (!invalidKeys.length)
          return;
        let msg = __("Invalid values:");
        invalidKeys.forEach((key) => {
          msg += `
  ${__("Argument: %s, Given: %s, Choices: %s", key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;
        });
        usage.fail(msg);
      };
      let checks = [];
      self.check = function check(f, global) {
        checks.push({
          func: f,
          global
        });
      };
      self.customChecks = function customChecks(argv, aliases) {
        for (let i = 0, f; (f = checks[i]) !== void 0; i++) {
          const func = f.func;
          let result = null;
          try {
            result = func(argv, aliases);
          } catch (err) {
            usage.fail(err.message ? err.message : err, err);
            continue;
          }
          if (!result) {
            usage.fail(__("Argument check failed: %s", func.toString()));
          } else if (typeof result === "string" || result instanceof Error) {
            usage.fail(result.toString(), result);
          }
        }
      };
      let implied = {};
      self.implies = function implies(key, value) {
        argsert_1.argsert("<string|object> [array|number|string]", [key, value], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self.implies(k, key[k]);
          });
        } else {
          yargs2.global(key);
          if (!implied[key]) {
            implied[key] = [];
          }
          if (Array.isArray(value)) {
            value.forEach((i) => self.implies(key, i));
          } else {
            common_types_1.assertNotStrictEqual(value, void 0);
            implied[key].push(value);
          }
        }
      };
      self.getImplied = function getImplied() {
        return implied;
      };
      function keyExists(argv, val) {
        const num = Number(val);
        val = isNaN(num) ? val : num;
        if (typeof val === "number") {
          val = argv._.length >= val;
        } else if (val.match(/^--no-.+/)) {
          val = val.match(/^--no-(.+)/)[1];
          val = !argv[val];
        } else {
          val = argv[val];
        }
        return val;
      }
      self.implications = function implications(argv) {
        const implyFail = [];
        Object.keys(implied).forEach((key) => {
          const origKey = key;
          (implied[key] || []).forEach((value) => {
            let key2 = origKey;
            const origValue = value;
            key2 = keyExists(argv, key2);
            value = keyExists(argv, value);
            if (key2 && !value) {
              implyFail.push(` ${origKey} -> ${origValue}`);
            }
          });
        });
        if (implyFail.length) {
          let msg = `${__("Implications failed:")}
`;
          implyFail.forEach((value) => {
            msg += value;
          });
          usage.fail(msg);
        }
      };
      let conflicting = {};
      self.conflicts = function conflicts(key, value) {
        argsert_1.argsert("<string|object> [array|string]", [key, value], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self.conflicts(k, key[k]);
          });
        } else {
          yargs2.global(key);
          if (!conflicting[key]) {
            conflicting[key] = [];
          }
          if (Array.isArray(value)) {
            value.forEach((i) => self.conflicts(key, i));
          } else {
            conflicting[key].push(value);
          }
        }
      };
      self.getConflicting = () => conflicting;
      self.conflicting = function conflictingFn(argv) {
        Object.keys(argv).forEach((key) => {
          if (conflicting[key]) {
            conflicting[key].forEach((value) => {
              if (value && argv[key] !== void 0 && argv[value] !== void 0) {
                usage.fail(__("Arguments %s and %s are mutually exclusive", key, value));
              }
            });
          }
        });
      };
      self.recommendCommands = function recommendCommands(cmd, potentialCommands) {
        const threshold = 3;
        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
        let recommended = null;
        let bestDistance = Infinity;
        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== void 0; i++) {
          const d = levenshtein_1.levenshtein(cmd, candidate);
          if (d <= threshold && d < bestDistance) {
            bestDistance = d;
            recommended = candidate;
          }
        }
        if (recommended)
          usage.fail(__("Did you mean %s?", recommended));
      };
      self.reset = function reset(localLookup) {
        implied = obj_filter_1.objFilter(implied, (k) => !localLookup[k]);
        conflicting = obj_filter_1.objFilter(conflicting, (k) => !localLookup[k]);
        checks = checks.filter((c) => c.global);
        return self;
      };
      const frozens = [];
      self.freeze = function freeze() {
        frozens.push({
          implied,
          checks,
          conflicting
        });
      };
      self.unfreeze = function unfreeze() {
        const frozen = frozens.pop();
        common_types_1.assertNotStrictEqual(frozen, void 0);
        ({
          implied,
          checks,
          conflicting
        } = frozen);
      };
      return self;
    }
    exports.validation = validation;
  }
});

// node_modules/yargs/build/lib/apply-extends.js
var require_apply_extends = __commonJS({
  "node_modules/yargs/build/lib/apply-extends.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applyExtends = void 0;
    var fs = require("fs");
    var path = require("path");
    var yerror_1 = require_yerror();
    var previouslyVisitedConfigs = [];
    function checkForCircularExtends(cfgPath) {
      if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
        throw new yerror_1.YError(`Circular extended configurations: '${cfgPath}'.`);
      }
    }
    function getPathToDefaultConfig(cwd, pathToExtend) {
      return path.resolve(cwd, pathToExtend);
    }
    function mergeDeep(config1, config2) {
      const target = {};
      function isObject(obj) {
        return obj && typeof obj === "object" && !Array.isArray(obj);
      }
      Object.assign(target, config1);
      for (const key of Object.keys(config2)) {
        if (isObject(config2[key]) && isObject(target[key])) {
          target[key] = mergeDeep(config1[key], config2[key]);
        } else {
          target[key] = config2[key];
        }
      }
      return target;
    }
    function applyExtends(config, cwd, mergeExtends = false) {
      let defaultConfig = {};
      if (Object.prototype.hasOwnProperty.call(config, "extends")) {
        if (typeof config.extends !== "string")
          return defaultConfig;
        const isPath = /\.json|\..*rc$/.test(config.extends);
        let pathToDefault = null;
        if (!isPath) {
          try {
            pathToDefault = require.resolve(config.extends);
          } catch (err) {
          }
        } else {
          pathToDefault = getPathToDefaultConfig(cwd, config.extends);
        }
        if (!pathToDefault && !isPath)
          return config;
        if (!pathToDefault)
          throw new yerror_1.YError(`Unable to find extended config '${config.extends}' in '${cwd}'.`);
        checkForCircularExtends(pathToDefault);
        previouslyVisitedConfigs.push(pathToDefault);
        defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, "utf8")) : require(config.extends);
        delete config.extends;
        defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault), mergeExtends);
      }
      previouslyVisitedConfigs = [];
      return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
    }
    exports.applyExtends = applyExtends;
  }
});

// node_modules/yargs/build/lib/process-argv.js
var require_process_argv = __commonJS({
  "node_modules/yargs/build/lib/process-argv.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getProcessArgvBin = exports.getProcessArgvWithoutBin = void 0;
    function getProcessArgvBinIndex() {
      if (isBundledElectronApp())
        return 0;
      return 1;
    }
    function isBundledElectronApp() {
      return isElectronApp() && !process.defaultApp;
    }
    function isElectronApp() {
      return !!process.versions.electron;
    }
    function getProcessArgvWithoutBin() {
      return process.argv.slice(getProcessArgvBinIndex() + 1);
    }
    exports.getProcessArgvWithoutBin = getProcessArgvWithoutBin;
    function getProcessArgvBin() {
      return process.argv[getProcessArgvBinIndex()];
    }
    exports.getProcessArgvBin = getProcessArgvBin;
  }
});

// node_modules/y18n/index.js
var require_y18n = __commonJS({
  "node_modules/y18n/index.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var util = require("util");
    function Y18N(opts) {
      opts = opts || {};
      this.directory = opts.directory || "./locales";
      this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
      this.locale = opts.locale || "en";
      this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
      this.cache = /* @__PURE__ */ Object.create(null);
      this.writeQueue = [];
    }
    Y18N.prototype.__ = function() {
      if (typeof arguments[0] !== "string") {
        return this._taggedLiteral.apply(this, arguments);
      }
      var args2 = Array.prototype.slice.call(arguments);
      var str = args2.shift();
      var cb = function() {
      };
      if (typeof args2[args2.length - 1] === "function")
        cb = args2.pop();
      cb = cb || function() {
      };
      if (!this.cache[this.locale])
        this._readLocaleFile();
      if (!this.cache[this.locale][str] && this.updateFiles) {
        this.cache[this.locale][str] = str;
        this._enqueueWrite([this.directory, this.locale, cb]);
      } else {
        cb();
      }
      return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args2));
    };
    Y18N.prototype._taggedLiteral = function(parts) {
      var args2 = arguments;
      var str = "";
      parts.forEach(function(part, i) {
        var arg = args2[i + 1];
        str += part;
        if (typeof arg !== "undefined") {
          str += "%s";
        }
      });
      return this.__.apply(null, [str].concat([].slice.call(arguments, 1)));
    };
    Y18N.prototype._enqueueWrite = function(work) {
      this.writeQueue.push(work);
      if (this.writeQueue.length === 1)
        this._processWriteQueue();
    };
    Y18N.prototype._processWriteQueue = function() {
      var _this = this;
      var work = this.writeQueue[0];
      var directory = work[0];
      var locale = work[1];
      var cb = work[2];
      var languageFile = this._resolveLocaleFile(directory, locale);
      var serializedLocale = JSON.stringify(this.cache[locale], null, 2);
      fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
        _this.writeQueue.shift();
        if (_this.writeQueue.length > 0)
          _this._processWriteQueue();
        cb(err);
      });
    };
    Y18N.prototype._readLocaleFile = function() {
      var localeLookup = {};
      var languageFile = this._resolveLocaleFile(this.directory, this.locale);
      try {
        localeLookup = JSON.parse(fs.readFileSync(languageFile, "utf-8"));
      } catch (err) {
        if (err instanceof SyntaxError) {
          err.message = "syntax error in " + languageFile;
        }
        if (err.code === "ENOENT")
          localeLookup = {};
        else
          throw err;
      }
      this.cache[this.locale] = localeLookup;
    };
    Y18N.prototype._resolveLocaleFile = function(directory, locale) {
      var file = path.resolve(directory, "./", locale + ".json");
      if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
        var languageFile = path.resolve(directory, "./", locale.split("_")[0] + ".json");
        if (this._fileExistsSync(languageFile))
          file = languageFile;
      }
      return file;
    };
    Y18N.prototype._fileExistsSync = function(file) {
      try {
        return fs.statSync(file).isFile();
      } catch (err) {
        return false;
      }
    };
    Y18N.prototype.__n = function() {
      var args2 = Array.prototype.slice.call(arguments);
      var singular = args2.shift();
      var plural = args2.shift();
      var quantity = args2.shift();
      var cb = function() {
      };
      if (typeof args2[args2.length - 1] === "function")
        cb = args2.pop();
      if (!this.cache[this.locale])
        this._readLocaleFile();
      var str = quantity === 1 ? singular : plural;
      if (this.cache[this.locale][singular]) {
        str = this.cache[this.locale][singular][quantity === 1 ? "one" : "other"];
      }
      if (!this.cache[this.locale][singular] && this.updateFiles) {
        this.cache[this.locale][singular] = {
          one: singular,
          other: plural
        };
        this._enqueueWrite([this.directory, this.locale, cb]);
      } else {
        cb();
      }
      var values = [str];
      if (~str.indexOf("%d"))
        values.push(quantity);
      return util.format.apply(util, values.concat(args2));
    };
    Y18N.prototype.setLocale = function(locale) {
      this.locale = locale;
    };
    Y18N.prototype.getLocale = function() {
      return this.locale;
    };
    Y18N.prototype.updateLocale = function(obj) {
      if (!this.cache[this.locale])
        this._readLocaleFile();
      for (var key in obj) {
        this.cache[this.locale][key] = obj[key];
      }
    };
    module2.exports = function(opts) {
      var y18n = new Y18N(opts);
      for (var key in y18n) {
        if (typeof y18n[key] === "function") {
          y18n[key] = y18n[key].bind(y18n);
        }
      }
      return y18n;
    };
  }
});

// node_modules/p-try/index.js
var require_p_try = __commonJS({
  "node_modules/p-try/index.js"(exports, module2) {
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve4) => {
      resolve4(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});

// node_modules/p-locate/node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/p-locate/node_modules/p-limit/index.js"(exports, module2) {
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve4, ...args2) => {
        activeCount++;
        const result = pTry(fn, ...args2);
        resolve4(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve4, ...args2) => {
        if (activeCount < concurrency) {
          run(fn, resolve4, ...args2);
        } else {
          queue.push(run.bind(null, fn, resolve4, ...args2));
        }
      };
      const generator = (fn, ...args2) => new Promise((resolve4) => enqueue(fn, resolve4, ...args2));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});

// node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "node_modules/p-locate/index.js"(exports, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options) => {
      options = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options
      };
      const limit = pLimit(options.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error) {
        if (error instanceof EndError) {
          return error.value;
        }
        throw error;
      }
    };
    module2.exports = pLocate;
    module2.exports.default = pLocate;
  }
});

// node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "node_modules/locate-path/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var fs = require("fs");
    var { promisify } = require("util");
    var pLocate = require_p_locate();
    var fsStat = promisify(fs.stat);
    var fsLStat = promisify(fs.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({ type }) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat) => type === void 0 || stat[typeMappings[type]]();
    module2.exports = async (paths, options) => {
      options = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat = await statFn(path.resolve(options.cwd, path_));
          return matchType(options.type, stat);
        } catch (_) {
          return false;
        }
      }, options);
    };
    module2.exports.sync = (paths, options) => {
      options = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;
      for (const path_ of paths) {
        try {
          const stat = statFn(path.resolve(options.cwd, path_));
          if (matchType(options.type, stat)) {
            return path_;
          }
        } catch (_) {
        }
      }
    };
  }
});

// node_modules/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/path-exists/index.js"(exports, module2) {
    "use strict";
    var fs = require("fs");
    var { promisify } = require("util");
    var pAccess = promisify(fs.access);
    module2.exports = async (path) => {
      try {
        await pAccess(path);
        return true;
      } catch (_) {
        return false;
      }
    };
    module2.exports.sync = (path) => {
      try {
        fs.accessSync(path);
        return true;
      } catch (_) {
        return false;
      }
    };
  }
});

// node_modules/find-up/index.js
var require_find_up = __commonJS({
  "node_modules/find-up/index.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var locatePath = require_locate_path();
    var pathExists = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options = {}) => {
      let directory = path.resolve(options.cwd || "");
      const { root: root2 } = path.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({ ...options, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path.resolve(directory, foundPath);
        }
        if (directory === root2) {
          return;
        }
        directory = path.dirname(directory);
      }
    };
    module2.exports.sync = (name, options = {}) => {
      let directory = path.resolve(options.cwd || "");
      const { root: root2 } = path.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({ ...options, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path.resolve(directory, foundPath);
        }
        if (directory === root2) {
          return;
        }
        directory = path.dirname(directory);
      }
    };
    module2.exports.exists = pathExists;
    module2.exports.sync.exists = pathExists.sync;
    module2.exports.stop = stop;
  }
});

// node_modules/require-main-filename/index.js
var require_require_main_filename = __commonJS({
  "node_modules/require-main-filename/index.js"(exports, module2) {
    module2.exports = function(_require) {
      _require = _require || require;
      var main = _require.main;
      if (main && isIISNode(main))
        return handleIISNode(main);
      else
        return main ? main.filename : process.cwd();
    };
    function isIISNode(main) {
      return /\\iisnode\\/.test(main.filename);
    }
    function handleIISNode(main) {
      if (!main.children.length) {
        return main.filename;
      } else {
        return main.children[0].filename;
      }
    }
  }
});

// node_modules/get-caller-file/index.js
var require_get_caller_file = __commonJS({
  "node_modules/get-caller-file/index.js"(exports, module2) {
    "use strict";
    module2.exports = function getCallerFile(position) {
      if (position === void 0) {
        position = 2;
      }
      if (position >= Error.stackTraceLimit) {
        throw new TypeError("getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `" + position + "` and Error.stackTraceLimit was: `" + Error.stackTraceLimit + "`");
      }
      var oldPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = oldPrepareStackTrace;
      if (stack !== null && typeof stack === "object") {
        return stack[position] ? stack[position].getFileName() : void 0;
      }
    };
  }
});

// node_modules/yargs/build/lib/yargs.js
var require_yargs = __commonJS({
  "node_modules/yargs/build/lib/yargs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isYargsInstance = exports.rebase = exports.Yargs = void 0;
    var command_1 = require_command();
    var common_types_1 = require_common_types();
    var yerror_1 = require_yerror();
    var usage_1 = require_usage();
    var argsert_1 = require_argsert();
    var fs = require("fs");
    var completion_1 = require_completion();
    var path = require("path");
    var validation_1 = require_validation();
    var obj_filter_1 = require_obj_filter();
    var apply_extends_1 = require_apply_extends();
    var middleware_1 = require_middleware();
    var processArgv = require_process_argv();
    var is_promise_1 = require_is_promise();
    var Parser = require_yargs_parser();
    var y18nFactory = require_y18n();
    var setBlocking = require_set_blocking();
    var findUp = require_find_up();
    var requireMainFilename = require_require_main_filename();
    function Yargs(processArgs = [], cwd = process.cwd(), parentRequire = require) {
      const self = {};
      let command2;
      let completion = null;
      let groups = {};
      const globalMiddleware = [];
      let output = "";
      const preservedGroups = {};
      let usage;
      let validation;
      let handlerFinishCommand = null;
      const y18n = y18nFactory({
        directory: path.resolve(__dirname, "../../locales"),
        updateFiles: false
      });
      self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);
      self.scriptName = function(scriptName) {
        self.customScriptName = true;
        self.$0 = scriptName;
        return self;
      };
      let default$0;
      if (/\b(node|iojs|electron)(\.exe)?$/.test(process.argv[0])) {
        default$0 = process.argv.slice(1, 2);
      } else {
        default$0 = process.argv.slice(0, 1);
      }
      self.$0 = default$0.map((x) => {
        const b = rebase(cwd, x);
        return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
      }).join(" ").trim();
      if (process.env._ !== void 0 && processArgv.getProcessArgvBin() === process.env._) {
        self.$0 = process.env._.replace(`${path.dirname(process.execPath)}/`, "");
      }
      const context = { resets: -1, commands: [], fullCommands: [], files: [] };
      self.getContext = () => context;
      let options;
      self.resetOptions = self.reset = function resetOptions(aliases = {}) {
        context.resets++;
        options = options || {};
        const tmpOptions = {};
        tmpOptions.local = options.local ? options.local : [];
        tmpOptions.configObjects = options.configObjects ? options.configObjects : [];
        const localLookup = {};
        tmpOptions.local.forEach((l) => {
          localLookup[l] = true;
          (aliases[l] || []).forEach((a) => {
            localLookup[a] = true;
          });
        });
        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {
          const keys = groups[groupName].filter((key) => !(key in localLookup));
          if (keys.length > 0) {
            acc[groupName] = keys;
          }
          return acc;
        }, {}));
        groups = {};
        const arrayOptions = [
          "array",
          "boolean",
          "string",
          "skipValidation",
          "count",
          "normalize",
          "number",
          "hiddenOptions"
        ];
        const objectOptions = [
          "narg",
          "key",
          "alias",
          "default",
          "defaultDescription",
          "config",
          "choices",
          "demandedOptions",
          "demandedCommands",
          "coerce",
          "deprecatedOptions"
        ];
        arrayOptions.forEach((k) => {
          tmpOptions[k] = (options[k] || []).filter((k2) => !localLookup[k2]);
        });
        objectOptions.forEach((k) => {
          tmpOptions[k] = obj_filter_1.objFilter(options[k], (k2) => !localLookup[k2]);
        });
        tmpOptions.envPrefix = options.envPrefix;
        options = tmpOptions;
        usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);
        validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);
        command2 = command2 ? command2.reset() : command_1.command(self, usage, validation, globalMiddleware);
        if (!completion)
          completion = completion_1.completion(self, usage, command2);
        completionCommand = null;
        output = "";
        exitError = null;
        hasOutput = false;
        self.parsed = false;
        return self;
      };
      self.resetOptions();
      const frozens = [];
      function freeze() {
        frozens.push({
          options,
          configObjects: options.configObjects.slice(0),
          exitProcess,
          groups,
          strict,
          strictCommands,
          completionCommand,
          output,
          exitError,
          hasOutput,
          parsed: self.parsed,
          parseFn,
          parseContext,
          handlerFinishCommand
        });
        usage.freeze();
        validation.freeze();
        command2.freeze();
      }
      function unfreeze() {
        const frozen = frozens.pop();
        common_types_1.assertNotStrictEqual(frozen, void 0);
        let configObjects;
        ({
          options,
          configObjects,
          exitProcess,
          groups,
          output,
          exitError,
          hasOutput,
          parsed: self.parsed,
          strict,
          strictCommands,
          completionCommand,
          parseFn,
          parseContext,
          handlerFinishCommand
        } = frozen);
        options.configObjects = configObjects;
        usage.unfreeze();
        validation.unfreeze();
        command2.unfreeze();
      }
      self.boolean = function(keys) {
        argsert_1.argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("boolean", keys);
        return self;
      };
      self.array = function(keys) {
        argsert_1.argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("array", keys);
        return self;
      };
      self.number = function(keys) {
        argsert_1.argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("number", keys);
        return self;
      };
      self.normalize = function(keys) {
        argsert_1.argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("normalize", keys);
        return self;
      };
      self.count = function(keys) {
        argsert_1.argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("count", keys);
        return self;
      };
      self.string = function(keys) {
        argsert_1.argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("string", keys);
        return self;
      };
      self.requiresArg = function(keys) {
        argsert_1.argsert("<array|string|object> [number]", [keys], arguments.length);
        if (typeof keys === "string" && options.narg[keys]) {
          return self;
        } else {
          populateParserHintSingleValueDictionary(self.requiresArg, "narg", keys, NaN);
        }
        return self;
      };
      self.skipValidation = function(keys) {
        argsert_1.argsert("<array|string>", [keys], arguments.length);
        populateParserHintArray("skipValidation", keys);
        return self;
      };
      function populateParserHintArray(type, keys) {
        keys = [].concat(keys);
        keys.forEach((key) => {
          key = sanitizeKey(key);
          options[type].push(key);
        });
      }
      self.nargs = function(key, value) {
        argsert_1.argsert("<string|object|array> [number]", [key, value], arguments.length);
        populateParserHintSingleValueDictionary(self.nargs, "narg", key, value);
        return self;
      };
      self.choices = function(key, value) {
        argsert_1.argsert("<object|string|array> [string|array]", [key, value], arguments.length);
        populateParserHintArrayDictionary(self.choices, "choices", key, value);
        return self;
      };
      self.alias = function(key, value) {
        argsert_1.argsert("<object|string|array> [string|array]", [key, value], arguments.length);
        populateParserHintArrayDictionary(self.alias, "alias", key, value);
        return self;
      };
      self.default = self.defaults = function(key, value, defaultDescription) {
        argsert_1.argsert("<object|string|array> [*] [string]", [key, value, defaultDescription], arguments.length);
        if (defaultDescription) {
          common_types_1.assertSingleKey(key);
          options.defaultDescription[key] = defaultDescription;
        }
        if (typeof value === "function") {
          common_types_1.assertSingleKey(key);
          if (!options.defaultDescription[key])
            options.defaultDescription[key] = usage.functionDescription(value);
          value = value.call();
        }
        populateParserHintSingleValueDictionary(self.default, "default", key, value);
        return self;
      };
      self.describe = function(key, desc) {
        argsert_1.argsert("<object|string|array> [string]", [key, desc], arguments.length);
        setKey(key, true);
        usage.describe(key, desc);
        return self;
      };
      function setKey(key, set) {
        populateParserHintSingleValueDictionary(setKey, "key", key, set);
        return self;
      }
      function demandOption(keys, msg) {
        argsert_1.argsert("<object|string|array> [string]", [keys, msg], arguments.length);
        populateParserHintSingleValueDictionary(self.demandOption, "demandedOptions", keys, msg);
        return self;
      }
      self.demandOption = demandOption;
      self.coerce = function(keys, value) {
        argsert_1.argsert("<object|string|array> [function]", [keys, value], arguments.length);
        populateParserHintSingleValueDictionary(self.coerce, "coerce", keys, value);
        return self;
      };
      function populateParserHintSingleValueDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type2, key2, value2) => {
          options[type2][key2] = value2;
        });
      }
      function populateParserHintArrayDictionary(builder, type, key, value) {
        populateParserHintDictionary(builder, type, key, value, (type2, key2, value2) => {
          options[type2][key2] = (options[type2][key2] || []).concat(value2);
        });
      }
      function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {
        if (Array.isArray(key)) {
          key.forEach((k) => {
            builder(k, value);
          });
        } else if (((key2) => typeof key2 === "object")(key)) {
          for (const k of common_types_1.objectKeys(key)) {
            builder(k, key[k]);
          }
        } else {
          singleKeyHandler(type, sanitizeKey(key), value);
        }
      }
      function sanitizeKey(key) {
        if (key === "__proto__")
          return "___proto___";
        return key;
      }
      function deleteFromParserHintObject(optionKey) {
        common_types_1.objectKeys(options).forEach((hintKey) => {
          if (((key) => key === "configObjects")(hintKey))
            return;
          const hint = options[hintKey];
          if (Array.isArray(hint)) {
            if (~hint.indexOf(optionKey))
              hint.splice(hint.indexOf(optionKey), 1);
          } else if (typeof hint === "object") {
            delete hint[optionKey];
          }
        });
        delete usage.getDescriptions()[optionKey];
      }
      self.config = function config(key = "config", msg, parseFn2) {
        argsert_1.argsert("[object|string] [string|function] [function]", [key, msg, parseFn2], arguments.length);
        if (typeof key === "object" && !Array.isArray(key)) {
          key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()["deep-merge-config"]);
          options.configObjects = (options.configObjects || []).concat(key);
          return self;
        }
        if (typeof msg === "function") {
          parseFn2 = msg;
          msg = void 0;
        }
        self.describe(key, msg || usage.deferY18nLookup("Path to JSON config file"));
        (Array.isArray(key) ? key : [key]).forEach((k) => {
          options.config[k] = parseFn2 || true;
        });
        return self;
      };
      self.example = function(cmd, description) {
        argsert_1.argsert("<string|array> [string]", [cmd, description], arguments.length);
        if (Array.isArray(cmd)) {
          cmd.forEach((exampleParams) => self.example(...exampleParams));
        } else {
          usage.example(cmd, description);
        }
        return self;
      };
      self.command = function(cmd, description, builder, handler, middlewares, deprecated) {
        argsert_1.argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [cmd, description, builder, handler, middlewares, deprecated], arguments.length);
        command2.addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return self;
      };
      self.commandDir = function(dir, opts) {
        argsert_1.argsert("<string> [object]", [dir, opts], arguments.length);
        const req = parentRequire || require;
        command2.addDirectory(dir, self.getContext(), req, require_get_caller_file()(), opts);
        return self;
      };
      self.demand = self.required = self.require = function demand(keys, max, msg) {
        if (Array.isArray(max)) {
          max.forEach((key) => {
            common_types_1.assertNotStrictEqual(msg, true);
            demandOption(key, msg);
          });
          max = Infinity;
        } else if (typeof max !== "number") {
          msg = max;
          max = Infinity;
        }
        if (typeof keys === "number") {
          common_types_1.assertNotStrictEqual(msg, true);
          self.demandCommand(keys, max, msg, msg);
        } else if (Array.isArray(keys)) {
          keys.forEach((key) => {
            common_types_1.assertNotStrictEqual(msg, true);
            demandOption(key, msg);
          });
        } else {
          if (typeof msg === "string") {
            demandOption(keys, msg);
          } else if (msg === true || typeof msg === "undefined") {
            demandOption(keys);
          }
        }
        return self;
      };
      self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert_1.argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [min, max, minMsg, maxMsg], arguments.length);
        if (typeof max !== "number") {
          minMsg = max;
          max = Infinity;
        }
        self.global("_", false);
        options.demandedCommands._ = {
          min,
          max,
          minMsg,
          maxMsg
        };
        return self;
      };
      self.getDemandedOptions = () => {
        argsert_1.argsert([], 0);
        return options.demandedOptions;
      };
      self.getDemandedCommands = () => {
        argsert_1.argsert([], 0);
        return options.demandedCommands;
      };
      self.deprecateOption = function deprecateOption(option, message) {
        argsert_1.argsert("<string> [string|boolean]", [option, message], arguments.length);
        options.deprecatedOptions[option] = message;
        return self;
      };
      self.getDeprecatedOptions = () => {
        argsert_1.argsert([], 0);
        return options.deprecatedOptions;
      };
      self.implies = function(key, value) {
        argsert_1.argsert("<string|object> [number|string|array]", [key, value], arguments.length);
        validation.implies(key, value);
        return self;
      };
      self.conflicts = function(key1, key2) {
        argsert_1.argsert("<string|object> [string|array]", [key1, key2], arguments.length);
        validation.conflicts(key1, key2);
        return self;
      };
      self.usage = function(msg, description, builder, handler) {
        argsert_1.argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [msg, description, builder, handler], arguments.length);
        if (description !== void 0) {
          common_types_1.assertNotStrictEqual(msg, null);
          if ((msg || "").match(/^\$0( |$)/)) {
            return self.command(msg, description, builder, handler);
          } else {
            throw new yerror_1.YError(".usage() description must start with $0 if being used as alias for .command()");
          }
        } else {
          usage.usage(msg);
          return self;
        }
      };
      self.epilogue = self.epilog = function(msg) {
        argsert_1.argsert("<string>", [msg], arguments.length);
        usage.epilog(msg);
        return self;
      };
      self.fail = function(f) {
        argsert_1.argsert("<function>", [f], arguments.length);
        usage.failFn(f);
        return self;
      };
      self.onFinishCommand = function(f) {
        argsert_1.argsert("<function>", [f], arguments.length);
        handlerFinishCommand = f;
        return self;
      };
      self.getHandlerFinishCommand = () => handlerFinishCommand;
      self.check = function(f, _global) {
        argsert_1.argsert("<function> [boolean]", [f, _global], arguments.length);
        validation.check(f, _global !== false);
        return self;
      };
      self.global = function global(globals, global) {
        argsert_1.argsert("<string|array> [boolean]", [globals, global], arguments.length);
        globals = [].concat(globals);
        if (global !== false) {
          options.local = options.local.filter((l) => globals.indexOf(l) === -1);
        } else {
          globals.forEach((g) => {
            if (options.local.indexOf(g) === -1)
              options.local.push(g);
          });
        }
        return self;
      };
      self.pkgConf = function pkgConf(key, rootPath) {
        argsert_1.argsert("<string> [string]", [key, rootPath], arguments.length);
        let conf = null;
        const obj = pkgUp(rootPath || cwd);
        if (obj[key] && typeof obj[key] === "object") {
          conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()["deep-merge-config"]);
          options.configObjects = (options.configObjects || []).concat(conf);
        }
        return self;
      };
      const pkgs = {};
      function pkgUp(rootPath) {
        const npath = rootPath || "*";
        if (pkgs[npath])
          return pkgs[npath];
        let obj = {};
        try {
          let startDir = rootPath || requireMainFilename(parentRequire);
          if (!rootPath && path.extname(startDir)) {
            startDir = path.dirname(startDir);
          }
          const pkgJsonPath = findUp.sync("package.json", {
            cwd: startDir
          });
          common_types_1.assertNotStrictEqual(pkgJsonPath, void 0);
          obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());
        } catch (noop) {
        }
        pkgs[npath] = obj || {};
        return pkgs[npath];
      }
      let parseFn = null;
      let parseContext = null;
      self.parse = function parse(args2, shortCircuit, _parseFn) {
        argsert_1.argsert("[string|array] [function|boolean|object] [function]", [args2, shortCircuit, _parseFn], arguments.length);
        freeze();
        if (typeof args2 === "undefined") {
          const argv = self._parseArgs(processArgs);
          const tmpParsed = self.parsed;
          unfreeze();
          self.parsed = tmpParsed;
          return argv;
        }
        if (typeof shortCircuit === "object") {
          parseContext = shortCircuit;
          shortCircuit = _parseFn;
        }
        if (typeof shortCircuit === "function") {
          parseFn = shortCircuit;
          shortCircuit = false;
        }
        if (!shortCircuit)
          processArgs = args2;
        if (parseFn)
          exitProcess = false;
        const parsed = self._parseArgs(args2, !!shortCircuit);
        completion.setParsed(self.parsed);
        if (parseFn)
          parseFn(exitError, parsed, output);
        unfreeze();
        return parsed;
      };
      self._getParseContext = () => parseContext || {};
      self._hasParseCallback = () => !!parseFn;
      self.option = self.options = function option(key, opt) {
        argsert_1.argsert("<string|object> [object]", [key, opt], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            self.options(k, key[k]);
          });
        } else {
          if (typeof opt !== "object") {
            opt = {};
          }
          options.key[key] = true;
          if (opt.alias)
            self.alias(key, opt.alias);
          const deprecate = opt.deprecate || opt.deprecated;
          if (deprecate) {
            self.deprecateOption(key, deprecate);
          }
          const demand = opt.demand || opt.required || opt.require;
          if (demand) {
            self.demand(key, demand);
          }
          if (opt.demandOption) {
            self.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : void 0);
          }
          if (opt.conflicts) {
            self.conflicts(key, opt.conflicts);
          }
          if ("default" in opt) {
            self.default(key, opt.default);
          }
          if (opt.implies !== void 0) {
            self.implies(key, opt.implies);
          }
          if (opt.nargs !== void 0) {
            self.nargs(key, opt.nargs);
          }
          if (opt.config) {
            self.config(key, opt.configParser);
          }
          if (opt.normalize) {
            self.normalize(key);
          }
          if (opt.choices) {
            self.choices(key, opt.choices);
          }
          if (opt.coerce) {
            self.coerce(key, opt.coerce);
          }
          if (opt.group) {
            self.group(key, opt.group);
          }
          if (opt.boolean || opt.type === "boolean") {
            self.boolean(key);
            if (opt.alias)
              self.boolean(opt.alias);
          }
          if (opt.array || opt.type === "array") {
            self.array(key);
            if (opt.alias)
              self.array(opt.alias);
          }
          if (opt.number || opt.type === "number") {
            self.number(key);
            if (opt.alias)
              self.number(opt.alias);
          }
          if (opt.string || opt.type === "string") {
            self.string(key);
            if (opt.alias)
              self.string(opt.alias);
          }
          if (opt.count || opt.type === "count") {
            self.count(key);
          }
          if (typeof opt.global === "boolean") {
            self.global(key, opt.global);
          }
          if (opt.defaultDescription) {
            options.defaultDescription[key] = opt.defaultDescription;
          }
          if (opt.skipValidation) {
            self.skipValidation(key);
          }
          const desc = opt.describe || opt.description || opt.desc;
          self.describe(key, desc);
          if (opt.hidden) {
            self.hide(key);
          }
          if (opt.requiresArg) {
            self.requiresArg(key);
          }
        }
        return self;
      };
      self.getOptions = () => options;
      self.positional = function(key, opts) {
        argsert_1.argsert("<string> <object>", [key, opts], arguments.length);
        if (context.resets === 0) {
          throw new yerror_1.YError(".positional() can only be called in a command's builder function");
        }
        const supportedOpts = [
          "default",
          "defaultDescription",
          "implies",
          "normalize",
          "choices",
          "conflicts",
          "coerce",
          "type",
          "describe",
          "desc",
          "description",
          "alias"
        ];
        opts = obj_filter_1.objFilter(opts, (k, v) => {
          let accept = supportedOpts.indexOf(k) !== -1;
          if (k === "type" && ["string", "number", "boolean"].indexOf(v) === -1)
            accept = false;
          return accept;
        });
        const fullCommand = context.fullCommands[context.fullCommands.length - 1];
        const parseOptions = fullCommand ? command2.cmdToParseOptions(fullCommand) : {
          array: [],
          alias: {},
          default: {},
          demand: {}
        };
        common_types_1.objectKeys(parseOptions).forEach((pk) => {
          const parseOption = parseOptions[pk];
          if (Array.isArray(parseOption)) {
            if (parseOption.indexOf(key) !== -1)
              opts[pk] = true;
          } else {
            if (parseOption[key] && !(pk in opts))
              opts[pk] = parseOption[key];
          }
        });
        self.group(key, usage.getPositionalGroupName());
        return self.option(key, opts);
      };
      self.group = function group(opts, groupName) {
        argsert_1.argsert("<string|array> <string>", [opts, groupName], arguments.length);
        const existing = preservedGroups[groupName] || groups[groupName];
        if (preservedGroups[groupName]) {
          delete preservedGroups[groupName];
        }
        const seen = {};
        groups[groupName] = (existing || []).concat(opts).filter((key) => {
          if (seen[key])
            return false;
          return seen[key] = true;
        });
        return self;
      };
      self.getGroups = () => Object.assign({}, groups, preservedGroups);
      self.env = function(prefix) {
        argsert_1.argsert("[string|boolean]", [prefix], arguments.length);
        if (prefix === false)
          delete options.envPrefix;
        else
          options.envPrefix = prefix || "";
        return self;
      };
      self.wrap = function(cols) {
        argsert_1.argsert("<number|null|undefined>", [cols], arguments.length);
        usage.wrap(cols);
        return self;
      };
      let strict = false;
      self.strict = function(enabled) {
        argsert_1.argsert("[boolean]", [enabled], arguments.length);
        strict = enabled !== false;
        return self;
      };
      self.getStrict = () => strict;
      let strictCommands = false;
      self.strictCommands = function(enabled) {
        argsert_1.argsert("[boolean]", [enabled], arguments.length);
        strictCommands = enabled !== false;
        return self;
      };
      self.getStrictCommands = () => strictCommands;
      let parserConfig = {};
      self.parserConfiguration = function parserConfiguration(config) {
        argsert_1.argsert("<object>", [config], arguments.length);
        parserConfig = config;
        return self;
      };
      self.getParserConfiguration = () => parserConfig;
      self.showHelp = function(level) {
        argsert_1.argsert("[string|function]", [level], arguments.length);
        if (!self.parsed)
          self._parseArgs(processArgs);
        if (command2.hasDefaultCommand()) {
          context.resets++;
          command2.runDefaultBuilderOn(self);
        }
        usage.showHelp(level);
        return self;
      };
      let versionOpt = null;
      self.version = function version(opt, msg, ver) {
        const defaultVersionOpt = "version";
        argsert_1.argsert("[boolean|string] [string] [string]", [opt, msg, ver], arguments.length);
        if (versionOpt) {
          deleteFromParserHintObject(versionOpt);
          usage.version(void 0);
          versionOpt = null;
        }
        if (arguments.length === 0) {
          ver = guessVersion();
          opt = defaultVersionOpt;
        } else if (arguments.length === 1) {
          if (opt === false) {
            return self;
          }
          ver = opt;
          opt = defaultVersionOpt;
        } else if (arguments.length === 2) {
          ver = msg;
          msg = void 0;
        }
        versionOpt = typeof opt === "string" ? opt : defaultVersionOpt;
        msg = msg || usage.deferY18nLookup("Show version number");
        usage.version(ver || void 0);
        self.boolean(versionOpt);
        self.describe(versionOpt, msg);
        return self;
      };
      function guessVersion() {
        const obj = pkgUp();
        return obj.version || "unknown";
      }
      let helpOpt = null;
      self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {
        const defaultHelpOpt = "help";
        argsert_1.argsert("[string|boolean] [string]", [opt, msg], arguments.length);
        if (helpOpt) {
          deleteFromParserHintObject(helpOpt);
          helpOpt = null;
        }
        if (arguments.length === 1) {
          if (opt === false)
            return self;
        }
        helpOpt = typeof opt === "string" ? opt : defaultHelpOpt;
        self.boolean(helpOpt);
        self.describe(helpOpt, msg || usage.deferY18nLookup("Show help"));
        return self;
      };
      const defaultShowHiddenOpt = "show-hidden";
      options.showHiddenOpt = defaultShowHiddenOpt;
      self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {
        argsert_1.argsert("[string|boolean] [string]", [opt, msg], arguments.length);
        if (arguments.length === 1) {
          if (opt === false)
            return self;
        }
        const showHiddenOpt = typeof opt === "string" ? opt : defaultShowHiddenOpt;
        self.boolean(showHiddenOpt);
        self.describe(showHiddenOpt, msg || usage.deferY18nLookup("Show hidden options"));
        options.showHiddenOpt = showHiddenOpt;
        return self;
      };
      self.hide = function hide(key) {
        argsert_1.argsert("<string>", [key], arguments.length);
        options.hiddenOptions.push(key);
        return self;
      };
      self.showHelpOnFail = function showHelpOnFail(enabled, message) {
        argsert_1.argsert("[boolean|string] [string]", [enabled, message], arguments.length);
        usage.showHelpOnFail(enabled, message);
        return self;
      };
      var exitProcess = true;
      self.exitProcess = function(enabled = true) {
        argsert_1.argsert("[boolean]", [enabled], arguments.length);
        exitProcess = enabled;
        return self;
      };
      self.getExitProcess = () => exitProcess;
      var completionCommand = null;
      self.completion = function(cmd, desc, fn) {
        argsert_1.argsert("[string] [string|boolean|function] [function]", [cmd, desc, fn], arguments.length);
        if (typeof desc === "function") {
          fn = desc;
          desc = void 0;
        }
        completionCommand = cmd || completionCommand || "completion";
        if (!desc && desc !== false) {
          desc = "generate completion script";
        }
        self.command(completionCommand, desc);
        if (fn)
          completion.registerFunction(fn);
        return self;
      };
      self.showCompletionScript = function($0, cmd) {
        argsert_1.argsert("[string] [string]", [$0, cmd], arguments.length);
        $0 = $0 || self.$0;
        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || "completion"));
        return self;
      };
      self.getCompletion = function(args2, done) {
        argsert_1.argsert("<array> <function>", [args2, done], arguments.length);
        completion.getCompletion(args2, done);
      };
      self.locale = function(locale) {
        argsert_1.argsert("[string]", [locale], arguments.length);
        if (!locale) {
          guessLocale();
          return y18n.getLocale();
        }
        detectLocale = false;
        y18n.setLocale(locale);
        return self;
      };
      self.updateStrings = self.updateLocale = function(obj) {
        argsert_1.argsert("<object>", [obj], arguments.length);
        detectLocale = false;
        y18n.updateLocale(obj);
        return self;
      };
      let detectLocale = true;
      self.detectLocale = function(detect) {
        argsert_1.argsert("<boolean>", [detect], arguments.length);
        detectLocale = detect;
        return self;
      };
      self.getDetectLocale = () => detectLocale;
      var hasOutput = false;
      var exitError = null;
      self.exit = (code, err) => {
        hasOutput = true;
        exitError = err;
        if (exitProcess)
          process.exit(code);
      };
      const _logger = {
        log(...args2) {
          if (!self._hasParseCallback())
            console.log(...args2);
          hasOutput = true;
          if (output.length)
            output += "\n";
          output += args2.join(" ");
        },
        error(...args2) {
          if (!self._hasParseCallback())
            console.error(...args2);
          hasOutput = true;
          if (output.length)
            output += "\n";
          output += args2.join(" ");
        }
      };
      self._getLoggerInstance = () => _logger;
      self._hasOutput = () => hasOutput;
      self._setHasOutput = () => {
        hasOutput = true;
      };
      let recommendCommands;
      self.recommendCommands = function(recommend = true) {
        argsert_1.argsert("[boolean]", [recommend], arguments.length);
        recommendCommands = recommend;
        return self;
      };
      self.getUsageInstance = () => usage;
      self.getValidationInstance = () => validation;
      self.getCommandInstance = () => command2;
      self.terminalWidth = () => {
        argsert_1.argsert([], 0);
        return typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null;
      };
      Object.defineProperty(self, "argv", {
        get: () => self._parseArgs(processArgs),
        enumerable: true
      });
      self._parseArgs = function parseArgs(args2, shortCircuit, _calledFromCommand, commandIndex) {
        let skipValidation = !!_calledFromCommand;
        args2 = args2 || processArgs;
        options.__ = y18n.__;
        options.configuration = self.getParserConfiguration();
        const populateDoubleDash = !!options.configuration["populate--"];
        const config = Object.assign({}, options.configuration, {
          "populate--": true
        });
        const parsed = Parser.detailed(args2, Object.assign({}, options, {
          configuration: config
        }));
        let argv = parsed.argv;
        if (parseContext)
          argv = Object.assign({}, argv, parseContext);
        const aliases = parsed.aliases;
        argv.$0 = self.$0;
        self.parsed = parsed;
        try {
          guessLocale();
          if (shortCircuit) {
            return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);
          }
          if (helpOpt) {
            const helpCmds = [helpOpt].concat(aliases[helpOpt] || []).filter((k) => k.length > 1);
            if (~helpCmds.indexOf(argv._[argv._.length - 1])) {
              argv._.pop();
              argv[helpOpt] = true;
            }
          }
          const handlerKeys = command2.getCommands();
          const requestCompletions = completion.completionKey in argv;
          const skipRecommendation = argv[helpOpt] || requestCompletions;
          const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== "$0");
          if (argv._.length) {
            if (handlerKeys.length) {
              let firstUnknownCommand;
              for (let i = commandIndex || 0, cmd; argv._[i] !== void 0; i++) {
                cmd = String(argv._[i]);
                if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {
                  const innerArgv = command2.runCommand(cmd, self, parsed, i + 1);
                  return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
                } else if (!firstUnknownCommand && cmd !== completionCommand) {
                  firstUnknownCommand = cmd;
                  break;
                }
              }
              if (command2.hasDefaultCommand() && !skipDefaultCommand) {
                const innerArgv = command2.runCommand(null, self, parsed);
                return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
              }
              if (recommendCommands && firstUnknownCommand && !skipRecommendation) {
                validation.recommendCommands(firstUnknownCommand, handlerKeys);
              }
            }
            if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {
              if (exitProcess)
                setBlocking(true);
              self.showCompletionScript();
              self.exit(0);
            }
          } else if (command2.hasDefaultCommand() && !skipDefaultCommand) {
            const innerArgv = command2.runCommand(null, self, parsed);
            return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);
          }
          if (requestCompletions) {
            if (exitProcess)
              setBlocking(true);
            args2 = [].concat(args2);
            const completionArgs = args2.slice(args2.indexOf(`--${completion.completionKey}`) + 1);
            completion.getCompletion(completionArgs, (completions) => {
              ;
              (completions || []).forEach((completion2) => {
                _logger.log(completion2);
              });
              self.exit(0);
            });
            return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);
          }
          if (!hasOutput) {
            Object.keys(argv).forEach((key) => {
              if (key === helpOpt && argv[key]) {
                if (exitProcess)
                  setBlocking(true);
                skipValidation = true;
                self.showHelp("log");
                self.exit(0);
              } else if (key === versionOpt && argv[key]) {
                if (exitProcess)
                  setBlocking(true);
                skipValidation = true;
                usage.showVersion();
                self.exit(0);
              }
            });
          }
          if (!skipValidation && options.skipValidation.length > 0) {
            skipValidation = Object.keys(argv).some((key) => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);
          }
          if (!skipValidation) {
            if (parsed.error)
              throw new yerror_1.YError(parsed.error.message);
            if (!requestCompletions) {
              self._runValidation(argv, aliases, {}, parsed.error);
            }
          }
        } catch (err) {
          if (err instanceof yerror_1.YError)
            usage.fail(err.message, err);
          else
            throw err;
        }
        return populateDoubleDash || _calledFromCommand ? argv : self._copyDoubleDash(argv);
      };
      self._copyDoubleDash = function(argv) {
        if (is_promise_1.isPromise(argv) || !argv._ || !argv["--"])
          return argv;
        argv._.push.apply(argv._, argv["--"]);
        try {
          delete argv["--"];
        } catch (_err) {
        }
        return argv;
      };
      self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {
        if (parseErrors)
          throw new yerror_1.YError(parseErrors.message);
        validation.nonOptionCount(argv);
        validation.requiredArguments(argv);
        let failedStrictCommands = false;
        if (strictCommands) {
          failedStrictCommands = validation.unknownCommands(argv);
        }
        if (strict && !failedStrictCommands) {
          validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);
        }
        validation.customChecks(argv, aliases);
        validation.limitedChoices(argv);
        validation.implications(argv);
        validation.conflicting(argv);
      };
      function guessLocale() {
        if (!detectLocale)
          return;
        const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || "en_US";
        self.locale(locale.replace(/[.:].*/, ""));
      }
      self.help();
      self.version();
      return self;
    }
    exports.Yargs = Yargs;
    function rebase(base, dir) {
      return path.relative(base, dir);
    }
    exports.rebase = rebase;
    function isYargsInstance(y) {
      return !!y && typeof y._parseArgs === "function";
    }
    exports.isYargsInstance = isYargsInstance;
  }
});

// node_modules/yargs/yargs.js
var require_yargs2 = __commonJS({
  "node_modules/yargs/yargs.js"(exports, module2) {
    "use strict";
    async function requiresNode8OrGreater() {
    }
    requiresNode8OrGreater();
    var { Yargs, rebase } = require_yargs();
    var Parser = require_yargs_parser();
    exports = module2.exports = Yargs;
    exports.rebase = rebase;
    exports.Parser = Parser;
  }
});

// node_modules/yargs/index.js
var require_yargs3 = __commonJS({
  "node_modules/yargs/index.js"(exports, module2) {
    "use strict";
    var yargs2 = require_yargs2();
    var processArgv = require_process_argv();
    Argv(processArgv.getProcessArgvWithoutBin());
    module2.exports = Argv;
    function Argv(processArgs, cwd) {
      const argv = yargs2(processArgs, cwd, require);
      singletonify(argv);
      return argv;
    }
    function singletonify(inst) {
      Object.keys(inst).forEach((key) => {
        if (key === "argv") {
          Argv.__defineGetter__(key, inst.__lookupGetter__(key));
        } else if (typeof inst[key] === "function") {
          Argv[key] = inst[key].bind(inst);
        } else {
          Argv.__defineGetter__("$0", () => {
            return inst.$0;
          });
          Argv.__defineGetter__("parsed", () => {
            return inst.parsed;
          });
        }
      });
    }
  }
});

// src/helpers/comments.ts
function isUnique(value, index, self) {
  return self.indexOf(value) === index;
}
function getAllJsDocs(checker, decls) {
  const allDocs = decls.map((decl) => getJsDocs(checker, decl));
  return {
    comment: allDocs.map((m) => m.comment).reduce((p, c) => [...p, ...c], []).filter(isUnique),
    tags: allDocs.map((m) => m.tags).reduce((p, c) => [...p, ...c], []).filter(isUnique)
  };
}
function getJsDocs(checker, node) {
  if ((0, import_typescript.isMethodDeclaration)(node) || (0, import_typescript.isMethodSignature)(node) || (0, import_typescript.isCallSignatureDeclaration)(node)) {
    const sign = checker.getSignatureFromDeclaration(node);
    if (sign) {
      return {
        comment: sign.getDocumentationComment(checker),
        tags: sign.getJsDocTags()
      };
    }
  }
  return {
    comment: node.symbol?.getDocumentationComment(checker),
    tags: node.symbol?.getJsDocTags()
  };
}
function stringifyJsDocTagText(txt) {
  if (typeof txt === "string") {
    if (txt.startsWith("http ://") || txt.startsWith("https ://")) {
      return txt.replace(" ", "");
    }
    return txt;
  } else if (Array.isArray(txt)) {
    return txt.map((s) => s.text).join("");
  }
  return "";
}
function stringifyJsDocs(doc) {
  const tags = (doc.tags || []).filter((m) => !removedTags.includes(m.name)).map((m) => `@${m.name}${newLineTags.includes(m.name) ? "\n" : m.text ? " " : ""}${stringifyJsDocTagText(m.text)}`);
  const result = doc.comment?.map((m) => m.text) ?? [];
  if (tags && result.length) {
    return [result.join(""), ...tags].join("\n");
  } else if (tags) {
    return tags.join("\n");
  } else {
    return result.join("");
  }
}
function shouldDrop(canDrop, tags) {
  let found = false;
  if (tags) {
    for (const tag of tags) {
      switch (tag.name) {
        case "ignore":
          found = canDrop;
          break;
        case "dets_ignore":
          return true;
        case "dets_preserve":
          return false;
      }
    }
  }
  return found;
}
function getCommentOrDrop(checker, node, canDrop = false) {
  const doc = getJsDocs(checker, node);
  if (shouldDrop(canDrop, doc.tags)) {
    return void 0;
  }
  return stringifyJsDocs(doc);
}
function getComment(checker, node) {
  const doc = getJsDocs(checker, node);
  return stringifyJsDocs(doc);
}
var import_typescript, newLineTags, removedTags;
var init_comments = __esm({
  "src/helpers/comments.ts"() {
    import_typescript = require("typescript");
    newLineTags = ["example"];
    removedTags = ["dets_removeprop", "dets_removeclause", "dets_preserve", "dets_ignore"];
  }
});

// src/helpers/constants.ts
var tslibRoot, tslibPrefix, globalFiles, globalIndicator, modulesRoot, typesRoot;
var init_constants = __esm({
  "src/helpers/constants.ts"() {
    tslibRoot = "/node_modules/typescript/lib";
    tslibPrefix = "lib.";
    globalFiles = ["globals.d.ts", "global.d.ts"];
    globalIndicator = "__global";
    modulesRoot = "/node_modules/";
    typesRoot = "/node_modules/@types/";
  }
});

// src/helpers/identifiers.ts
function getLibRefName(libName) {
  if (libName[0] === "@") {
    libName = libName.substring(1);
  }
  const parts = libName.split(/[\/\-]/g);
  return parts.map((p) => p[0].toUpperCase() + p.substring(1)).join("");
}
function getTypeRefName(name) {
  if ((0, import_typescript2.isIdentifier)(name)) {
    return name.text;
  } else {
    const ns = getTypeRefName(name.left);
    return `${ns}.${name.right.text}`;
  }
}
function getPredicateName(name) {
  if ((0, import_typescript2.isIdentifier)(name)) {
    return name.text;
  } else {
    return "this";
  }
}
function getExportName(name) {
  if (!name) {
    return void 0;
  } else if ((0, import_typescript2.isIdentifier)(name)) {
    return name.text;
  } else if ((0, import_typescript2.isStringLiteral)(name)) {
    return name.text;
  } else {
    return name.text;
  }
}
function getParameterElement(element) {
  return (0, import_typescript2.isBindingElement)(element) ? getParameterName(element.name) : getParameterName(element);
}
function getParameterName(name) {
  if ((0, import_typescript2.isIdentifier)(name)) {
    return name.text;
  } else if ((0, import_typescript2.isObjectBindingPattern)(name)) {
    const content = name.elements.map(getParameterElement).join(", ");
    return `{ ${content} }`;
  } else if ((0, import_typescript2.isArrayBindingPattern)(name)) {
    const content = name.elements.map(getParameterElement).join(", ");
    return `[${content}]`;
  } else {
    return "";
  }
}
function makeModule(fileName, root2) {
  const relFile = (0, import_path.relative)(root2, fileName);
  const ext = (0, import_path.extname)(fileName);
  const file = !relFile.startsWith(".") ? `./${relFile}` : relFile;
  return file.substring(0, file.length - ext.length);
}
function getLibName(fileName, root2) {
  if (fileName) {
    if (fileName.indexOf(typesRoot) !== -1) {
      const start = fileName.lastIndexOf(typesRoot) + typesRoot.length;
      const name = fileName.substring(start).split("/").shift();
      if (name.indexOf("__") !== -1) {
        const [scope, lib] = name.split("__");
        return `@${scope}/${lib}`;
      }
      return name;
    } else if (fileName.indexOf(modulesRoot) !== -1) {
      const start = fileName.lastIndexOf(modulesRoot) + modulesRoot.length;
      const [scope, lib] = fileName.substring(start).split("/");
      if (scope.indexOf("@") === 0) {
        return `${scope}/${lib}`;
      }
      return scope;
    } else {
      return makeModule(fileName, root2);
    }
  }
  return void 0;
}
var import_typescript2, import_path;
var init_identifiers = __esm({
  "src/helpers/identifiers.ts"() {
    import_typescript2 = require("typescript");
    import_path = require("path");
    init_constants();
  }
});

// src/helpers/node.ts
function getModule(node) {
  while (node) {
    if ((0, import_typescript3.isModuleDeclaration)(node) && (0, import_typescript3.isSourceFile)(node.parent) && (0, import_typescript3.isStringLiteral)(node.name)) {
      return node.name.text;
    }
    node = node.parent;
  }
  return void 0;
}
function getDeclarationFromSymbol(checker, symbol) {
  if (!symbol) {
    return void 0;
  } else if (symbol.flags === import_typescript3.SymbolFlags.Alias) {
    const aliasSymbol = checker.getAliasedSymbol(symbol);
    return getDeclarationFromSymbol(checker, aliasSymbol);
  } else {
    const decl = symbol.valueDeclaration || symbol.declarations?.[0];
    if (decl && (0, import_typescript3.isImportSpecifier)(decl)) {
      return getDeclarationFromNode(checker, decl.name);
    }
    return decl;
  }
}
function getDeclarationFromNode(checker, node) {
  const symbol = getSymbol(checker, node);
  return getDeclarationFromSymbol(checker, symbol);
}
function getSymbol(checker, node) {
  const symbol = node.aliasSymbol ?? node.symbol;
  if (symbol) {
    return symbol;
  } else if ((0, import_typescript3.isTypeReferenceNode)(node)) {
    const ref = node.typeName;
    return ref.aliasSymbol ?? ref.symbol ?? checker.getSymbolAtLocation(ref);
  } else {
    return checker.getSymbolAtLocation(node);
  }
}
function isDefaultExport(node) {
  return node.symbol?.name === "default";
}
function shouldInclude(node) {
  return (0, import_typescript3.isModuleDeclaration)(node) || (0, import_typescript3.isExportDeclaration)(node) || isNodeExported(node);
}
function isNodeExported(node, alsoTopLevel = false) {
  return (0, import_typescript3.isExportAssignment)(node) || ((0, import_typescript3.getCombinedModifierFlags)(node) & import_typescript3.ModifierFlags.Export) !== 0 || alsoTopLevel && !!node.parent && node.parent.kind === import_typescript3.SyntaxKind.SourceFile;
}
function isPrivate(type) {
  return type.kind === import_typescript3.SyntaxKind.PrivateKeyword;
}
function isPublic(type) {
  return type.kind === import_typescript3.SyntaxKind.PublicKeyword;
}
function isStatic(type) {
  return type.kind === import_typescript3.SyntaxKind.StaticKeyword;
}
function isProtected(type) {
  return type.kind === import_typescript3.SyntaxKind.ProtectedKeyword;
}
function isReadonly(type) {
  return type.kind === import_typescript3.SyntaxKind.ReadonlyKeyword;
}
var import_typescript3;
var init_node = __esm({
  "src/helpers/node.ts"() {
    import_typescript3 = require("typescript");
  }
});

// src/helpers/paths.ts
function findAppRoot(root2, app) {
  return (0, import_path2.resolve)(root2, app);
}
function isBaseLib(path) {
  if (path in pathCache) {
    return pathCache[path];
  } else if (path) {
    const parts = path.split("/");
    const part = parts.pop();
    const newPath = parts.join("/");
    const result = newPath.endsWith(tslibRoot) && part.startsWith(tslibPrefix) || globalFiles.includes(part);
    pathCache[path] = result;
    return result;
  } else {
    return false;
  }
}
var import_path2, pathCache;
var init_paths = __esm({
  "src/helpers/paths.ts"() {
    import_path2 = require("path");
    init_constants();
    pathCache = {};
  }
});

// src/helpers/strings.ts
function makeIdentifier(identifier) {
  return checkIdentifier.test(identifier) ? identifier : JSON.stringify(identifier);
}
function formatContent(content) {
  return content.split("\n").map((line) => line ? `  ${line}
` : "\n").join("");
}
function toContent(lines, terminator) {
  const content = lines.map((line) => `${line}${terminator}`).join("\n");
  return formatContent(content);
}
function toBlock(lines, terminator) {
  if (lines.length > 0) {
    return `{
${toContent(lines, terminator)}}`;
  }
  return "{}";
}
var checkIdentifier;
var init_strings = __esm({
  "src/helpers/strings.ts"() {
    checkIdentifier = /^[a-zA-Z\_\$][a-zA-Z0-9\_\$]*$/;
  }
});

// src/helpers/symbol.ts
function fullyQualifiedName(symbol, delimiter) {
  const parts = [];
  do {
    parts.push(symbol.name);
    symbol = symbol.parent;
  } while (symbol && symbol.flags === import_typescript4.SymbolFlags.NamespaceModule && symbol.name !== globalIndicator);
  return parts.reverse().join(delimiter);
}
function isGlobal(symbol) {
  const parent = symbol?.parent;
  if (parent) {
    if (parent.name === globalIndicator) {
      return true;
    }
    return isGlobal(parent);
  }
  return false;
}
function getSymbolName(symbol) {
  if (symbol.flags === import_typescript4.SymbolFlags.EnumMember) {
    return `${symbol.parent.name}.${symbol.name}`;
  }
  return symbol.name;
}
function getModifiers(symbol) {
  const decorators = [];
  if (symbol) {
    const modifiers = symbol.declarations?.[0]?.modifiers ?? [];
    modifiers.some(isPrivate) && decorators.push("private");
    modifiers.some(isPublic) && decorators.push("public");
    modifiers.some(isProtected) && decorators.push("protected");
    modifiers.some(isStatic) && decorators.push("static");
    modifiers.some(isReadonly) && decorators.push("readonly");
  }
  return decorators.join(" ");
}
var import_typescript4;
var init_symbol = __esm({
  "src/helpers/symbol.ts"() {
    import_typescript4 = require("typescript");
    init_constants();
    init_node();
  }
});

// src/helpers/index.ts
var init_helpers = __esm({
  "src/helpers/index.ts"() {
    init_comments();
    init_identifiers();
    init_node();
    init_paths();
    init_strings();
    init_symbol();
  }
});

// src/output/stringify.ts
function stringifyComment(type) {
  if (type.comment) {
    const lines = type.comment.split("\n").map((line) => ` * ${line}
`).join("");
    return `/**
${lines} */
`;
  }
  return "";
}
function stringifyPropName(name) {
  return typeof name === "string" ? makeIdentifier(name) : `[${stringifyNode(name)}]`;
}
function stringifyTupleProp(type) {
  const target = type.valueType;
  const comment = stringifyComment(type);
  const isOpt = type.optional ? "?" : "";
  const name = stringifyPropName(type.name);
  if (typeof target === "undefined") {
    return `${comment}${name}${isOpt}: any`;
  } else if (target.kind === "function") {
    return `${comment}${name}${isOpt}: ${stringifySignature(target, 0 /* default */)}`;
  } else {
    return `${comment}${name}${isOpt}: ${stringifyNode(target)}`;
  }
}
function stringifyProp(type) {
  const target = type.valueType;
  const comment = stringifyComment(type);
  const isOpt = type.optional ? "?" : "";
  const modifier = type.modifiers ? `${type.modifiers} ` : "";
  const name = stringifyPropName(type.name);
  if (typeof target === "undefined") {
    return `${comment}${modifier}${name}${isOpt}: any`;
  } else if (target.kind === "function") {
    return `${comment}${modifier}${name}${isOpt}${stringifySignature(target, 1 /* property */)}`;
  } else {
    return `${comment}${modifier}${name}${isOpt}: ${stringifyNode(target)}`;
  }
}
function stringifyParameter(param) {
  const isOpt = param.optional ? "?" : "";
  const spread = param.spread ? "..." : "";
  const modifiers = param.modifiers ? `${param.modifiers} ` : "";
  return `${modifiers}${spread}${param.param}${isOpt}: ${stringifyNode(param.value)}`;
}
function stringifyParameters(params) {
  return params.map(stringifyParameter).join(", ");
}
function stringifySignature(type, mode, anonymous = false) {
  const ctor = type.kind === "new" ? "new " : "";
  const prop = (mode & 1 /* property */) !== 0;
  const paren = (mode & 2 /* parenthesis */) !== 0;
  const comment = anonymous ? stringifyComment(type) : "";
  const parameters = stringifyParameters(type.parameters);
  const ta = stringifyTypeArgs(type);
  const rt = stringifyNode(type.returnType);
  const del = prop ? ": " : " => ";
  const result = `${ctor}${ta}(${parameters})${del}${rt}`;
  const fn = paren ? `(${result})` : result;
  return `${comment}${fn}`;
}
function stringifyConstructor(type) {
  const parameters = stringifyParameters(type.parameters);
  const modifiers = type.modifiers ? `${type.modifiers} ` : "";
  return `${modifiers}constructor(${parameters})`;
}
function stringifyIndex(type) {
  const isOpt = type.optional ? "?" : "";
  const index = stringifyParameters(type.parameters);
  return `[${index}]${isOpt}: ${stringifyNode(type.valueType)}`;
}
function stringifyMapped(type) {
  const isOpt = type.optional ? "?" : "";
  const index = `${type.name} in ${stringifyNode(type.constraint)}`;
  return `[${index}]${isOpt}: ${stringifyNode(type.value)}`;
}
function stringifyAccess(type) {
  const right = stringifyNode(type.name);
  const left = stringifyNode(type.object);
  return `${left}.${right}`;
}
function stringifyIndexedAccess(type) {
  const right = stringifyNode(type.index);
  const left = stringifyNode(type.object);
  return `${left}[${right}]`;
}
function stringifyInterface(type) {
  const lines = type.props.map((p) => stringifyNode(p, 1 /* property */));
  if (type.mapped) {
    lines.push(stringifyMapped(type.mapped));
  }
  return toBlock(lines, ";");
}
function stringifyClass(type) {
  const lines = type.props.map((p) => stringifyNode(p));
  return toBlock(lines, ";");
}
function stringifyEnum(values) {
  const lines = values.map((p) => stringifyNode(p));
  return toBlock(lines, ",");
}
function stringifyExtends(type) {
  const { extends: es } = type;
  return es.length ? ` extends ${es.map((t) => stringifyNode(t)).join(", ")}` : "";
}
function stringifyImplements(type) {
  const { implements: is } = type;
  return is.length ? ` implements ${is.map((t) => stringifyNode(t)).join(", ")}` : "";
}
function stringifyTypes(types2) {
  return types2.map((t) => stringifyNode(t)).join(", ");
}
function stringifyTypeArgs(type) {
  if (type.types?.length > 0) {
    return `<${stringifyTypes(type.types)}>`;
  }
  return "";
}
function stringifyTypeParameter(type) {
  const name = stringifyNode(type.parameter);
  const constraint = stringifyNode(type.constraint);
  const defaults = stringifyNode(type.default);
  const constraintClause = constraint ? ` extends ${constraint}` : "";
  const defaultsClause = defaults ? ` = ${defaults}` : "";
  return `${name}${constraintClause}${defaultsClause}`;
}
function stringifyTernary(condition) {
  const t = stringifyNode(condition.check);
  const e = stringifyNode(condition.extends);
  const p = stringifyNode(condition.primary);
  const a = stringifyNode(condition.alternate);
  return `${t} extends ${e} ? ${p} : ${a}`;
}
function stringifyMember(member) {
  const key = stringifyPropName(member.name);
  const name = `${stringifyComment(member)}${key}`;
  if (member.value) {
    return `${name} = ${stringifyNode(member.value)}`;
  }
  return name;
}
function stringifySetAccessor(accessor) {
  const comment = stringifyComment(accessor);
  const modifier = accessor.modifiers ? `${accessor.modifiers} ` : "";
  const args2 = stringifyParameters(accessor.parameters);
  return `${comment}${modifier}set ${accessor.name}(${args2})`;
}
function stringifyGetAccessor(accessor) {
  const comment = stringifyComment(accessor);
  const modifier = accessor.modifiers ? `${accessor.modifiers} ` : "";
  const result = stringifyNode(accessor.type);
  return `${comment}${modifier}get ${accessor.name}(): ${result}`;
}
function stringifyPredicate(predicate) {
  const type = stringifyNode(predicate.value);
  return `${predicate.name} is ${type}`;
}
function stringifyReadonly(type) {
  const value = type.value;
  if (value.kind === "ref" && value.refName === "Array" && value.types.length === 1) {
    const [arg] = value.types;
    return `readonly ${stringifyNode(arg)}[]`;
  }
  return `readonly ${stringifyNode(value)}`;
}
function stringifyNode(type, mode = 0 /* default */) {
  switch (type?.kind) {
    case "interface":
      return stringifyInterface(type);
    case "prop":
      return stringifyProp(type);
    case "tuple-prop":
      return stringifyTupleProp(type);
    case "ref":
      return `${type.refName}${stringifyTypeArgs(type)}`;
    case "typeParameter":
      return stringifyTypeParameter(type);
    case "union":
      return type.types.map((u) => stringifyNode(u, 2 /* parenthesis */)).join(" | ");
    case "intersection":
      return type.types.map((u) => stringifyNode(u)).join(" & ");
    case "member":
      return stringifyMember(type);
    case "conditional":
      return stringifyTernary(type);
    case "readonly":
      return stringifyReadonly(type);
    case "unique":
      return `unique ${stringifyNode(type.value)}`;
    case "keyof":
      return `keyof ${stringifyNode(type.value)}`;
    case "infer":
      return `infer ${stringifyNode(type.parameter)}`;
    case "any":
    case "null":
    case "void":
    case "undefined":
    case "boolean":
    case "unknown":
    case "bigint":
    case "number":
    case "never":
    case "string":
      return type.kind;
    case "nonPrimitive":
      return type.name || "object";
    case "esSymbol":
      return "symbol";
    case "unidentified":
      return "any";
    case "literal":
      return `${type.value}`;
    case "access":
      return stringifyAccess(type);
    case "indexedAccess":
      return stringifyIndexedAccess(type);
    case "index":
      return stringifyIndex(type);
    case "class":
      return `class ${stringifyClass(type)}`;
    case "constructor":
      return stringifyConstructor(type);
    case "mapped":
      return stringifyMapped(type);
    case "substitution":
      return stringifyNode(type.variable);
    case "rest":
      return `...${stringifyNode(type.value)}`;
    case "new":
    case "function":
      return stringifySignature(type, mode, true);
    case "tuple":
      return `[${stringifyTypes(type.types)}]`;
    case "set":
      return stringifySetAccessor(type);
    case "get":
      return stringifyGetAccessor(type);
    case "predicate":
      return stringifyPredicate(type);
    case "template":
      return `\`${type.parts.map((p) => typeof p === "string" ? p : `\${${stringifyNode(p)}}`).join("")}\``;
    case "parenthesis":
      return `(${stringifyNode(type.value)})`;
  }
  return "";
}
var init_stringify = __esm({
  "src/output/stringify.ts"() {
    init_helpers();
  }
});

// src/output/exports.ts
function stringifyExport(type) {
  switch (type?.kind) {
    case "interface":
      return `${stringifyComment(type)}export interface ${type.name}${stringifyTypeArgs(type)}${stringifyExtends(
        type
      )} ${stringifyInterface(type)}`;
    case "class":
      return `${stringifyComment(type)}export class ${type.name}${stringifyTypeArgs(type)}${stringifyExtends(
        type
      )}${stringifyImplements(type)} ${stringifyClass(type)}`;
    case "alias":
      return `${stringifyComment(type)}export type ${type.name}${stringifyTypeArgs(type)} = ${stringifyNode(
        type.child
      )};`;
    case "enumLiteral":
      return `${stringifyComment(type)}export ${type.const ? "const enum" : "enum"} ${type.name} ${stringifyEnum(
        type.values
      )}`;
    case "const":
      return `${stringifyComment(type)}export const ${type.name}: ${stringifyNode(type.value)};`;
    case "function":
      return `${stringifyComment(type)}export function ${type.name}${stringifySignature(
        type,
        1 /* property */
      )};`;
    case "default":
      const sc = type.value.kind === "class" ? "" : ";";
      return `${stringifyComment(type)}export default ${stringifyNode(type.value)}${sc}`;
  }
  return "";
}
function stringifyExports(refs) {
  return refs.map((r) => stringifyExport(r)).filter((m) => !!m).join("\n\n");
}
var init_exports = __esm({
  "src/output/exports.ts"() {
    init_stringify();
  }
});

// src/output/module.ts
function stringifyModule(name, refs) {
  const content = stringifyExports(refs);
  const formattedContent = formatContent(content);
  return `declare module "${name}" {
${formattedContent}}`;
}
var init_module = __esm({
  "src/output/module.ts"() {
    init_exports();
    init_helpers();
  }
});

// src/output/declaration.ts
function stringifyDeclaration(context) {
  const { noModuleDeclaration } = context.flags;
  const modules = Object.keys(context.modules).filter((moduleName) => Object.keys(context.modules[moduleName]).length > 0).map((moduleName) => {
    const refs = context.modules[moduleName];
    if (noModuleDeclaration && moduleName === context.name) {
      return stringifyExports(refs);
    }
    return stringifyModule(moduleName, refs);
  }).join("\n\n");
  const preamble = context.usedImports.map((lib) => `import * as ${getLibRefName(lib)} from '${lib}';`).join("\n");
  if (preamble) {
    return `${preamble}

${modules}`;
  }
  return modules;
}
var init_declaration = __esm({
  "src/output/declaration.ts"() {
    init_module();
    init_exports();
    init_helpers();
  }
});

// src/output/index.ts
var init_output = __esm({
  "src/output/index.ts"() {
    init_declaration();
    init_exports();
    init_module();
  }
});

// src/logger.ts
var defaultLogger, wrapLogger;
var init_logger = __esm({
  "src/logger.ts"() {
    defaultLogger = {
      error(message) {
        throw new Error(message);
      },
      warn(message) {
        console.warn(message);
      },
      info(message) {
        console.info(message);
      },
      verbose(message) {
        console.log(message);
      }
    };
    wrapLogger = (logger, level) => {
      return {
        error(message) {
          level >= 1 && logger.error(message);
        },
        warn(message) {
          level >= 2 && logger.warn(message);
        },
        info(message) {
          level >= 3 && logger.info(message);
        },
        verbose(message) {
          level >= 4 && logger.verbose(message);
        }
      };
    };
  }
});

// src/input/api.ts
function includeApi(context, node, interfaceName) {
  if ((0, import_typescript5.isInterfaceDeclaration)(node) && node.name.text === interfaceName) {
    context.exports.push(node);
  } else {
    context.log.verbose(`Skipping API using interface "${interfaceName}" from node: ${node}`);
  }
}
var import_typescript5;
var init_api = __esm({
  "src/input/api.ts"() {
    import_typescript5 = require("typescript");
  }
});

// src/input/exports.ts
function includeExports(context, key, symbol) {
  const defs = {};
  if (symbol) {
    context.checker.getExportsOfModule(symbol).forEach((exp) => {
      const decl = exp.valueDeclaration || exp.declarations?.[0];
      if (!decl) {
      } else if (ts.isExportSpecifier(decl)) {
        const name = decl.name?.text;
        if (name) {
          defs[name] = getDeclarationFromNode(context.checker, decl);
        }
      } else if (ts.isExportAssignment(decl)) {
        defs["default"] = getDeclarationFromNode(context.checker, decl);
      } else if (ts.isVariableDeclaration(decl)) {
        defs[getParameterName(decl.name)] = decl;
      } else if (ts.isFunctionDeclaration(decl) || ts.isInterfaceDeclaration(decl) || ts.isClassDeclaration(decl) || ts.isTypeAliasDeclaration(decl) || ts.isEnumDeclaration(decl)) {
        const name = isDefaultExport(decl) ? "default" : decl.name?.text;
        if (name) {
          defs[name] = decl;
        }
      } else if (ts.isMethodDeclaration(decl) || ts.isPropertyDeclaration(decl) || ts.isModuleDeclaration(decl)) {
      } else if (ts.isImportEqualsDeclaration(decl)) {
      } else if (ts.isNamespaceExport(decl)) {
        defs[decl.name.text] = decl;
      } else {
        context.log.warn(`Skipping import of unknown node (kind: ${decl.kind}).`);
      }
    });
  }
  context.availableImports[key] = defs;
}
var ts;
var init_exports2 = __esm({
  "src/input/exports.ts"() {
    ts = __toESM(require("typescript"));
    init_helpers();
  }
});

// src/input/utils.ts
function createBinding(context, lib, name) {
  if (!context.usedImports.includes(lib)) {
    context.usedImports.push(lib);
  }
  return `${getLibRefName(lib)}.${name}`;
}
function getDefault(value) {
  return {
    kind: "default",
    name: "default",
    value
  };
}
function getRef(refName, types2 = []) {
  return {
    kind: "ref",
    refName,
    types: types2
  };
}
function getSymbolName2(imports, node) {
  if (imports) {
    for (const name of Object.keys(imports)) {
      if (imports[name] === node) {
        return name;
      }
    }
  }
  return void 0;
}
function isImportedFile(node, root2, imports) {
  const fn = node.getSourceFile()?.fileName;
  if (fn) {
    const libName = getLibName(fn, root2);
    return Object.keys(imports).some((name) => name === libName);
  }
  return false;
}
function getPackage(node, global, root2, imports) {
  const fn = node.getSourceFile()?.fileName;
  const base = isBaseLib(fn) || false;
  if (!base) {
    const libName = getLibName(fn, root2);
    const [lib] = Object.keys(imports).filter((name) => {
      if (global) {
        return name === libName;
      } else {
        return Object.values(imports[name]).includes(node);
      }
    });
    const symbolName = getSymbolName2(imports[lib], node);
    return {
      external: !!lib,
      moduleName: lib && getModule(node) || lib,
      symbolName,
      base,
      lib,
      fn
    };
  }
  return {
    external: true,
    moduleName: void 0,
    symbolName: void 0,
    base,
    lib: void 0,
    fn
  };
}
var init_utils = __esm({
  "src/input/utils.ts"() {
    init_helpers();
  }
});

// src/input/includes.ts
function isText(actual, expected) {
  if (typeof actual === "string") {
    return actual === expected;
  } else if (Array.isArray(actual)) {
    return actual.some((m) => m.text === expected);
  }
  return false;
}
function includeClauses(context, clauses, newClause, tags = []) {
  const types2 = [];
  for (const clause of newClause.types) {
    const decl = getDeclarationFromNode(context.checker, clause.expression);
    const name = decl?.symbol?.name;
    if (decl && !tags.some((m) => m.name === "dets_removeclause" && isText(m.text, name))) {
      types2.push(clause);
    }
  }
  clauses.push({
    ...newClause,
    types: ts2.factory.createNodeArray(types2)
  });
}
function includeProp(props, newProp, getPropName, tags = []) {
  const name = getPropName(newProp.name);
  if (tags.some((m) => m.name === "dets_removeprop" && isText(m.text, name))) {
    return;
  }
  for (const oldProp of props) {
    if (oldProp.kind === newProp.kind && getPropName(oldProp.name) === name) {
      if (!ts2.isMethodSignature(newProp) && !ts2.isCallSignatureDeclaration(newProp)) {
        return;
      }
    }
  }
  props.push(newProp);
}
var ts2;
var init_includes = __esm({
  "src/input/includes.ts"() {
    ts2 = __toESM(require("typescript"));
    init_helpers();
  }
});

// src/input/node.ts
var ts3, DeclVisitor;
var init_node2 = __esm({
  "src/input/node.ts"() {
    ts3 = __toESM(require("typescript"));
    init_utils();
    init_includes();
    init_helpers();
    DeclVisitor = class {
      constructor(context) {
        this.context = context;
        this.queue = [];
        this.modules = [];
        this.processed = [];
        const [defaultModule] = Object.keys(context.modules ?? {});
        this.refs = context.modules[defaultModule] ?? [];
        this.names = context.moduleNames[defaultModule] ?? /* @__PURE__ */ new Map();
        for (const node of context.exports) {
          this.enqueue(node);
        }
      }
      logVerbose(message) {
        this.context.log.verbose(message);
      }
      logWarn(message) {
        this.context.log.warn(message);
      }
      printWarning(type, node) {
        this.logWarn(
          `Could not resolve ${type} at position ${node.pos} of "${node.getSourceFile()?.fileName}". Kind: ${node.kind}.`
        );
      }
      swapName(oldName, newName) {
        const refs = this.refs;
        const last = refs.pop();
        if (!last) {
        } else if (last.kind === "default") {
          if (last.value.kind === "ref") {
            const name = last.value.refName;
            for (let i = refs.length; i--; ) {
              const ref = refs[i];
              if (ref.name === name) {
                refs.splice(i, 1, {
                  ...ref,
                  name: newName
                });
                break;
              }
            }
          }
        } else if ("name" in last && last.name === oldName) {
          refs.push({
            ...last,
            name: newName
          });
        } else {
          refs.push(last);
        }
      }
      findName(node) {
        return this.names.get(node);
      }
      createName(name) {
        const altStart = `${name}___`;
        const available = /* @__PURE__ */ new Set();
        for (const m of this.names.values()) {
          if (m === name || m.startsWith(altStart)) {
            available.add(m);
          }
        }
        const count = available.size;
        if (count) {
          return `${altStart}${count}`;
        }
        return name;
      }
      getName(node, suggested) {
        const existing = this.findName(node);
        if (!existing) {
          this.logVerbose(`Missing "name". Retrieving with suggestion "${suggested}".`);
          const name = this.createName(suggested);
          const decls = node.symbol?.declarations ?? [node];
          decls.forEach((decl) => this.names.set(decl, name));
          return name;
        }
        return existing;
      }
      normalizeName(node) {
        const c = this.context;
        const symbol = node.symbol ?? node.aliasSymbol ?? c.checker.getSymbolAtLocation(node);
        const global = isGlobal(symbol);
        const { moduleName, lib, symbolName } = getPackage(node, global, c.root, c.availableImports);
        if (!lib) {
          const name = global ? fullyQualifiedName(symbol, "_") : getSymbolName(symbol);
          return this.getName(node, name);
        } else if (global) {
          return fullyQualifiedName(symbol, ".");
        } else {
          return createBinding(c, moduleName, symbolName ?? getSymbolName(symbol));
        }
      }
      convertToTypeNodeFromType(type) {
        const c = this.context.checker;
        return c.typeToTypeNode(type, void 0, ts3.NodeBuilderFlags.NoTruncation);
      }
      convertToTypeNodeFromNode(node) {
        const type = this.context.checker.getTypeAtLocation(node);
        return this.convertToTypeNodeFromType(type);
      }
      valueFromLiteral(node) {
        switch (node.literal.kind) {
          case ts3.SyntaxKind.StringLiteral:
            return JSON.stringify(node.literal.text);
          case ts3.SyntaxKind.TrueKeyword:
            return "true";
          case ts3.SyntaxKind.FalseKeyword:
            return "false";
          case ts3.SyntaxKind.NumericLiteral:
          case ts3.SyntaxKind.BigIntLiteral:
            return node.literal.text;
          case ts3.SyntaxKind.NullKeyword:
            return "null";
          default:
            this.logVerbose(`No match for literal node kind "${node.literal.kind}". Trying to get from type node...`);
            const type = this.context.checker.getTypeFromTypeNode(node);
            return type?.intrinsicName ?? type?.value;
        }
      }
      getInferredType(node) {
        const typeNode = this.convertToTypeNodeFromNode(node);
        return this.getTypeNode(typeNode);
      }
      getUnion(node) {
        return {
          kind: "union",
          types: node.types.map((m) => this.getNode(m))
        };
      }
      getLiteral(node) {
        return {
          kind: "literal",
          value: this.valueFromLiteral(node)
        };
      }
      getNode(node) {
        if (ts3.isTypeNode(node)) {
          return this.getTypeNode(node);
        } else if (ts3.isTypeAliasDeclaration(node) || ts3.isFunctionDeclaration(node) || ts3.isInterfaceDeclaration(node) || ts3.isClassDeclaration(node)) {
          this.enqueue(node);
          return getRef(this.normalizeName(node), this.getTypeParameters(node.typeParameters));
        } else if (isDefaultExport(node) || ts3.isVariableDeclaration(node) || ts3.isVariableStatement(node)) {
          this.enqueue(node);
          return getRef(this.normalizeName(node));
        } else if (ts3.isPropertyAssignment(node)) {
          return {
            kind: "prop",
            modifiers: getModifiers(node.symbol),
            name: node.symbol.name,
            //@ts-ignore
            optional: node.questionToken !== void 0,
            valueType: this.getExpression(node.initializer)
          };
        }
        this.logVerbose(`Node is presumably a reference. Found kind "${node.kind}".`);
        return getRef(node.symbol.name);
      }
      getPropDeclaration(node) {
        const type = node.type ?? this.convertToTypeNodeFromNode(node);
        return this.getTypeNode(type);
      }
      getPropValue(node) {
        if (ts3.isPropertySignature(node)) {
          return this.getTypeNode(node.type);
        } else if (ts3.isMethodSignature(node)) {
          return this.getMethodSignature(node);
        } else if (ts3.isPropertyDeclaration(node)) {
          return this.getPropDeclaration(node);
        } else if (ts3.isMethodDeclaration(node)) {
          return this.getMethodSignature(node);
        }
        this.printWarning("property", node);
      }
      getNormalProp(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = getCommentOrDrop(checker, node.emitNode?.commentRange ?? node, canDrop);
        if (typeof comment === "string") {
          return {
            kind: "prop",
            name: this.getPropName(node.name),
            modifiers: getModifiers(node.symbol),
            optional: node.questionToken !== void 0,
            comment,
            valueType: this.getPropValue(node)
          };
        }
        this.logVerbose(`The prop "${this.getPropName(node.name)}" was skipped due to @ignore.`);
        return void 0;
      }
      getIndexProp(node) {
        return {
          kind: "index",
          parameters: this.getFunctionParameters(node.parameters),
          optional: node.questionToken !== void 0,
          valueType: this.getTypeNode(node.type)
        };
      }
      getConstructor(node) {
        return {
          kind: "constructor",
          parameters: this.getFunctionParameters(node.parameters),
          modifiers: getModifiers(node.symbol),
          comment: getComment(this.context.checker, node)
        };
      }
      getClassMember(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = getCommentOrDrop(checker, node, canDrop);
        if (node.name) {
          if (typeof comment === "string") {
            return {
              kind: "prop",
              name: node.name.getText(),
              modifiers: getModifiers(node.symbol),
              optional: false,
              comment,
              valueType: this.getPropValue(node)
            };
          }
          this.logVerbose(`The member "${node.name.getText()}" was skipped due to @ignore.`);
        }
        return void 0;
      }
      getProps(nodes) {
        const props = [];
        nodes?.forEach((node) => {
          if (ts3.isIndexSignatureDeclaration(node)) {
            props.push(this.getIndexProp(node));
          } else if (ts3.isCallSignatureDeclaration(node)) {
            props.push(this.getMethodSignature(node));
          } else if (ts3.isConstructSignatureDeclaration(node)) {
            props.push(this.getConstructorCall(node));
          } else if (ts3.isGetAccessor(node)) {
            const prop = this.getGetAccessor(node);
            prop && props.push(prop);
          } else if (ts3.isSetAccessor(node)) {
            const prop = this.getSetAccessor(node);
            prop && props.push(prop);
          } else if (ts3.isPropertySignature(node)) {
            const prop = this.getNormalProp(node);
            prop && props.push(prop);
          } else {
            this.logVerbose(`Getting props - assuming node of kind "${node?.kind}" is a normal prop.`);
            const prop = this.getNormalProp(node);
            prop && props.push(prop);
          }
        });
        return props;
      }
      getClassMembers(nodes) {
        const members = [];
        nodes?.forEach((node) => {
          if (ts3.isConstructorDeclaration(node)) {
            members.push(this.getConstructor(node));
          } else if (ts3.isCallSignatureDeclaration(node)) {
            members.push(this.getMethodSignature(node));
          } else if (ts3.isConstructSignatureDeclaration(node)) {
            members.push(this.getConstructorCall(node));
          } else if (ts3.isGetAccessor(node)) {
            const member = this.getGetAccessor(node);
            member && members.push(member);
          } else if (ts3.isSetAccessor(node)) {
            const member = this.getSetAccessor(node);
            member && members.push(member);
          } else if (ts3.isIndexSignatureDeclaration(node)) {
            members.push(this.getIndexProp(node));
          } else {
            this.logVerbose(`Getting class members - assuming node of kind "${node?.kind}" is a class member.`);
            const member = this.getClassMember(node);
            member && members.push(member);
          }
        });
        return members;
      }
      getEnumMember(node) {
        const value = node.initializer;
        return {
          kind: "member",
          name: this.getPropName(node.name),
          value: value && this.getExpression(value),
          comment: getComment(this.context.checker, node)
        };
      }
      getEnumMembers(nodes) {
        return nodes?.map((node) => this.getEnumMember(node)) ?? [];
      }
      getReturnType(node) {
        const checker = this.context.checker;
        const type = node.type ?? this.convertToTypeNodeFromType(checker.getReturnTypeOfSignature(checker.getSignatureFromDeclaration(node)));
        return this.getTypeNode(type);
      }
      getFunctionDeclaration(node) {
        const name = this.getName(node, node.name.text);
        return {
          ...this.getMethodSignature(node),
          name
        };
      }
      getMethodSignature(node) {
        return {
          kind: "function",
          name: void 0,
          parameters: this.getFunctionParameters(node.parameters),
          returnType: this.getReturnType(node),
          types: this.getTypeParameters(node.typeParameters),
          comment: getComment(this.context.checker, node)
        };
      }
      getConstructorCall(node) {
        return {
          kind: "new",
          parameters: this.getFunctionParameters(node.parameters),
          returnType: this.getTypeNode(node.type),
          types: this.getTypeParameters(node.typeParameters),
          comment: getComment(this.context.checker, node)
        };
      }
      getTypeParameter(node) {
        return {
          kind: "typeParameter",
          parameter: getRef(node.name.text),
          constraint: node.constraint && this.getTypeNode(node.constraint),
          default: node.default && this.getTypeNode(node.default)
        };
      }
      getTypeParameters(nodes) {
        return nodes?.map((node) => this.getTypeParameter(node)) ?? [];
      }
      getTypeArguments(nodes) {
        return nodes?.map((node) => this.getTypeNode(node)) ?? [];
      }
      getFunctionParameterValue(node) {
        if (node.type) {
          return this.getTypeNode(node.type);
        }
        const typeNode = this.convertToTypeNodeFromNode(node);
        if (typeNode) {
          return this.getTypeNode(typeNode);
        } else if (node.initializer) {
          return this.getExpression(node.initializer);
        } else {
          this.logVerbose(
            `Found unidentified node of kind "${node.kind}" in function parameter value. Falling back to "any".`
          );
          return {
            kind: "any"
          };
        }
      }
      getFunctionParameter(node) {
        return {
          kind: "parameter",
          param: getParameterName(node.name),
          spread: node.dotDotDotToken !== void 0,
          optional: node.questionToken !== void 0 || node.initializer !== void 0,
          modifiers: getModifiers(node.symbol),
          value: this.getFunctionParameterValue(node)
        };
      }
      getFunctionParameters(nodes) {
        return nodes?.map((node) => this.getFunctionParameter(node)) ?? [];
      }
      getIndexAccess(node) {
        return {
          kind: "indexedAccess",
          index: this.getTypeNode(node.indexType),
          object: this.getTypeNode(node.objectType)
        };
      }
      getTypeOperator(node) {
        switch (node.operator) {
          case ts3.SyntaxKind.KeyOfKeyword:
            return {
              kind: "keyof",
              value: this.getTypeNode(node.type)
            };
          case ts3.SyntaxKind.UniqueKeyword:
            return {
              kind: "unique",
              value: this.getTypeNode(node.type)
            };
          case ts3.SyntaxKind.ReadonlyKeyword:
            return {
              kind: "readonly",
              value: this.getTypeNode(node.type)
            };
          default:
            this.logWarn(`Found unknown type operator node of kind "${node.kind}".`);
        }
      }
      getMappedType(node) {
        const p = node.typeParameter;
        return {
          kind: "interface",
          name: void 0,
          extends: [],
          props: [],
          types: [],
          comment: getComment(this.context.checker, node),
          mapped: {
            kind: "mapped",
            constraint: this.getTypeNode(p.constraint),
            name: p.name.text,
            optional: node.questionToken !== void 0,
            value: this.getTypeNode(node.type)
          }
        };
      }
      getConditionalType(node) {
        return {
          kind: "conditional",
          alternate: this.getTypeNode(node.falseType),
          check: this.getTypeNode(node.checkType),
          extends: this.getTypeNode(node.extendsType),
          primary: this.getTypeNode(node.trueType)
        };
      }
      getPredicate(node) {
        return {
          kind: "predicate",
          name: getPredicateName(node.parameterName),
          value: this.getTypeNode(node.type)
        };
      }
      getSetAccessor(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = getCommentOrDrop(checker, node, canDrop);
        if (typeof comment === "string") {
          return {
            kind: "set",
            name: this.getPropName(node.name),
            parameters: this.getFunctionParameters(node.parameters),
            comment,
            modifiers: getModifiers(node.symbol)
          };
        }
        this.logVerbose(`The setter "${this.getPropName(node.name)}" was skipped due to @ignore.`);
        return void 0;
      }
      getGetAccessor(node) {
        const { checker, flags } = this.context;
        const canDrop = !flags.noIgnore;
        const comment = getCommentOrDrop(checker, node, canDrop);
        if (typeof comment === "string") {
          return {
            kind: "get",
            name: this.getPropName(node.name),
            type: this.getReturnType(node),
            comment,
            modifiers: getModifiers(node.symbol)
          };
        }
        this.logVerbose(`The getter "${this.getPropName(node.name)}" was skipped due to @ignore.`);
        return void 0;
      }
      getTypeReference(node) {
        const c = this.context.checker;
        const decl = getDeclarationFromNode(c, node);
        if (decl && !ts3.isTypeParameterDeclaration(decl)) {
          this.enqueue(decl);
          return getRef(this.normalizeName(decl), this.getTypeArguments(node.typeArguments));
        }
        return getRef(getTypeRefName(node.typeName), this.getTypeArguments(node.typeArguments));
      }
      getTypeLiteral(node) {
        return {
          kind: "interface",
          name: void 0,
          comment: getComment(this.context.checker, node),
          extends: [],
          props: this.getProps(node.members),
          types: []
        };
      }
      getExpressionWithTypeArguments(node) {
        const decl = getDeclarationFromNode(this.context.checker, node.expression);
        if (decl) {
          this.enqueue(decl);
          return getRef(this.normalizeName(decl), this.getTypeArguments(node.typeArguments));
        }
        return {
          kind: "ref",
          refName: "any",
          types: []
        };
      }
      getArray(node) {
        return getRef("Array", [this.getTypeNode(node.elementType)]);
      }
      getInfer(node) {
        return {
          kind: "infer",
          parameter: this.getTypeParameter(node.typeParameter)
        };
      }
      getIntersection(node) {
        return {
          kind: "intersection",
          types: node.types.map((n) => this.getTypeNode(n))
        };
      }
      getTuple(node) {
        return {
          kind: "tuple",
          types: (node["elementTypes"] ?? node.elements).map((n) => this.getTypeNode(n))
        };
      }
      getParenthesis(node) {
        return {
          kind: "parenthesis",
          value: this.getTypeNode(node.type)
        };
      }
      getTypeQueryNode(node) {
        const symbol = this.context.checker.getSymbolAtLocation(node.exprName);
        if (symbol !== void 0) {
          const type = this.context.checker.getTypeOfSymbolAtLocation(symbol, node);
          const typeNode = this.convertToTypeNodeFromType(type);
          if (typeNode && ts3.isImportTypeNode(typeNode)) {
            const props = type.getProperties().map((prop) => ({
              name: prop.name,
              decl: prop.valueDeclaration
            })).map((m) => ({
              name: m.name,
              type: m.decl && this.context.checker.getTypeOfSymbolAtLocation(m.decl.symbol, m.decl)
            })).map((m) => ({
              name: m.name,
              node: m.type && this.convertToTypeNodeFromType(m.type)
            })).map(
              (m) => ({
                name: m.name,
                modifiers: "",
                optional: false,
                kind: "prop",
                valueType: this.getTypeNode(m.node)
              })
            );
            return {
              kind: "interface",
              props,
              types: [],
              extends: [],
              name: ""
            };
          }
          return this.getTypeNode(typeNode);
        }
        const decl = getDeclarationFromNode(this.context.checker, node.exprName);
        this.enqueue(decl);
        return getRef(`typeof ${getTypeRefName(node.exprName)}`);
      }
      getTypeRestNode(node) {
        return {
          kind: "rest",
          value: this.getTypeNode(node.type)
        };
      }
      getNamedTuple(node) {
        const model = {
          kind: "tuple-prop",
          name: this.getPropName(node.name),
          valueType: this.getTypeNode(node.type),
          optional: node.questionToken !== void 0
        };
        if (node.dotDotDotToken) {
          return {
            kind: "rest",
            value: model
          };
        }
        return model;
      }
      getTemplateLiteralNode(node) {
        const parts = [node.head.text];
        for (const span of node.templateSpans) {
          parts.push(this.getTypeNode(span.type));
          parts.push(span.literal.text);
        }
        return {
          kind: "template",
          parts
        };
      }
      getConstantNode(node) {
        switch (node.kind) {
          case ts3.SyntaxKind.AnyKeyword:
            return {
              kind: "any"
            };
          case ts3.SyntaxKind.UnknownKeyword:
            return {
              kind: "unknown"
            };
          case ts3.SyntaxKind.NumberKeyword:
            return {
              kind: "number"
            };
          case ts3.SyntaxKind.BigIntKeyword:
            return {
              kind: "bigint"
            };
          case ts3.SyntaxKind.ObjectKeyword:
            return {
              kind: "nonPrimitive"
            };
          case ts3.SyntaxKind.BooleanKeyword:
            return {
              kind: "boolean"
            };
          case ts3.SyntaxKind.StringKeyword:
            return {
              kind: "string"
            };
          case ts3.SyntaxKind.SymbolKeyword:
            return {
              kind: "esSymbol"
            };
          case ts3.SyntaxKind.VoidKeyword:
            return {
              kind: "void"
            };
          case ts3.SyntaxKind.UndefinedKeyword:
            return {
              kind: "undefined"
            };
          case ts3.SyntaxKind.NullKeyword:
            return {
              kind: "null"
            };
          case ts3.SyntaxKind.NeverKeyword:
            return {
              kind: "never"
            };
          case ts3.SyntaxKind.ThisKeyword:
          case ts3.SyntaxKind.ThisType:
            return getRef("this");
        }
        this.printWarning("type node", node);
      }
      getTypeNode(node) {
        if (!node) {
          return {
            kind: "any"
          };
        } else if (ts3.isUnionTypeNode(node)) {
          return this.getUnion(node);
        } else if (ts3.isLiteralTypeNode(node)) {
          return this.getLiteral(node);
        } else if (ts3.isExpressionWithTypeArguments(node)) {
          return this.getExpressionWithTypeArguments(node);
        } else if (ts3.isTypeLiteralNode(node)) {
          return this.getTypeLiteral(node);
        } else if (ts3.isArrayTypeNode(node)) {
          return this.getArray(node);
        } else if (ts3.isTypeReferenceNode(node)) {
          return this.getTypeReference(node);
        } else if (ts3.isIndexedAccessTypeNode(node)) {
          return this.getIndexAccess(node);
        } else if (ts3.isTypeOperatorNode(node)) {
          return this.getTypeOperator(node);
        } else if (ts3.isMappedTypeNode(node)) {
          return this.getMappedType(node);
        } else if ("isConditionalTypeNode" in ts3 && ts3.isConditionalTypeNode(node)) {
          return this.getConditionalType(node);
        } else if (ts3.isFunctionTypeNode(node)) {
          return this.getMethodSignature(node);
        } else if ("isInferTypeNode" in ts3 && ts3.isInferTypeNode(node)) {
          return this.getInfer(node);
        } else if (ts3.isIntersectionTypeNode(node)) {
          return this.getIntersection(node);
        } else if (ts3.isParenthesizedTypeNode(node)) {
          return this.getParenthesis(node);
        } else if (ts3.isConstructorTypeNode(node)) {
          return this.getConstructorCall(node);
        } else if ("isTypePredicateNode" in ts3 && ts3.isTypePredicateNode(node)) {
          return this.getPredicate(node);
        } else if ("isTupleTypeNode" in ts3 && ts3.isTupleTypeNode(node)) {
          return this.getTuple(node);
        } else if ("isTypeQueryNode" in ts3 && ts3.isTypeQueryNode(node)) {
          return this.getTypeQueryNode(node);
        } else if ("isRestTypeNode" in ts3 && ts3.isRestTypeNode(node)) {
          return this.getTypeRestNode(node);
        } else if ("isTemplateLiteralTypeNode" in ts3 && ts3.isTemplateLiteralTypeNode(node)) {
          return this.getTemplateLiteralNode(node);
        } else if (ts3.isNamedTupleMember(node)) {
          return this.getNamedTuple(node);
        } else {
          return this.getConstantNode(node);
        }
      }
      getExtends(nodes) {
        const clauses = [];
        nodes?.forEach((node) => {
          if (node.token === ts3.SyntaxKind.ExtendsKeyword) {
            clauses.push(...node.types);
          } else {
            this.logVerbose(`Skipping unidentified node of kind "${node.kind}" in extends section.`);
          }
        });
        return clauses.map((node) => this.getTypeNode(node));
      }
      getImplements(nodes) {
        const clauses = [];
        nodes?.forEach((node) => {
          if (node.token === ts3.SyntaxKind.ImplementsKeyword) {
            clauses.push(...node.types);
          } else {
            this.logVerbose(`Skipping unidentified node of kind "${node.kind}" in implements section.`);
          }
        });
        return clauses.map((node) => this.getTypeNode(node));
      }
      getDefaultExpression(node) {
        const name = getExportName(node.name) ?? "_default";
        const expr = node.expression;
        if (ts3.isIdentifier(expr)) {
          const decl = getDeclarationFromNode(this.context.checker, expr);
          this.enqueue(decl);
          return getRef(expr.text);
        } else if (ts3.isArrowFunction(expr)) {
          this.includeInContext(expr, () => ({
            ...this.getMethodSignature(expr),
            name
          }));
        } else {
          this.includeInContext(expr, () => ({
            kind: "const",
            name,
            value: this.getExpression(expr),
            comment: getComment(this.context.checker, node)
          }));
        }
        return getRef(name);
      }
      getAlias(node) {
        const name = this.getName(node, node.name.text);
        return {
          kind: "alias",
          name,
          child: this.getTypeNode(node.type),
          types: this.getTypeParameters(node.typeParameters),
          comment: getComment(this.context.checker, node)
        };
      }
      getClass(node) {
        const { checker } = this.context;
        const type = checker.getTypeAtLocation(node);
        const decls = type.symbol.declarations.filter(ts3.isInterfaceDeclaration);
        const name = this.getName(node, node.name?.text);
        const docs = getAllJsDocs(checker, decls);
        decls.forEach((m) => this.enqueue(m));
        return {
          kind: "class",
          name,
          extends: this.getExtends(node.heritageClauses),
          implements: this.getImplements(node.heritageClauses),
          props: this.getClassMembers(node.members),
          types: this.getTypeParameters(node.typeParameters),
          comment: stringifyJsDocs(docs)
        };
      }
      getPropName(name) {
        if (!name) {
          return void 0;
        } else if (ts3.isIdentifier(name)) {
          return name.text;
        } else if (ts3.isStringLiteral(name)) {
          return name.text;
        } else if (ts3.isNumericLiteral(name)) {
          return name.text;
        } else if (ts3.isComputedPropertyName(name)) {
          return this.getExpression(name.expression);
        } else {
          return name.getText();
        }
      }
      getInterface(node) {
        const { checker, availableImports, root: root2 } = this.context;
        const type = checker.getTypeAtLocation(node);
        const decls = type.symbol.declarations.filter(ts3.isInterfaceDeclaration).filter((m) => !isImportedFile(m, root2, availableImports));
        const clauses = [];
        const props = [];
        const typeParameters = [];
        const name = this.getName(node, node.name.text);
        const docs = getAllJsDocs(checker, decls);
        decls.forEach((m) => {
          m.heritageClauses?.forEach((c) => {
            clauses.includes(c) || includeClauses(this.context, clauses, c, docs.tags);
          });
          m.members?.forEach((p) => {
            props.includes(p) || includeProp(props, p, (prop) => this.getPropName(prop), docs.tags);
          });
          m.typeParameters?.forEach((t, i) => {
            typeParameters.length === i && typeParameters.push(t);
          });
        });
        return {
          kind: "interface",
          name,
          extends: this.getExtends(clauses),
          props: this.getProps(props),
          types: this.getTypeParameters(typeParameters),
          comment: stringifyJsDocs(docs)
        };
      }
      getExpression(node) {
        if (ts3.isArrowFunction(node)) {
          return this.getMethodSignature(node);
        } else if (ts3.isNumericLiteral(node)) {
          return {
            kind: "literal",
            value: node.text
          };
        } else if (ts3.isStringLiteral(node)) {
          return {
            kind: "literal",
            value: JSON.stringify(node.text)
          };
        } else if (node.kind === ts3.SyntaxKind.TrueKeyword || node.kind === ts3.SyntaxKind.FalseKeyword) {
          return {
            kind: "boolean"
          };
        } else if (ts3.isIdentifier(node)) {
          const decl = getDeclarationFromNode(this.context.checker, node);
          this.enqueue(decl);
          return getRef(node.text);
        } else if (ts3.isPropertyAccessExpression(node)) {
          return {
            kind: "access",
            object: this.getExpression(node.expression),
            name: this.getExpression(node.name)
          };
        } else {
          return this.getInferredType(node);
        }
      }
      getVariableValue(node) {
        if (node.type) {
          return this.getTypeNode(node.type);
        } else if (node.initializer) {
          return this.getExpression(node.initializer);
        } else {
          const typeNode = this.convertToTypeNodeFromNode(node);
          return this.getTypeNode(typeNode);
        }
      }
      getVariable(node) {
        const name = this.getName(node, node.name.getText());
        return {
          kind: "const",
          name,
          value: this.getVariableValue(node),
          comment: getComment(this.context.checker, node)
        };
      }
      getEnum(node) {
        const symbol = getSymbol(this.context.checker, node);
        const name = this.getName(node, node.name.text);
        return {
          kind: "enumLiteral",
          name,
          const: symbol.flags === ts3.SymbolFlags.ConstEnum,
          values: this.getEnumMembers(node.members),
          comment: getComment(this.context.checker, node)
        };
      }
      includeInContext(node, createType) {
        const c = this.context;
        const symbol = getSymbol(c.checker, node);
        const global = isGlobal(symbol);
        const { external, fn } = getPackage(node, global, c.root, c.availableImports);
        if (!external) {
          this.refs.push(createType());
        } else {
          this.logVerbose(`Node from "${fn}" is external and should not be included.`);
        }
      }
      includeExportedTypeAlias(node) {
        this.includeInContext(node, () => this.getAlias(node));
      }
      includeDefaultExport(node) {
        const expr = node.expression;
        if (expr) {
          this.includeInContext(expr, () => getDefault(this.getDefaultExpression(node)));
        } else if (ts3.isFunctionDeclaration(node)) {
          const name = "_default";
          this.includeInContext(node, () => ({
            ...this.getMethodSignature(node),
            name
          }));
          this.includeInContext(node, () => getDefault(getRef(name)));
        } else if (ts3.isClassDeclaration(node)) {
          this.includeInContext(node, () => getDefault(this.getClass(node)));
        } else {
          this.printWarning("default export", node);
        }
      }
      includeExportedFunction(node) {
        this.includeInContext(node, () => this.getFunctionDeclaration(node));
      }
      includeExportedClass(node) {
        this.includeInContext(node, () => this.getClass(node));
      }
      includeExportedInterface(node) {
        const name = this.getName(node, node.name.text);
        const exists = this.refs.some((m) => m.kind === "interface" && m.name === name);
        if (!exists) {
          this.includeInContext(node, () => this.getInterface(node));
        } else {
          this.logVerbose(`Skipping already included interface "${name}".`);
        }
      }
      includeExportedVariable(node) {
        this.includeInContext(node, () => this.getVariable(node));
      }
      includeExportedVariables(node) {
        node.declarationList.declarations.forEach((decl) => this.includeExportedVariable(decl));
      }
      includeImportedValue(node) {
        const decl = node.symbol.declarations[0];
        this.enqueue(decl);
      }
      includeExportedEnum(node) {
        this.includeInContext(node, () => this.getEnum(node));
      }
      includeSelectedExports(elements) {
        elements.forEach((el) => {
          if (el.symbol) {
            const original = this.context.checker.getAliasedSymbol(el.symbol);
            if (original) {
              const decl = getDeclarationFromSymbol(this.context.checker, original);
              if (decl) {
                this.processNode(decl);
                this.swapName(original.name, el.symbol.name);
              }
            } else if (el.propertyName) {
              const symbol = this.context.checker.getExportSpecifierLocalTargetSymbol(el);
              if (symbol) {
                const decl = getDeclarationFromSymbol(this.context.checker, symbol);
                if (decl) {
                  this.processNode(decl);
                  this.swapName(el.propertyName.text, el.symbol.name);
                }
              }
            }
          }
        });
      }
      includeStarExports(node) {
        if (node.moduleSpecifier && ts3.isStringLiteral(node.moduleSpecifier)) {
          const moduleName = node.moduleSpecifier.text;
          const sourceFile = node.getSourceFile();
          this.context.forEachResolvedModule((value, originalName) => {
            if (originalName === moduleName) {
              const fileName = value?.resolvedModule?.resolvedFileName ?? value?.resolvedFileName;
              if (fileName) {
                const newFile = this.context.program.getSourceFile(fileName);
                ts3.forEachChild(newFile, (node2) => {
                  if (shouldInclude(node2)) {
                    this.enqueue(node2);
                  }
                });
              }
            }
          }, sourceFile);
        }
      }
      includeExportsDeclaration(node) {
        const { exportClause } = node;
        if (exportClause && ts3.isNamedExports(exportClause) && exportClause.elements) {
          this.includeSelectedExports(exportClause.elements);
        } else {
          this.includeStarExports(node);
        }
      }
      processModule(node) {
        const c = this.context;
        const name = node.name.text;
        const availableImportNames = Object.keys(this.context.availableImports);
        c.modules[name] = this.refs = c.modules[name] || [];
        c.moduleNames[name] = this.names = c.moduleNames[name] || /* @__PURE__ */ new Map();
        node.body?.forEachChild((subNode) => {
          if (isNodeExported(subNode) || availableImportNames.includes(name)) {
            this.enqueue(subNode);
          }
        });
      }
      processNode(node) {
        if (ts3.isTypeAliasDeclaration(node)) {
          this.includeExportedTypeAlias(node);
        } else if (isDefaultExport(node)) {
          this.includeDefaultExport(node);
        } else if (ts3.isVariableDeclaration(node)) {
          this.includeExportedVariable(node);
        } else if (ts3.isVariableStatement(node)) {
          this.includeExportedVariables(node);
        } else if (ts3.isFunctionDeclaration(node)) {
          this.includeExportedFunction(node);
        } else if (ts3.isInterfaceDeclaration(node)) {
          this.includeExportedInterface(node);
        } else if (ts3.isClassDeclaration(node)) {
          this.includeExportedClass(node);
        } else if (ts3.isImportSpecifier(node)) {
          this.includeImportedValue(node);
        } else if (ts3.isEnumDeclaration(node)) {
          this.includeExportedEnum(node);
        } else if (ts3.isTypeLiteralNode(node)) {
          this.logVerbose(`Skipping type literal node: ${node}`);
        } else if (ts3.isExportDeclaration(node)) {
          this.includeExportsDeclaration(node);
        } else if (ts3.isModuleDeclaration(node)) {
          this.modules.push(node);
        } else if (ts3.isImportTypeNode(node) || ts3.isPropertySignature(node) || ts3.isPropertyAssignment(node)) {
          this.logVerbose(`Skipping import type node: ${node}`);
        } else {
          this.printWarning("type", node);
        }
      }
      enqueue(item) {
        if (!item) {
        } else if (ts3.isEnumMember(item)) {
          this.enqueue(item.parent);
        } else if (!this.queue.includes(item) && !this.processed.includes(item)) {
          this.queue.push(item);
        }
      }
      processQueue() {
        while (this.queue.length || this.modules.length) {
          while (this.queue.length > 0) {
            const item = this.queue.shift();
            this.processed.push(item);
            this.processNode(item);
          }
          if (this.modules.length > 0) {
            const mod = this.modules.shift();
            this.processModule(mod);
          }
        }
      }
    };
  }
});

// src/input/typings.ts
function includeTypings(context, node) {
  if (shouldInclude(node)) {
    context.exports.push(node);
  } else {
    context.log.verbose(`Skipping typings from node: ${node}`);
  }
}
var init_typings = __esm({
  "src/input/typings.ts"() {
    init_helpers();
  }
});

// src/input/index.ts
var init_input = __esm({
  "src/input/index.ts"() {
    init_api();
    init_exports2();
    init_node2();
    init_typings();
  }
});

// src/commands.ts
function setupVisitorContext(name, root2, files2, imports, log, flags) {
  const rootNames = files2.filter((m) => !!m);
  const program = ts4.createProgram(rootNames, {
    allowJs: true,
    esModuleInterop: true,
    module: ts4.ModuleKind.ESNext,
    moduleResolution: ts4.ModuleResolutionKind.NodeJs,
    jsx: ts4.JsxEmit.React
  });
  const checker = program.getTypeChecker();
  const context = {
    modules: {
      [name]: []
    },
    moduleNames: {
      [name]: /* @__PURE__ */ new Map()
    },
    availableImports: {},
    usedImports: [],
    imports,
    exports: [],
    root: root2,
    name,
    checker,
    program,
    log,
    flags,
    forEachResolvedModule(cb, file) {
      if ("forEachResolvedModule" in program) {
        context.program.forEachResolvedModule(cb, file);
      } else {
        file.resolvedModules?.forEach(cb);
      }
    }
  };
  addAvailableImports(context, imports);
  addAmbientModules(context, imports);
  return context;
}
function fillExportsFromApi(context, apiPath, apiName) {
  const api = context.program.getSourceFile(apiPath);
  if (api) {
    ts4.forEachChild(api, (node) => includeApi(context, node, apiName));
  } else {
    context.log.error(
      `Cannot find the "${apiPath}" module. Are you sure it exists? Please run "npm i" to install missing modules.`
    );
  }
}
function fillExportsFromReferences(context, typingsPath) {
  const tp = context.program.getSourceFile(typingsPath);
  if (tp) {
    const ps = tp.pragmas?.get("reference");
    if (ps) {
      const values = Array.isArray(ps) ? ps.map((m) => m.arguments?.path?.value) : [ps.arguments?.path?.value];
      values.forEach((value) => {
        if (typeof value === "string") {
          const path = (0, import_path3.resolve)(typingsPath, "..", value);
          fillExportsFromTypes(context, path);
        }
      });
    }
  }
}
function fillExportsFromTypes(context, typingsPath) {
  const tp = context.program.getSourceFile(typingsPath);
  if (tp) {
    fillExportsFromReferences(context, typingsPath);
    ts4.forEachChild(tp, (node) => includeTypings(context, node));
  } else {
    context.log.warn(
      'Cannot find the provided typings. Check the "typings" field of your "package.json" for the correct path.'
    );
  }
}
function addAvailableImports(context, imports) {
  const sourceFiles = context.program.getSourceFiles();
  const remaining = [...imports];
  context.log.verbose(`Adding ${imports.length} imports from ${sourceFiles.length} source files.`);
  for (const sourceFile of sourceFiles) {
    if (remaining.length === 0) {
      break;
    }
    context.forEachResolvedModule((value, key) => {
      const index = remaining.indexOf(key);
      const fileName = value?.resolvedModule?.resolvedFileName ?? value?.resolvedFileName;
      if (!fileName) {
        context.log.verbose(`Skipping module without filename: ${value}.`);
      } else if (index === -1) {
        context.log.verbose(`Skipping module "${fileName}" as it does not match.`);
      } else {
        const file = context.program.getSourceFile(fileName);
        includeExports(context, key, file?.symbol);
        remaining.splice(index, 1);
      }
    }, sourceFile);
  }
}
function addAmbientModules(context, imports) {
  const modules = context.checker.getAmbientModules();
  context.log.verbose(`Adding ${modules.length} ambient modules.`);
  for (const module2 of modules) {
    const file = module2.declarations?.[0]?.getSourceFile()?.fileName;
    const lib = getLibName(file, context.root);
    if (imports.includes(lib)) {
      includeExports(context, module2.name, module2);
    }
  }
}
async function runAll(context, plugins, type) {
  const { log } = context;
  log.verbose(`Running the ${type}" plugins.`);
  for (const plugin of plugins) {
    try {
      if ("type" in plugin) {
        if (plugin.type === type) {
          await plugin.run(context);
        }
      } else if (typeof plugin[type] === "function") {
        const runner = plugin[type];
        await runner.call(plugin, context);
      }
    } catch (ex) {
      log.error(`The plugin "${plugin.name}" crashed: ${ex}`);
    }
  }
}
async function processVisitorContext(context, plugins) {
  const { log } = context;
  await runAll(context, plugins, "before-init");
  const visitor = new DeclVisitor(context);
  await runAll(context, plugins, "before-process");
  log.verbose("Processing the queue.");
  visitor.processQueue();
  await runAll(context, plugins, "after-process");
  await runAll(context, plugins, "before-stringify");
  log.verbose("Generating the string representation.");
}
async function generateDeclaration(options) {
  const {
    name,
    root: root2 = process.cwd(),
    imports = [],
    files: files2 = [],
    types: types2 = [],
    apis = [],
    plugins = [],
    logger = defaultLogger,
    logLevel = 3,
    noIgnore = false,
    noModuleDeclaration = false
  } = options;
  const log = wrapLogger(logger, logLevel);
  log.verbose(`Aggregating the sources from "${root2}".`);
  const sources = [
    ...files2.map((file) => findAppRoot(root2, file)),
    ...apis.map((api) => findAppRoot(root2, api.file)),
    ...types2.map((type) => findAppRoot(root2, type))
  ];
  log.verbose(`Setting up a visitor context for "${name}".`);
  const context = setupVisitorContext(name, root2, sources, imports, log, {
    noIgnore,
    noModuleDeclaration
  });
  log.verbose(`Starting API gathering in "${root2}".`);
  for (const api of apis) {
    const path = findAppRoot(root2, api.file);
    fillExportsFromApi(context, path, api.name);
  }
  log.verbose(`Starting type aggregation from "${root2}".`);
  for (const type of types2) {
    const path = findAppRoot(root2, type);
    fillExportsFromTypes(context, path);
  }
  log.verbose(`Processing the visitor context.`);
  await processVisitorContext(context, plugins);
  return stringifyDeclaration(context);
}
async function retrieveTypings(options) {
  const name = "main";
  const {
    root: root2 = process.cwd(),
    imports = [],
    files: files2 = [],
    types: types2 = [],
    plugins = [],
    logger = defaultLogger,
    logLevel = 3,
    noIgnore = false,
    noModuleDeclaration = false
  } = options;
  const log = wrapLogger(logger, logLevel);
  log.verbose(`Aggregating the sources from "${root2}".`);
  const sources = [...files2.map((file) => findAppRoot(root2, file)), ...types2.map((type) => findAppRoot(root2, type))];
  log.verbose(`Setting up a visitor context for "${name}".`);
  const context = setupVisitorContext(name, root2, sources, imports, log, {
    noIgnore,
    noModuleDeclaration
  });
  log.verbose(`Starting type aggregation from "${root2}".`);
  for (const type of types2) {
    const path = findAppRoot(root2, type);
    fillExportsFromTypes(context, path);
  }
  log.verbose(`Processing the visitor context.`);
  await processVisitorContext(context, plugins);
  return context.modules.main;
}
var ts4, import_path3;
var init_commands = __esm({
  "src/commands.ts"() {
    ts4 = __toESM(require("typescript"));
    import_path3 = require("path");
    init_output();
    init_helpers();
    init_logger();
    init_input();
  }
});

// src/refs.ts
function findRefs(types2) {
  const queue = [...types2];
  const refs = [];
  for (let i = 0; i < queue.length; i++) {
    const type = queue[i];
    switch (type?.kind) {
      case "ref":
        refs.push(type);
        break;
      case "alias":
        queue.push(type.child, ...type.types);
        break;
      case "function":
        queue.push(...type.parameters, type.returnType, ...type.types);
        break;
      case "default":
        queue.push(type.value);
        break;
      case "const":
        queue.push(type.value);
        break;
      case "interface":
        queue.push(...type.extends, type.mapped, ...type.props, ...type.types);
        break;
      case "class":
        queue.push(...type.extends, ...type.implements, ...type.props, ...type.types);
        break;
      case "enumLiteral":
        queue.push(...type.values);
        break;
      case "member":
        queue.push(type.value);
        break;
      case "prop":
        queue.push(type.valueType);
        break;
      case "typeParameter":
        queue.push(type.constraint, type.parameter);
        break;
      case "parameter":
        queue.push(type.value);
        break;
      case "union":
        queue.push(...type.types);
        break;
      case "intersection":
        queue.push(...type.types);
        break;
      case "index":
        queue.push(type.valueType, ...type.parameters);
        break;
      case "indexedAccess":
        queue.push(type.index, type.object);
        break;
      case "conditional":
        queue.push(type.alternate, type.check, type.extends, type.primary);
        break;
      case "substitution":
        queue.push(type.variable);
        break;
      case "tuple-prop":
        queue.push(type.valueType);
        break;
      case "tuple":
        queue.push(...type.types);
        break;
      case "constructor":
        queue.push(...type.parameters);
        break;
      case "keyof":
        queue.push(type.value);
        break;
      case "readonly":
        queue.push(type.value);
        break;
      case "unique":
        queue.push(type.value);
        break;
      case "predicate":
        queue.push(type.value);
        break;
      case "mapped":
        queue.push(type.constraint, type.value);
        break;
      case "infer":
        queue.push(type.parameter);
        break;
      case "new":
        queue.push(...type.parameters, type.returnType, ...type.types);
        break;
      case "get":
        queue.push(type.type);
        break;
      case "set":
        queue.push(...type.parameters);
        break;
      case "parenthesis":
        queue.push(type.value);
        break;
      case "rest":
        queue.push(type.value);
        break;
      case "template":
        queue.push(...type.parts.map((m) => typeof m !== "string" ? m : void 0).filter(Boolean));
        break;
      default:
        break;
    }
  }
  return refs;
}
function updateImports(imprts, refs) {
  for (let i = imprts.length; i--; ) {
    const refName = getLibRefName(imprts[i]);
    const prefix = `${refName}.`;
    const hasRef = refs.some((ref) => ref.refName.startsWith(prefix));
    if (!hasRef) {
      imprts.splice(i, 1);
    }
  }
}
var init_refs = __esm({
  "src/refs.ts"() {
    init_helpers();
  }
});

// src/plugins.ts
function createExcludePlugin(moduleNames) {
  return {
    name: "exclude-plugin",
    "after-process"(context) {
      for (const name of moduleNames) {
        delete context.modules[name];
      }
    }
  };
}
function createDiffPlugin(originalFile) {
  const state = {};
  return {
    name: "diff-plugin",
    async "before-init"(context) {
      const refs = await retrieveTypings({
        root: (0, import_path4.dirname)(originalFile),
        types: [originalFile],
        plugins: [],
        logger: context.log,
        imports: context.imports,
        log: context.log
      });
      state.types = refs;
      state.cache = refs.map((ref) => stringifyNode(ref));
    },
    async "after-process"(context) {
      const mod = context.modules[context.name];
      for (let i = mod.length; i--; ) {
        const node = mod[i];
        const current = stringifyNode(node);
        if (state.cache.indexOf(current) !== -1) {
          mod.splice(i, 1);
        } else if (node.kind === "interface") {
          const mergedInterface = state.types.find((m) => m.kind === "interface" && m.name === node.name);
          if (mergedInterface) {
            const originals = mergedInterface.props.map((p) => stringifyNode(p));
            for (let j = node.props.length; j--; ) {
              const prop = stringifyNode(node.props[j]);
              if (originals.includes(prop)) {
                node.props.splice(j, 1);
              }
            }
          }
        }
      }
      const refs = findRefs(mod);
      updateImports(context.usedImports, refs);
    }
  };
}
var import_path4;
var init_plugins = __esm({
  "src/plugins.ts"() {
    import_path4 = require("path");
    init_commands();
    init_stringify();
    init_refs();
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  addAmbientModules: () => addAmbientModules,
  addAvailableImports: () => addAvailableImports,
  createDiffPlugin: () => createDiffPlugin,
  createExcludePlugin: () => createExcludePlugin,
  fillExportsFromApi: () => fillExportsFromApi,
  fillExportsFromReferences: () => fillExportsFromReferences,
  fillExportsFromTypes: () => fillExportsFromTypes,
  generateDeclaration: () => generateDeclaration,
  processVisitorContext: () => processVisitorContext,
  retrieveTypings: () => retrieveTypings,
  setupVisitorContext: () => setupVisitorContext
});
var init_src = __esm({
  "src/index.ts"() {
    init_commands();
    init_plugins();
  }
});

// src/cli.ts
var yargs = __toESM(require_yargs3());
var import_path5 = require("path");
var import_fs = require("fs");
var import_child_process = require("child_process");
var root = process.cwd();
var args = yargs.command("$0 [entry...]", "Bundles the found type declarations into a single d.ts file.", (args2) => {
  return args2.positional("entry", {
    default: [],
    description: "The entry level modules to be consumed.",
    array: true,
    type: "string"
  }).describe("name", "Sets the name of the module.").string("name").default("name", getName(root)).describe("files", "Sets additional files to be referenced by TypeScript.").array("files").default("files", []).demandOption("files").describe("types", "Sets additional type modules to export via their file path.").array("types").default("types", []).describe("apis", 'Sets the interfaces to include using "InterfaceName:FilePath" syntax.').array("apis").default("apis", []).describe("imports", "Sets the imports to avoid bundling in via their package names.").array("imports").default("imports", []).describe("ignore", "Actively uses the ignore comment to drop properties.").boolean("ignore").default("ignore", true).describe("module-declaration", 'Wraps the declaration in a "declare module" block.').boolean("module-declaration").default("module-declaration", true).describe("out", "Sets the path to the output file.").string("out").default("out", "./dist/index.d.ts");
}).parse();
function getName(dir) {
  const location = (0, import_path5.resolve)(dir, "package.json");
  if (!(0, import_fs.existsSync)(location)) {
    const parent = (0, import_path5.resolve)(dir, "..");
    if (parent !== dir) {
      return getName(parent);
    }
    return void 0;
  }
  return require(location).name;
}
function getApiDecl(api) {
  const [name, file] = api.split(":");
  return { name, file };
}
function writeFile(path, content) {
  const full = (0, import_path5.resolve)(root, path);
  const dir = (0, import_path5.dirname)(full);
  if (!(0, import_fs.existsSync)(dir)) {
    (0, import_fs.mkdirSync)(dir, { recursive: true });
  }
  (0, import_fs.writeFileSync)(full, content, "utf8");
}
function runScript(script, cwd) {
  return new Promise((resolve4, reject) => {
    const cp = (0, import_child_process.exec)(script, { cwd });
    cp.on("close", (code, signal) => code === 0 ? resolve4() : reject(new Error(signal)));
  });
}
var files = [...args.entry, ...args.files];
var types = [...args.entry, ...args.types];
async function runCli() {
  const { generateDeclaration: generateDeclaration2 } = (init_src(), __toCommonJS(src_exports));
  const content = await generateDeclaration2({
    root,
    files,
    types,
    name: args.name,
    apis: args.apis.map(getApiDecl),
    noModuleDeclaration: !args["module-declaration"],
    imports: args.imports,
    noIgnore: !args.ignore
  });
  writeFile(args.out, content);
}
if (!args.name) {
  console.error("Please provide a name for the module.");
  process.exit(1);
}
if (files.length === 0) {
  console.error("At least one input file expected.");
  process.exit(1);
}
(async () => {
  try {
    require("typescript");
  } catch {
    console.warn(`TypeScript is missing. Trying to install ...`);
    await runScript("npm install typescript@^5", (0, import_path5.resolve)(__dirname, ".."));
  }
  try {
    await runCli();
  } catch {
    process.exit(1);
  }
  process.exit(0);
})();
