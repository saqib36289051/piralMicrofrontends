"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildConfiguration = exports.defaultConfig = exports.mergeConfiguration = exports.readConfiguration = exports.makePathsAbsolute = void 0;
const chalk = __importStar(require("chalk"));
const path_1 = require("path");
const fs_1 = require("fs");
const info_1 = require("../info");
const helpers_1 = require("../helpers");
function makePathsAbsolute(baseDir, config) {
    if (config) {
        if (config.directory) {
            config.directory = (0, path_1.resolve)(baseDir, config.directory);
        }
        if (config.client) {
            config.client = (0, path_1.resolve)(baseDir, config.client);
        }
        if (config.injectors) {
            for (const name of Object.keys(config.injectors)) {
                const injector = config.injectors[name];
                const directory = injector.directory;
                const localDir = injector.baseDir;
                if (typeof directory === 'string') {
                    injector.directory = (0, path_1.resolve)(baseDir, directory);
                }
                else if (Array.isArray(directory)) {
                    injector.directory = directory.map((dir) => (0, path_1.resolve)(baseDir, dir));
                }
                if (typeof localDir === 'string') {
                    injector.baseDir = (0, path_1.resolve)(baseDir, localDir);
                }
                else {
                    injector.baseDir = baseDir;
                }
            }
        }
        if (Array.isArray(config.middlewares)) {
            for (const middleware of config.middlewares) {
                const localDir = middleware.baseDir;
                if (typeof localDir === 'string') {
                    middleware.baseDir = (0, path_1.resolve)(baseDir, localDir);
                }
                else {
                    middleware.baseDir = baseDir;
                }
            }
        }
        if (Array.isArray(config.sources)) {
            config.sources = config.sources.map((dir) => (0, path_1.resolve)(baseDir, dir));
        }
    }
}
exports.makePathsAbsolute = makePathsAbsolute;
function readConfiguration(path) {
    if (path && (0, fs_1.existsSync)(path)) {
        const dir = (0, path_1.dirname)(path);
        try {
            const content = (0, fs_1.readFileSync)(path, 'utf8');
            const config = JSON.parse(content);
            if (config) {
                makePathsAbsolute(dir, config);
                return config;
            }
        }
        catch (e) {
            const msg = `Error reading configuration from "${path}" in "${dir}": ${e}`;
            throw new Error(`${chalk.red('ERR')} ${chalk.white(msg)}`);
        }
    }
    return {};
}
exports.readConfiguration = readConfiguration;
function mergeObjects(sources, select) {
    const obj = {};
    for (const source of sources) {
        const value = select(source);
        if (value && typeof value === 'object') {
            (0, helpers_1.deepMerge)(obj, value);
        }
    }
    return obj;
}
function mergeArrays(sources, select, compare) {
    const arr = [];
    for (const source of sources) {
        const value = select(source);
        if (value && Array.isArray(value)) {
            for (let i = arr.length; i--;) {
                const a = arr[i];
                for (const b of value) {
                    if (compare(a, b)) {
                        arr.splice(i, 1);
                    }
                }
            }
            arr.push(...value);
        }
    }
    return arr;
}
function mergeConfiguration(options = {}, ...configs) {
    const { initial = {}, required = {} } = options;
    const sources = [initial, ...configs, required];
    const result = Object.assign({}, ...sources);
    if (options.cert !== undefined || options.key !== undefined) {
        result.ssl = {
            cert: options.cert || (result.ssl && result.ssl.cert),
            key: options.key || (result.ssl && result.ssl.key),
        };
    }
    if (options.skipApi) {
        result.api = false;
    }
    if (options.logs) {
        result.logLevel = options.logs;
    }
    if (options.dir) {
        result.directory = options.dir;
    }
    if (options.name) {
        result.name = options.name;
    }
    if (options.port) {
        result.port = options.port;
    }
    if (options.host) {
        result.host = options.host;
    }
    result.injectors = mergeObjects(sources, (m) => m.injectors);
    result.map = mergeObjects(sources, (m) => m.map);
    result.sources = mergeArrays(sources, (m) => m.sources, (a, b) => a === b);
    result.injectorDirs = mergeArrays(sources, (m) => m.injectorDirs, (a, b) => a === b);
    result.middlewares = mergeArrays(sources, (m) => m.middlewares, (a, b) => a.source === b.source);
    return result;
}
exports.mergeConfiguration = mergeConfiguration;
const certDir = (0, path_1.resolve)(info_1.rootDir, 'cert');
exports.defaultConfig = {
    name: `${info_1.name} v${info_1.version}`,
    host: '0.0.0.0',
    port: 9000,
    directory: (0, path_1.resolve)(info_1.currentDir, 'mocks'),
    client: 'kras-management-portal',
    ssl: {
        cert: (0, path_1.resolve)(certDir, 'server.crt'),
        key: (0, path_1.resolve)(certDir, 'server.key'),
    },
    uploadLimit: parseInt(process.env.FILE_SIZE_LIMIT, 10) || 10, // default: 10 MB
    logLevel: 'error',
    api: '/manage',
    ws: true,
    map: {},
    auth: undefined,
    middlewares: [],
    injectorDirs: [],
    sources: [],
    injectors: {},
};
function buildConfiguration(config = {}) {
    const newConfig = Object.assign({}, exports.defaultConfig, config);
    const newMap = {};
    Object.keys(newConfig.map || {}).forEach((oldKey) => {
        const newKey = oldKey.replace(/\/+$/, '');
        newMap[newKey] = newConfig.map[oldKey];
    });
    newConfig.map = newMap;
    return newConfig;
}
exports.buildConfiguration = buildConfiguration;
