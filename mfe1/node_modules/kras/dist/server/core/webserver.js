"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebServer = void 0;
const express_1 = __importDefault(require("express"));
const express_ws_1 = __importDefault(require("express-ws"));
const multer_1 = __importDefault(require("multer"));
const http_1 = require("http");
const https_1 = require("https");
const body_parser_1 = require("body-parser");
const events_1 = require("events");
const readSsl_1 = require("./readSsl");
const proxy_1 = require("./proxy");
function findHook(hooks, req) {
    let closest = undefined;
    let highscore = 0;
    for (const hook of hooks) {
        const score = hook.rate(req);
        if (score === 1) {
            return hook;
        }
        else if (score > highscore) {
            highscore = score;
            closest = hook;
        }
    }
    if (closest) {
        return closest;
    }
}
function getWsTargets(mapping) {
    const keys = Object.keys(mapping);
    if (keys.length) {
        const targets = keys.filter((key) => {
            const address = mapping[key];
            if (typeof address === 'string') {
                return address.match('^wss?://');
            }
            return address;
        });
        if (targets.length) {
            return targets;
        }
    }
    return ['*'];
}
class WebServer extends events_1.EventEmitter {
    constructor(config = {}) {
        super();
        this.hooks = [];
        this.routes = [];
        const mapping = config.map || {};
        const ssl = (0, readSsl_1.readSsl)(config.ssl);
        this.targets = getWsTargets(mapping);
        this.port = config.port || 9000;
        this.host = config.host || '0.0.0.0';
        this.app = (0, express_1.default)();
        this.protocol = ssl ? 'https' : 'http';
        this.server = ssl ? (0, https_1.createServer)(ssl, this.app) : (0, http_1.createServer)(this.app);
        this.wsOptions = typeof config.ws === 'object' ? config.ws : undefined;
        this.ws = !!config.ws;
        const sizeInMB = typeof config.uploadLimit === 'number' ? config.uploadLimit : 10;
        const upload = (0, multer_1.default)({
            storage: multer_1.default.memoryStorage(),
            limits: { files: 5, fileSize: sizeInMB * 1024 * 1024 },
        });
        this.app.use((req, res, next) => {
            //prepares the req / res system
            req.addedHeaders = {};
            req.removedHeaders = [];
            req.addedQuery = {};
            req.removedQuery = ['_'];
            res.middlewares = [];
            res.prepared = undefined;
            next();
        });
        this.app.use(upload.any());
        this.app.use((0, body_parser_1.text)({
            type: (req) => {
                return !(req.headers['content-type'] && req.headers['content-type'].search('multipart/form-data') !== -1);
            },
            limit: '50mb',
        }));
        this.targets.forEach((target) => this.app.ws(`${target}/*`, (ws, req) => {
            const url = req.url.replace('/.websocket', '').substr(target.length);
            const id = Date.now() % 100000000;
            this.emit('user-connected', {
                id,
                ws,
                target,
                url,
                req,
            });
            ws.on('close', () => this.emit('user-disconnected', {
                id,
                ws,
                target,
                url,
                req,
            }));
        }));
    }
    get ws() {
        const ws = this.sockets && this.sockets.getWss();
        return !!ws;
    }
    set ws(value) {
        const ws = this.sockets && this.sockets.getWss();
        if (!value && ws) {
            this.emit('info', 'Turned off WebSocket support');
            ws.close();
            this.sockets = undefined;
        }
        else if (!ws && value) {
            this.emit('info', 'Turned on WebSocket support');
            this.sockets = (0, express_ws_1.default)(this.app, this.server, {
                wsOptions: this.wsOptions,
            });
            const wsServer = this.sockets.getWss();
            wsServer.on('connection', (socket) => {
                socket.on('error', (err) => {
                    this.emit('error', `Problem with the WS socket connection: ${err}`);
                });
            });
            wsServer.on('error', (err) => {
                this.emit('error', `Error with WS server: ${err}`);
            });
        }
    }
    add(hook) {
        if (Array.isArray(hook)) {
            this.hooks.push.apply(this.hooks, hook);
        }
        else if (typeof hook === 'object') {
            this.hooks.push(hook);
        }
        return this;
    }
    remove(hook) {
        const index = this.hooks.indexOf(hook);
        this.hooks.splice(index, 1);
        return this;
    }
    at(...segments) {
        const endpoint = segments.join('/');
        const app = this.app;
        const api = {
            get(handler) {
                app.get(endpoint, handler);
                return api;
            },
            put(handler) {
                app.put(endpoint, handler);
                return api;
            },
            delete(handler) {
                app.delete(endpoint, handler);
                return api;
            },
            post(handler) {
                app.post(endpoint, handler);
                return api;
            },
            any(handler) {
                app.all(endpoint, handler);
                return api;
            },
            feed(handler) {
                app.ws(endpoint, handler);
                return api;
            },
        };
        this.routes.push(endpoint);
        return api;
    }
    setup() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setup();
            this.app.all('*', (req, res) => {
                if (req.method !== 'OPTIONS') {
                    const hook = findHook(this.hooks, req);
                    if (!hook) {
                        res.status(404);
                        return res.end('Page could not be found.');
                    }
                    return hook.handle(req, res);
                }
                this.emit('debug', `Handled CORS request to ${req.url}`);
                return (0, proxy_1.corsHandler)(req, res);
            });
            return yield new Promise((resolve) => {
                this.server.listen(this.port, this.host, () => {
                    this.emit('open', {
                        port: this.port,
                        protocol: this.protocol,
                        routes: this.routes,
                    });
                    resolve();
                });
            });
        });
    }
    stop() {
        this.emit('close');
        return new Promise((resolve) => this.server.close(() => resolve()));
    }
    broadcast(msg) {
        const sockets = this.sockets;
        if (sockets) {
            const isObject = typeof msg === 'object';
            const data = isObject ? JSON.stringify(msg) : (msg || '').toString();
            const targets = this.targets;
            const wst = targets.length !== 1 || targets[0] !== '*' ? targets : undefined;
            this.emit('broadcast', { content: data, from: 'kras', to: '*', remote: false });
            const socket = sockets.getWss(wst);
            if (socket) {
                const clients = socket.clients;
                this.emit('debug', `Broadcasting to ${clients.size} client(s)`);
                clients.forEach((client) => client.send(data));
            }
        }
    }
}
exports.WebServer = WebServer;
