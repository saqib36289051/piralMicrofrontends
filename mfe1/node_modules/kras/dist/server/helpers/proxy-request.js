"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.proxyRequest = exports.defaultProxyHeaders = void 0;
const axios_1 = __importDefault(require("axios"));
const https_1 = require("https");
const build_response_1 = require("./build-response");
function convertHeaders(headers) {
    const result = {};
    Object.entries(headers).forEach(([name, value]) => {
        if (Array.isArray(value)) {
            result[name] = value.map((n) => `${n}`);
        }
        else {
            result[name] = `${value}`;
        }
    });
    return result;
}
exports.defaultProxyHeaders = [
    'authorization',
    'accept',
    'content-type',
    'cookie',
    'accept-language',
    'user-agent',
    'if-match',
    'if-range',
    'if-unmodified-since',
    'if-none-match',
    'if-modified-since',
    'pragma',
    'range',
];
function proxyRequest(req) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield axios_1.default.request({
            url: req.url,
            httpsAgent: new https_1.Agent(Object.assign({ rejectUnauthorized: false }, req.agentOptions)),
            responseType: 'arraybuffer',
            method: req.method,
            validateStatus: () => true,
            proxy: req.proxy,
            headers: req.headers,
            data: req.body,
            maxRedirects: req.redirect ? undefined : 0,
        });
        return (0, build_response_1.fromNode)({
            headers: convertHeaders(res.headers),
            request: {
                href: req.url,
            },
            statusCode: res.status,
            statusMessage: res.statusText,
            url: res.config.url,
        }, res.data, req.injector);
    });
}
exports.proxyRequest = proxyRequest;
