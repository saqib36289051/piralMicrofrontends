"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryEvaluate = void 0;
const helpers_1 = require("../helpers");
function errorHandler() {
    return undefined;
}
function tryEvaluate(script) {
    try {
        const handler = (0, helpers_1.asScript)(script.file);
        if (typeof handler !== 'function') {
            throw new Error('Does not export a function - it will be ignored.');
        }
        script.error = undefined;
        script.handler = handler;
    }
    catch (e) {
        script.error = e;
        script.handler = errorHandler;
    }
}
exports.tryEvaluate = tryEvaluate;
class ScriptInjector {
    constructor(options, config, core) {
        this.files = [];
        const directory = options.directory || config.sources || config.directory;
        this.config = options;
        this.core = core;
        this.krasConfig = config;
        this.watcher = (0, helpers_1.watch)(directory, '**/*.js', (ev, fileName, position) => {
            switch (ev) {
                case 'create':
                case 'update':
                    return this.load(fileName, position);
                case 'delete':
                    return this.unload(fileName);
            }
        });
    }
    getOptions() {
        return {
            directories: (0, helpers_1.editDirectoryOption)(this.watcher.directories),
            files: (0, helpers_1.editFileOption)(this.files),
            extended: {
                description: 'The options available to all script files via the context argument.',
                title: 'Extended Configuration',
                type: 'json',
                value: JSON.stringify(this.config.extended || {}, undefined, 2),
            },
        };
    }
    setOptions(options) {
        for (const { name, active } of options.files) {
            const script = this.files.find((f) => f.file === name);
            if (script && typeof active === 'boolean') {
                script.active = active;
            }
        }
        this.config.extended = JSON.parse(options.extended || '{}');
        this.watcher.directories = options.directories;
    }
    get name() {
        return 'script-injector';
    }
    get active() {
        return this.config.active;
    }
    set active(value) {
        this.config.active = value;
    }
    unload(fileName) {
        const index = this.files.findIndex(({ file }) => file === fileName);
        if (index !== -1) {
            this.files.splice(index, 1);
        }
    }
    load(fileName, position) {
        var _a;
        const file = this.files.find(({ file }) => file === fileName);
        const active = (_a = file === null || file === void 0 ? void 0 : file.active) !== null && _a !== void 0 ? _a : true;
        const script = { file: fileName, active };
        tryEvaluate(script);
        if (script.error) {
            this.core.emit('error', script.error);
        }
        this.unload(fileName);
        this.files.splice(position, 0, script);
    }
    dispose() {
        this.watcher.close();
    }
    handle(req) {
        for (const { file, active, handler } of this.files) {
            const name = this.name;
            if (active) {
                const builder = ({ statusCode = 200, statusText = '', headers = {}, content = '' }) => (0, helpers_1.fromJson)(req.url, statusCode, statusText, headers, content, {
                    name,
                    file: {
                        name: file,
                    },
                });
                const extended = this.config.extended || {};
                const ctx = Object.assign({ $server: this.core, $options: this.config, $config: this.krasConfig }, extended);
                const res = handler(ctx, req, builder);
                if (res) {
                    return res;
                }
            }
        }
    }
}
exports.default = ScriptInjector;
